
Robot_Firmware_v17.2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002440  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000024  20400000  00402440  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000144  20400024  00402464  00020024  2**2
                  ALLOC
  3 .heap         00000200  20400168  004025a8  00020024  2**0
                  ALLOC
  4 .stack        00000400  20400368  004027a8  00020024  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020024  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020052  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001e3c9  00000000  00000000  000200ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003db1  00000000  00000000  0003e474  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000c13f  00000000  00000000  00042225  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000c60  00000000  00000000  0004e364  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000bf8  00000000  00000000  0004efc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00039061  00000000  00000000  0004fbbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00017dd0  00000000  00000000  00088c1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    001232a3  00000000  00000000  000a09ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00001e98  00000000  00000000  001c3c90  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	68 07 40 20 d5 01 40 00 d1 01 40 00 d1 01 40 00     h.@ ..@...@...@.
  400010:	d1 01 40 00 d1 01 40 00 d1 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	d1 01 40 00 d1 01 40 00 00 00 00 00 d1 01 40 00     ..@...@.......@.
  40003c:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  40004c:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  40005c:	d1 01 40 00 d1 01 40 00 00 00 00 00 89 12 40 00     ..@...@.......@.
  40006c:	7d 12 40 00 00 00 00 00 d1 01 40 00 d1 01 40 00     }.@.......@...@.
  40007c:	d1 01 40 00 d1 01 40 00 00 00 00 00 d1 01 40 00     ..@...@.......@.
  40008c:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  40009c:	d5 19 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  4000ac:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  4000bc:	4d 14 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     M.@...@...@...@.
	...
  4000e0:	d1 01 40 00 d1 01 40 00 00 00 00 00 d1 01 40 00     ..@...@.......@.
  4000f0:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  400100:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  400110:	d1 01 40 00 00 00 00 00 00 00 00 00 00 00 00 00     ..@.............
  400120:	d1 01 40 00 d1 01 40 00 d1 01 40 00 d1 01 40 00     ..@...@...@...@.
  400130:	61 14 40 00 d1 01 40 00 00 00 00 00 d1 01 40 00     a.@...@.......@.
  400140:	d1 01 40 00 d1 01 40 00 00 00 00 00 00 00 00 00     ..@...@.........
  400150:	d1 01 40 00 d1 01 40 00                             ..@...@.

00400158 <__do_global_dtors_aux>:
  400158:	b510      	push	{r4, lr}
  40015a:	4c05      	ldr	r4, [pc, #20]	; (400170 <__do_global_dtors_aux+0x18>)
  40015c:	7823      	ldrb	r3, [r4, #0]
  40015e:	b933      	cbnz	r3, 40016e <__do_global_dtors_aux+0x16>
  400160:	4b04      	ldr	r3, [pc, #16]	; (400174 <__do_global_dtors_aux+0x1c>)
  400162:	b113      	cbz	r3, 40016a <__do_global_dtors_aux+0x12>
  400164:	4804      	ldr	r0, [pc, #16]	; (400178 <__do_global_dtors_aux+0x20>)
  400166:	f3af 8000 	nop.w
  40016a:	2301      	movs	r3, #1
  40016c:	7023      	strb	r3, [r4, #0]
  40016e:	bd10      	pop	{r4, pc}
  400170:	20400024 	.word	0x20400024
  400174:	00000000 	.word	0x00000000
  400178:	00402440 	.word	0x00402440

0040017c <frame_dummy>:
  40017c:	4b0c      	ldr	r3, [pc, #48]	; (4001b0 <frame_dummy+0x34>)
  40017e:	b143      	cbz	r3, 400192 <frame_dummy+0x16>
  400180:	480c      	ldr	r0, [pc, #48]	; (4001b4 <frame_dummy+0x38>)
  400182:	490d      	ldr	r1, [pc, #52]	; (4001b8 <frame_dummy+0x3c>)
  400184:	b510      	push	{r4, lr}
  400186:	f3af 8000 	nop.w
  40018a:	480c      	ldr	r0, [pc, #48]	; (4001bc <frame_dummy+0x40>)
  40018c:	6803      	ldr	r3, [r0, #0]
  40018e:	b923      	cbnz	r3, 40019a <frame_dummy+0x1e>
  400190:	bd10      	pop	{r4, pc}
  400192:	480a      	ldr	r0, [pc, #40]	; (4001bc <frame_dummy+0x40>)
  400194:	6803      	ldr	r3, [r0, #0]
  400196:	b933      	cbnz	r3, 4001a6 <frame_dummy+0x2a>
  400198:	4770      	bx	lr
  40019a:	4b09      	ldr	r3, [pc, #36]	; (4001c0 <frame_dummy+0x44>)
  40019c:	2b00      	cmp	r3, #0
  40019e:	d0f7      	beq.n	400190 <frame_dummy+0x14>
  4001a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001a4:	4718      	bx	r3
  4001a6:	4b06      	ldr	r3, [pc, #24]	; (4001c0 <frame_dummy+0x44>)
  4001a8:	2b00      	cmp	r3, #0
  4001aa:	d0f5      	beq.n	400198 <frame_dummy+0x1c>
  4001ac:	4718      	bx	r3
  4001ae:	bf00      	nop
  4001b0:	00000000 	.word	0x00000000
  4001b4:	00402440 	.word	0x00402440
  4001b8:	20400028 	.word	0x20400028
  4001bc:	00402440 	.word	0x00402440
  4001c0:	00000000 	.word	0x00000000

004001c4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001c4:	b508      	push	{r3, lr}
	system_init();
  4001c6:	4b01      	ldr	r3, [pc, #4]	; (4001cc <atmel_start_init+0x8>)
  4001c8:	4798      	blx	r3
  4001ca:	bd08      	pop	{r3, pc}
  4001cc:	004005b1 	.word	0x004005b1

004001d0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001d0:	e7fe      	b.n	4001d0 <Dummy_Handler>
	...

004001d4 <Reset_Handler>:
{
  4001d4:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001d6:	4b10      	ldr	r3, [pc, #64]	; (400218 <Reset_Handler+0x44>)
  4001d8:	4a10      	ldr	r2, [pc, #64]	; (40021c <Reset_Handler+0x48>)
  4001da:	429a      	cmp	r2, r3
  4001dc:	d009      	beq.n	4001f2 <Reset_Handler+0x1e>
  4001de:	4b0e      	ldr	r3, [pc, #56]	; (400218 <Reset_Handler+0x44>)
  4001e0:	4a0e      	ldr	r2, [pc, #56]	; (40021c <Reset_Handler+0x48>)
  4001e2:	e003      	b.n	4001ec <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001e4:	6811      	ldr	r1, [r2, #0]
  4001e6:	6019      	str	r1, [r3, #0]
  4001e8:	3304      	adds	r3, #4
  4001ea:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  4001ec:	490c      	ldr	r1, [pc, #48]	; (400220 <Reset_Handler+0x4c>)
  4001ee:	428b      	cmp	r3, r1
  4001f0:	d3f8      	bcc.n	4001e4 <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  4001f2:	4b0c      	ldr	r3, [pc, #48]	; (400224 <Reset_Handler+0x50>)
  4001f4:	e002      	b.n	4001fc <Reset_Handler+0x28>
                *pDest++ = 0;
  4001f6:	2200      	movs	r2, #0
  4001f8:	601a      	str	r2, [r3, #0]
  4001fa:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  4001fc:	4a0a      	ldr	r2, [pc, #40]	; (400228 <Reset_Handler+0x54>)
  4001fe:	4293      	cmp	r3, r2
  400200:	d3f9      	bcc.n	4001f6 <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  400202:	4a0a      	ldr	r2, [pc, #40]	; (40022c <Reset_Handler+0x58>)
  400204:	4b0a      	ldr	r3, [pc, #40]	; (400230 <Reset_Handler+0x5c>)
  400206:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  40020a:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  40020c:	4b09      	ldr	r3, [pc, #36]	; (400234 <Reset_Handler+0x60>)
  40020e:	4798      	blx	r3
        main();
  400210:	4b09      	ldr	r3, [pc, #36]	; (400238 <Reset_Handler+0x64>)
  400212:	4798      	blx	r3
  400214:	e7fe      	b.n	400214 <Reset_Handler+0x40>
  400216:	bf00      	nop
  400218:	20400000 	.word	0x20400000
  40021c:	00402440 	.word	0x00402440
  400220:	20400024 	.word	0x20400024
  400224:	20400024 	.word	0x20400024
  400228:	20400168 	.word	0x20400168
  40022c:	e000ed00 	.word	0xe000ed00
  400230:	00400000 	.word	0x00400000
  400234:	004020ad 	.word	0x004020ad
  400238:	00401c15 	.word	0x00401c15

0040023c <TIMER_0_init>:
 * \brief Timer initialization function
 *
 * Enables Timer peripheral, clocks and initializes Timer driver
 */
static void TIMER_0_init(void)
{
  40023c:	b508      	push	{r3, lr}
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40023e:	4b08      	ldr	r3, [pc, #32]	; (400260 <TIMER_0_init+0x24>)
  400240:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  400242:	f413 0f00 	tst.w	r3, #8388608	; 0x800000
  400246:	d103      	bne.n	400250 <TIMER_0_init+0x14>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400248:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  40024c:	4b04      	ldr	r3, [pc, #16]	; (400260 <TIMER_0_init+0x24>)
  40024e:	611a      	str	r2, [r3, #16]
	_pmc_enable_periph_clock(ID_TC0_CHANNEL0);
	TIMER_0_PORT_init();
	timer_init(&TIMER_0, TC0, _tc_get_timer());
  400250:	4b04      	ldr	r3, [pc, #16]	; (400264 <TIMER_0_init+0x28>)
  400252:	4798      	blx	r3
  400254:	4602      	mov	r2, r0
  400256:	4904      	ldr	r1, [pc, #16]	; (400268 <TIMER_0_init+0x2c>)
  400258:	4804      	ldr	r0, [pc, #16]	; (40026c <TIMER_0_init+0x30>)
  40025a:	4b05      	ldr	r3, [pc, #20]	; (400270 <TIMER_0_init+0x34>)
  40025c:	4798      	blx	r3
  40025e:	bd08      	pop	{r3, pc}
  400260:	400e0600 	.word	0x400e0600
  400264:	004019d1 	.word	0x004019d1
  400268:	4000c000 	.word	0x4000c000
  40026c:	2040012c 	.word	0x2040012c
  400270:	00400d41 	.word	0x00400d41

00400274 <ADC_0_PORT_init>:
	((Pio *)hw)->PIO_PDR = PIO_PSR_P31;
}

static inline void hri_pio_set_PSR_reg(const void *const hw, hri_pio_psr_reg_t mask)
{
	((Pio *)hw)->PIO_PER = mask;
  400274:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  400278:	4b05      	ldr	r3, [pc, #20]	; (400290 <ADC_0_PORT_init+0x1c>)
  40027a:	601a      	str	r2, [r3, #0]
  40027c:	2204      	movs	r2, #4
  40027e:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
  400282:	601a      	str	r2, [r3, #0]
  400284:	f44f 2280 	mov.w	r2, #262144	; 0x40000
  400288:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
  40028c:	601a      	str	r2, [r3, #0]
  40028e:	4770      	bx	lr
  400290:	400e1400 	.word	0x400e1400

00400294 <ADC_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400294:	4b04      	ldr	r3, [pc, #16]	; (4002a8 <ADC_0_CLOCK_init+0x14>)
  400296:	699b      	ldr	r3, [r3, #24]
  400298:	f013 5f00 	tst.w	r3, #536870912	; 0x20000000
  40029c:	d103      	bne.n	4002a6 <ADC_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40029e:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4002a2:	4b01      	ldr	r3, [pc, #4]	; (4002a8 <ADC_0_CLOCK_init+0x14>)
  4002a4:	611a      	str	r2, [r3, #16]
  4002a6:	4770      	bx	lr
  4002a8:	400e0600 	.word	0x400e0600

004002ac <ADC_0_init>:
{
  4002ac:	b508      	push	{r3, lr}
	ADC_0_CLOCK_init();
  4002ae:	4b05      	ldr	r3, [pc, #20]	; (4002c4 <ADC_0_init+0x18>)
  4002b0:	4798      	blx	r3
	ADC_0_PORT_init();
  4002b2:	4b05      	ldr	r3, [pc, #20]	; (4002c8 <ADC_0_init+0x1c>)
  4002b4:	4798      	blx	r3
	adc_sync_init(&ADC_0, AFEC0, (void *)NULL);
  4002b6:	2200      	movs	r2, #0
  4002b8:	4904      	ldr	r1, [pc, #16]	; (4002cc <ADC_0_init+0x20>)
  4002ba:	4805      	ldr	r0, [pc, #20]	; (4002d0 <ADC_0_init+0x24>)
  4002bc:	4b05      	ldr	r3, [pc, #20]	; (4002d4 <ADC_0_init+0x28>)
  4002be:	4798      	blx	r3
  4002c0:	bd08      	pop	{r3, pc}
  4002c2:	bf00      	nop
  4002c4:	00400295 	.word	0x00400295
  4002c8:	00400275 	.word	0x00400275
  4002cc:	4003c000 	.word	0x4003c000
  4002d0:	204000d0 	.word	0x204000d0
  4002d4:	00400785 	.word	0x00400785

004002d8 <EXTERNAL_IRQ_1_init>:
	((Pio *)hw)->PIO_ODR = ~data;
}

static inline void hri_pio_clear_OSR_reg(const void *const hw, hri_pio_osr_reg_t mask)
{
	((Pio *)hw)->PIO_ODR = mask;
  4002d8:	4b03      	ldr	r3, [pc, #12]	; (4002e8 <EXTERNAL_IRQ_1_init+0x10>)
  4002da:	2202      	movs	r2, #2
  4002dc:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = ~data;
}

static inline void hri_pio_clear_PUSR_reg(const void *const hw, hri_pio_pusr_reg_t mask)
{
	((Pio *)hw)->PIO_PUDR = mask;
  4002de:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = ~data;
}

static inline void hri_pio_clear_PPDSR_reg(const void *const hw, hri_pio_ppdsr_reg_t mask)
{
	((Pio *)hw)->PIO_PPDDR = mask;
  4002e0:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4002e4:	601a      	str	r2, [r3, #0]
  4002e6:	4770      	bx	lr
  4002e8:	400e1000 	.word	0x400e1000

004002ec <EXTERNAL_IRQ_0_init>:
	((Pio *)hw)->PIO_ODR = mask;
  4002ec:	4b12      	ldr	r3, [pc, #72]	; (400338 <EXTERNAL_IRQ_0_init+0x4c>)
  4002ee:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  4002f2:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4002f4:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4002f6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4002fa:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4002fc:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  400300:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400302:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400304:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400308:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  40030a:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  40030e:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400310:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400312:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400316:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  400318:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  40031c:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40031e:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400320:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400324:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  400326:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  40032a:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40032c:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  40032e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400332:	601a      	str	r2, [r3, #0]
  400334:	4770      	bx	lr
  400336:	bf00      	nop
  400338:	400e0e00 	.word	0x400e0e00

0040033c <PWM_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40033c:	4b17      	ldr	r3, [pc, #92]	; (40039c <PWM_0_PORT_init+0x60>)
  40033e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400340:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  400344:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400346:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400348:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
  40034c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40034e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400352:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400354:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
  400358:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40035a:	f022 0204 	bic.w	r2, r2, #4
  40035e:	671a      	str	r2, [r3, #112]	; 0x70
  400360:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400362:	f022 0204 	bic.w	r2, r2, #4
  400366:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400368:	2204      	movs	r2, #4
  40036a:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40036c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40036e:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  400372:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400374:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400376:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  40037a:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40037c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  400380:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400382:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400384:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  400388:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40038a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40038c:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
  400390:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400392:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  400396:	605a      	str	r2, [r3, #4]
  400398:	4770      	bx	lr
  40039a:	bf00      	nop
  40039c:	400e1400 	.word	0x400e1400

004003a0 <PWM_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4003a0:	4b04      	ldr	r3, [pc, #16]	; (4003b4 <PWM_0_CLOCK_init+0x14>)
  4003a2:	699b      	ldr	r3, [r3, #24]
  4003a4:	2b00      	cmp	r3, #0
  4003a6:	db03      	blt.n	4003b0 <PWM_0_CLOCK_init+0x10>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4003a8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  4003ac:	4b01      	ldr	r3, [pc, #4]	; (4003b4 <PWM_0_CLOCK_init+0x14>)
  4003ae:	611a      	str	r2, [r3, #16]
  4003b0:	4770      	bx	lr
  4003b2:	bf00      	nop
  4003b4:	400e0600 	.word	0x400e0600

004003b8 <PWM_0_init>:
{
  4003b8:	b508      	push	{r3, lr}
	PWM_0_CLOCK_init();
  4003ba:	4b06      	ldr	r3, [pc, #24]	; (4003d4 <PWM_0_init+0x1c>)
  4003bc:	4798      	blx	r3
	PWM_0_PORT_init();
  4003be:	4b06      	ldr	r3, [pc, #24]	; (4003d8 <PWM_0_init+0x20>)
  4003c0:	4798      	blx	r3
	pwm_init(&PWM_0, PWM0, _pwm_get_pwm());
  4003c2:	4b06      	ldr	r3, [pc, #24]	; (4003dc <PWM_0_init+0x24>)
  4003c4:	4798      	blx	r3
  4003c6:	4602      	mov	r2, r0
  4003c8:	4905      	ldr	r1, [pc, #20]	; (4003e0 <PWM_0_init+0x28>)
  4003ca:	4806      	ldr	r0, [pc, #24]	; (4003e4 <PWM_0_init+0x2c>)
  4003cc:	4b06      	ldr	r3, [pc, #24]	; (4003e8 <PWM_0_init+0x30>)
  4003ce:	4798      	blx	r3
  4003d0:	bd08      	pop	{r3, pc}
  4003d2:	bf00      	nop
  4003d4:	004003a1 	.word	0x004003a1
  4003d8:	0040033d 	.word	0x0040033d
  4003dc:	00401621 	.word	0x00401621
  4003e0:	40020000 	.word	0x40020000
  4003e4:	204000b4 	.word	0x204000b4
  4003e8:	00400a8d 	.word	0x00400a8d

004003ec <PWM_1_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4003ec:	4b06      	ldr	r3, [pc, #24]	; (400408 <PWM_1_PORT_init+0x1c>)
  4003ee:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003f0:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  4003f4:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4003f6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003f8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
  4003fc:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003fe:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  400402:	605a      	str	r2, [r3, #4]
  400404:	4770      	bx	lr
  400406:	bf00      	nop
  400408:	400e0e00 	.word	0x400e0e00

0040040c <PWM_1_CLOCK_init>:
}

static inline hri_pmc_pcsr1_reg_t hri_pmc_get_PCSR1_reg(const void *const hw, hri_pmc_pcsr1_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR1;
  40040c:	4b05      	ldr	r3, [pc, #20]	; (400424 <PWM_1_CLOCK_init+0x18>)
  40040e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
			hri_pmc_set_PCSR0_reg(PMC, (1 << periph_id));
		}
	} else if (periph_id < 64) {
		periph_id -= 32;
		if (!hri_pmc_get_PCSR1_reg(PMC, (1 << periph_id))) {
  400412:	f013 5f80 	tst.w	r3, #268435456	; 0x10000000
  400416:	d104      	bne.n	400422 <PWM_1_CLOCK_init+0x16>
	((Pmc *)hw)->PMC_PCER1 = mask;
  400418:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40041c:	4b01      	ldr	r3, [pc, #4]	; (400424 <PWM_1_CLOCK_init+0x18>)
  40041e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  400422:	4770      	bx	lr
  400424:	400e0600 	.word	0x400e0600

00400428 <PWM_1_init>:
{
  400428:	b508      	push	{r3, lr}
	PWM_1_CLOCK_init();
  40042a:	4b06      	ldr	r3, [pc, #24]	; (400444 <PWM_1_init+0x1c>)
  40042c:	4798      	blx	r3
	PWM_1_PORT_init();
  40042e:	4b06      	ldr	r3, [pc, #24]	; (400448 <PWM_1_init+0x20>)
  400430:	4798      	blx	r3
	pwm_init(&PWM_1, PWM1, _pwm_get_pwm());
  400432:	4b06      	ldr	r3, [pc, #24]	; (40044c <PWM_1_init+0x24>)
  400434:	4798      	blx	r3
  400436:	4602      	mov	r2, r0
  400438:	4905      	ldr	r1, [pc, #20]	; (400450 <PWM_1_init+0x28>)
  40043a:	4806      	ldr	r0, [pc, #24]	; (400454 <PWM_1_init+0x2c>)
  40043c:	4b06      	ldr	r3, [pc, #24]	; (400458 <PWM_1_init+0x30>)
  40043e:	4798      	blx	r3
  400440:	bd08      	pop	{r3, pc}
  400442:	bf00      	nop
  400444:	0040040d 	.word	0x0040040d
  400448:	004003ed 	.word	0x004003ed
  40044c:	00401621 	.word	0x00401621
  400450:	4005c000 	.word	0x4005c000
  400454:	204000f0 	.word	0x204000f0
  400458:	00400a8d 	.word	0x00400a8d

0040045c <SPI_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40045c:	4b11      	ldr	r3, [pc, #68]	; (4004a4 <SPI_0_PORT_init+0x48>)
  40045e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400460:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  400464:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400466:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400468:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  40046c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40046e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  400472:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400474:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400476:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  40047a:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40047c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40047e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400482:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400484:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400488:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40048a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40048c:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  400490:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400492:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400494:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  400498:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40049a:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  40049e:	605a      	str	r2, [r3, #4]
  4004a0:	4770      	bx	lr
  4004a2:	bf00      	nop
  4004a4:	400e1400 	.word	0x400e1400

004004a8 <SPI_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004a8:	4b04      	ldr	r3, [pc, #16]	; (4004bc <SPI_0_CLOCK_init+0x14>)
  4004aa:	699b      	ldr	r3, [r3, #24]
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4004ac:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  4004b0:	d103      	bne.n	4004ba <SPI_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004b2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4004b6:	4b01      	ldr	r3, [pc, #4]	; (4004bc <SPI_0_CLOCK_init+0x14>)
  4004b8:	611a      	str	r2, [r3, #16]
  4004ba:	4770      	bx	lr
  4004bc:	400e0600 	.word	0x400e0600

004004c0 <SPI_0_init>:
{
  4004c0:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
  4004c2:	4b08      	ldr	r3, [pc, #32]	; (4004e4 <SPI_0_init+0x24>)
  4004c4:	4798      	blx	r3
	spi_m_sync_set_func_ptr(&SPI_0, _spi_get_spi_m_sync());
  4004c6:	4b08      	ldr	r3, [pc, #32]	; (4004e8 <SPI_0_init+0x28>)
  4004c8:	4798      	blx	r3
  4004ca:	4c08      	ldr	r4, [pc, #32]	; (4004ec <SPI_0_init+0x2c>)
  4004cc:	4601      	mov	r1, r0
  4004ce:	4620      	mov	r0, r4
  4004d0:	4b07      	ldr	r3, [pc, #28]	; (4004f0 <SPI_0_init+0x30>)
  4004d2:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SPI0);
  4004d4:	4907      	ldr	r1, [pc, #28]	; (4004f4 <SPI_0_init+0x34>)
  4004d6:	4620      	mov	r0, r4
  4004d8:	4b07      	ldr	r3, [pc, #28]	; (4004f8 <SPI_0_init+0x38>)
  4004da:	4798      	blx	r3
	SPI_0_PORT_init();
  4004dc:	4b07      	ldr	r3, [pc, #28]	; (4004fc <SPI_0_init+0x3c>)
  4004de:	4798      	blx	r3
  4004e0:	bd10      	pop	{r4, pc}
  4004e2:	bf00      	nop
  4004e4:	004004a9 	.word	0x004004a9
  4004e8:	00401821 	.word	0x00401821
  4004ec:	204000d8 	.word	0x204000d8
  4004f0:	00400b0d 	.word	0x00400b0d
  4004f4:	40008000 	.word	0x40008000
  4004f8:	00400b2d 	.word	0x00400b2d
  4004fc:	0040045d 	.word	0x0040045d

00400500 <I2C_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400500:	4b0a      	ldr	r3, [pc, #40]	; (40052c <I2C_0_PORT_init+0x2c>)
  400502:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400504:	f022 0210 	bic.w	r2, r2, #16
  400508:	671a      	str	r2, [r3, #112]	; 0x70
  40050a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40050c:	f022 0210 	bic.w	r2, r2, #16
  400510:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400512:	2210      	movs	r2, #16
  400514:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400516:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400518:	f022 0208 	bic.w	r2, r2, #8
  40051c:	671a      	str	r2, [r3, #112]	; 0x70
  40051e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400520:	f022 0208 	bic.w	r2, r2, #8
  400524:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400526:	2208      	movs	r2, #8
  400528:	605a      	str	r2, [r3, #4]
  40052a:	4770      	bx	lr
  40052c:	400e0e00 	.word	0x400e0e00

00400530 <I2C_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400530:	4b04      	ldr	r3, [pc, #16]	; (400544 <I2C_0_CLOCK_init+0x14>)
  400532:	699b      	ldr	r3, [r3, #24]
  400534:	f413 2f00 	tst.w	r3, #524288	; 0x80000
  400538:	d103      	bne.n	400542 <I2C_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40053a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40053e:	4b01      	ldr	r3, [pc, #4]	; (400544 <I2C_0_CLOCK_init+0x14>)
  400540:	611a      	str	r2, [r3, #16]
  400542:	4770      	bx	lr
  400544:	400e0600 	.word	0x400e0600

00400548 <I2C_0_init>:
{
	_pmc_enable_periph_clock(ID_TWIHS0);
}

void I2C_0_init(void)
{
  400548:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
  40054a:	4b04      	ldr	r3, [pc, #16]	; (40055c <I2C_0_init+0x14>)
  40054c:	4798      	blx	r3

	i2c_m_sync_init(&I2C_0, TWIHS0);
  40054e:	4904      	ldr	r1, [pc, #16]	; (400560 <I2C_0_init+0x18>)
  400550:	4804      	ldr	r0, [pc, #16]	; (400564 <I2C_0_init+0x1c>)
  400552:	4b05      	ldr	r3, [pc, #20]	; (400568 <I2C_0_init+0x20>)
  400554:	4798      	blx	r3

	I2C_0_PORT_init();
  400556:	4b05      	ldr	r3, [pc, #20]	; (40056c <I2C_0_init+0x24>)
  400558:	4798      	blx	r3
  40055a:	bd08      	pop	{r3, pc}
  40055c:	00400531 	.word	0x00400531
  400560:	40018000 	.word	0x40018000
  400564:	2040010c 	.word	0x2040010c
  400568:	004009d9 	.word	0x004009d9
  40056c:	00400501 	.word	0x00400501

00400570 <delay_driver_init>:
}

void delay_driver_init(void)
{
  400570:	b508      	push	{r3, lr}
	delay_init(SysTick);
  400572:	4802      	ldr	r0, [pc, #8]	; (40057c <delay_driver_init+0xc>)
  400574:	4b02      	ldr	r3, [pc, #8]	; (400580 <delay_driver_init+0x10>)
  400576:	4798      	blx	r3
  400578:	bd08      	pop	{r3, pc}
  40057a:	bf00      	nop
  40057c:	e000e010 	.word	0xe000e010
  400580:	004007fd 	.word	0x004007fd

00400584 <WDT_0_init>:
}

void WDT_0_init(void)
{
  400584:	b508      	push	{r3, lr}
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
  400586:	2248      	movs	r2, #72	; 0x48
  400588:	4904      	ldr	r1, [pc, #16]	; (40059c <WDT_0_init+0x18>)
  40058a:	2001      	movs	r0, #1
  40058c:	4b04      	ldr	r3, [pc, #16]	; (4005a0 <WDT_0_init+0x1c>)
  40058e:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
  400590:	4804      	ldr	r0, [pc, #16]	; (4005a4 <WDT_0_init+0x20>)
  400592:	4b05      	ldr	r3, [pc, #20]	; (4005a8 <WDT_0_init+0x24>)
  400594:	6003      	str	r3, [r0, #0]

	return _wdt_init(&wdt->dev);
  400596:	4b05      	ldr	r3, [pc, #20]	; (4005ac <WDT_0_init+0x28>)
  400598:	4798      	blx	r3
  40059a:	bd08      	pop	{r3, pc}
  40059c:	00402104 	.word	0x00402104
  4005a0:	00400e61 	.word	0x00400e61
  4005a4:	204000d4 	.word	0x204000d4
  4005a8:	400e1850 	.word	0x400e1850
  4005ac:	00401bd1 	.word	0x00401bd1

004005b0 <system_init>:
	wdt_init(&WDT_0, WDT);
}

void system_init(void)
{
  4005b0:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  4005b2:	4b66      	ldr	r3, [pc, #408]	; (40074c <system_init+0x19c>)
  4005b4:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4005b6:	4b66      	ldr	r3, [pc, #408]	; (400750 <system_init+0x1a0>)
  4005b8:	699b      	ldr	r3, [r3, #24]
  4005ba:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4005be:	d103      	bne.n	4005c8 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4005c0:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4005c4:	4b62      	ldr	r3, [pc, #392]	; (400750 <system_init+0x1a0>)
  4005c6:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4005c8:	4b61      	ldr	r3, [pc, #388]	; (400750 <system_init+0x1a0>)
  4005ca:	699b      	ldr	r3, [r3, #24]
  4005cc:	f413 6f00 	tst.w	r3, #2048	; 0x800
  4005d0:	d103      	bne.n	4005da <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4005d2:	f44f 6200 	mov.w	r2, #2048	; 0x800
  4005d6:	4b5e      	ldr	r3, [pc, #376]	; (400750 <system_init+0x1a0>)
  4005d8:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4005da:	4b5d      	ldr	r3, [pc, #372]	; (400750 <system_init+0x1a0>)
  4005dc:	699b      	ldr	r3, [r3, #24]
  4005de:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  4005e2:	d103      	bne.n	4005ec <system_init+0x3c>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4005e4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  4005e8:	4b59      	ldr	r3, [pc, #356]	; (400750 <system_init+0x1a0>)
  4005ea:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_ODR = mask;
  4005ec:	4b59      	ldr	r3, [pc, #356]	; (400754 <system_init+0x1a4>)
  4005ee:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  4005f2:	6159      	str	r1, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4005f4:	6619      	str	r1, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4005f6:	f8c3 1090 	str.w	r1, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4005fa:	6019      	str	r1, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4005fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  400600:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400602:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400604:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400608:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  40060a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  40060e:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400610:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400612:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400616:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  400618:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  40061c:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40061e:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400620:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400624:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_SODR = mask;
  400626:	f503 7300 	add.w	r3, r3, #512	; 0x200
  40062a:	2008      	movs	r0, #8
  40062c:	6318      	str	r0, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  40062e:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400630:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_SODR = mask;
  400632:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  400636:	2404      	movs	r4, #4
  400638:	631c      	str	r4, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  40063a:	611c      	str	r4, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40063c:	601c      	str	r4, [r3, #0]
	((Pio *)hw)->PIO_SODR = mask;
  40063e:	6318      	str	r0, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  400640:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400642:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400644:	2010      	movs	r0, #16
  400646:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400648:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40064a:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40064c:	2020      	movs	r0, #32
  40064e:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400650:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400652:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400654:	2040      	movs	r0, #64	; 0x40
  400656:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400658:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40065a:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40065c:	2080      	movs	r0, #128	; 0x80
  40065e:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400660:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400662:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400664:	f44f 7080 	mov.w	r0, #256	; 0x100
  400668:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  40066a:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40066c:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40066e:	f44f 7000 	mov.w	r0, #512	; 0x200
  400672:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400674:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400676:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400678:	f44f 6080 	mov.w	r0, #1024	; 0x400
  40067c:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  40067e:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400680:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  400682:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  400686:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400688:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  40068a:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  40068e:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  400690:	f44f 5000 	mov.w	r0, #8192	; 0x2000
  400694:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  400696:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400698:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  40069c:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  40069e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  4006a2:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006a4:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006a6:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006aa:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4006ac:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  4006b0:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006b2:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006b4:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006b8:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4006ba:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  4006be:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006c0:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006c2:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006c6:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4006c8:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  4006cc:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006ce:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006d0:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006d4:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4006d6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
  4006da:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006dc:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006de:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006e2:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_ODR = mask;
  4006e4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  4006e8:	6158      	str	r0, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  4006ea:	6618      	str	r0, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  4006ec:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  4006f0:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  4006f2:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
  4006f6:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  4006f8:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  4006fa:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  4006fc:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
  400700:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400702:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400704:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400706:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
  40070a:	6358      	str	r0, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  40070c:	6118      	str	r0, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40070e:	6018      	str	r0, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400710:	6359      	str	r1, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400712:	6119      	str	r1, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400714:	6019      	str	r1, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400716:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400718:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40071a:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(Dribbler_Motor_Dir, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(Dribbler_Motor_Dir, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
  40071c:	4b0e      	ldr	r3, [pc, #56]	; (400758 <system_init+0x1a8>)
  40071e:	4798      	blx	r3
	EXTERNAL_IRQ_1_init();
  400720:	4b0e      	ldr	r3, [pc, #56]	; (40075c <system_init+0x1ac>)
  400722:	4798      	blx	r3
	EXTERNAL_IRQ_0_init();
  400724:	4b0e      	ldr	r3, [pc, #56]	; (400760 <system_init+0x1b0>)
  400726:	4798      	blx	r3

	PWM_0_init();
  400728:	4b0e      	ldr	r3, [pc, #56]	; (400764 <system_init+0x1b4>)
  40072a:	4798      	blx	r3

	PWM_1_init();
  40072c:	4b0e      	ldr	r3, [pc, #56]	; (400768 <system_init+0x1b8>)
  40072e:	4798      	blx	r3

	SPI_0_init();
  400730:	4b0e      	ldr	r3, [pc, #56]	; (40076c <system_init+0x1bc>)
  400732:	4798      	blx	r3
	TIMER_0_init();
  400734:	4b0e      	ldr	r3, [pc, #56]	; (400770 <system_init+0x1c0>)
  400736:	4798      	blx	r3

	I2C_0_init();
  400738:	4b0e      	ldr	r3, [pc, #56]	; (400774 <system_init+0x1c4>)
  40073a:	4798      	blx	r3

	delay_driver_init();
  40073c:	4b0e      	ldr	r3, [pc, #56]	; (400778 <system_init+0x1c8>)
  40073e:	4798      	blx	r3

	WDT_0_init();
  400740:	4b0e      	ldr	r3, [pc, #56]	; (40077c <system_init+0x1cc>)
  400742:	4798      	blx	r3

	ext_irq_init();
  400744:	4b0e      	ldr	r3, [pc, #56]	; (400780 <system_init+0x1d0>)
  400746:	4798      	blx	r3
  400748:	bd10      	pop	{r4, pc}
  40074a:	bf00      	nop
  40074c:	0040100d 	.word	0x0040100d
  400750:	400e0600 	.word	0x400e0600
  400754:	400e0e00 	.word	0x400e0e00
  400758:	004002ad 	.word	0x004002ad
  40075c:	004002d9 	.word	0x004002d9
  400760:	004002ed 	.word	0x004002ed
  400764:	004003b9 	.word	0x004003b9
  400768:	00400429 	.word	0x00400429
  40076c:	004004c1 	.word	0x004004c1
  400770:	0040023d 	.word	0x0040023d
  400774:	00400549 	.word	0x00400549
  400778:	00400571 	.word	0x00400571
  40077c:	00400585 	.word	0x00400585
  400780:	00400875 	.word	0x00400875

00400784 <adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t adc_sync_init(struct adc_sync_descriptor *const descr, void *const hw, void *const func)
{
  400784:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400786:	4604      	mov	r4, r0
  400788:	460d      	mov	r5, r1
  40078a:	2800      	cmp	r0, #0
  40078c:	bf18      	it	ne
  40078e:	2900      	cmpne	r1, #0
  400790:	bf14      	ite	ne
  400792:	2001      	movne	r0, #1
  400794:	2000      	moveq	r0, #0
  400796:	2239      	movs	r2, #57	; 0x39
  400798:	4903      	ldr	r1, [pc, #12]	; (4007a8 <adc_sync_init+0x24>)
  40079a:	4b04      	ldr	r3, [pc, #16]	; (4007ac <adc_sync_init+0x28>)
  40079c:	4798      	blx	r3

	return _adc_sync_init(&descr->device, hw);
  40079e:	4629      	mov	r1, r5
  4007a0:	4620      	mov	r0, r4
  4007a2:	4b03      	ldr	r3, [pc, #12]	; (4007b0 <adc_sync_init+0x2c>)
  4007a4:	4798      	blx	r3
}
  4007a6:	bd38      	pop	{r3, r4, r5, pc}
  4007a8:	00402120 	.word	0x00402120
  4007ac:	00400e61 	.word	0x00400e61
  4007b0:	00400f9d 	.word	0x00400f9d

004007b4 <adc_sync_enable_channel>:

/**
 * \brief Enable ADC
 */
int32_t adc_sync_enable_channel(struct adc_sync_descriptor *const descr, const uint8_t channel)
{
  4007b4:	b538      	push	{r3, r4, r5, lr}
  4007b6:	460d      	mov	r5, r1
	ASSERT(descr);
  4007b8:	4604      	mov	r4, r0
  4007ba:	224e      	movs	r2, #78	; 0x4e
  4007bc:	4905      	ldr	r1, [pc, #20]	; (4007d4 <adc_sync_enable_channel+0x20>)
  4007be:	3000      	adds	r0, #0
  4007c0:	bf18      	it	ne
  4007c2:	2001      	movne	r0, #1
  4007c4:	4b04      	ldr	r3, [pc, #16]	; (4007d8 <adc_sync_enable_channel+0x24>)
  4007c6:	4798      	blx	r3
	_adc_sync_enable_channel(&descr->device, channel);
  4007c8:	4629      	mov	r1, r5
  4007ca:	4620      	mov	r0, r4
  4007cc:	4b03      	ldr	r3, [pc, #12]	; (4007dc <adc_sync_enable_channel+0x28>)
  4007ce:	4798      	blx	r3

	return ERR_NONE;
}
  4007d0:	2000      	movs	r0, #0
  4007d2:	bd38      	pop	{r3, r4, r5, pc}
  4007d4:	00402120 	.word	0x00402120
  4007d8:	00400e61 	.word	0x00400e61
  4007dc:	00400fd5 	.word	0x00400fd5

004007e0 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  4007e0:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  4007e4:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  4007e6:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  4007e8:	f3bf 8f5f 	dmb	sy
  4007ec:	4770      	bx	lr

004007ee <atomic_leave_critical>:
  4007ee:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  4007f2:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  4007f4:	f383 8810 	msr	PRIMASK, r3
  4007f8:	4770      	bx	lr
	...

004007fc <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  4007fc:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  4007fe:	4b02      	ldr	r3, [pc, #8]	; (400808 <delay_init+0xc>)
  400800:	6018      	str	r0, [r3, #0]
  400802:	4b02      	ldr	r3, [pc, #8]	; (40080c <delay_init+0x10>)
  400804:	4798      	blx	r3
  400806:	bd08      	pop	{r3, pc}
  400808:	20400040 	.word	0x20400040
  40080c:	00401839 	.word	0x00401839

00400810 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
  400810:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
  400812:	4b04      	ldr	r3, [pc, #16]	; (400824 <delay_us+0x14>)
  400814:	681c      	ldr	r4, [r3, #0]
  400816:	4b04      	ldr	r3, [pc, #16]	; (400828 <delay_us+0x18>)
  400818:	4798      	blx	r3
  40081a:	4601      	mov	r1, r0
  40081c:	4620      	mov	r0, r4
  40081e:	4b03      	ldr	r3, [pc, #12]	; (40082c <delay_us+0x1c>)
  400820:	4798      	blx	r3
  400822:	bd10      	pop	{r4, pc}
  400824:	20400040 	.word	0x20400040
  400828:	00401001 	.word	0x00401001
  40082c:	00401845 	.word	0x00401845

00400830 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  400830:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  400832:	2506      	movs	r5, #6
  400834:	2400      	movs	r4, #0

	while (upper >= lower) {
  400836:	e007      	b.n	400848 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  400838:	4a0d      	ldr	r2, [pc, #52]	; (400870 <process_ext_irq+0x40>)
  40083a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  40083e:	b1b3      	cbz	r3, 40086e <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  400840:	4798      	blx	r3
  400842:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  400844:	3a01      	subs	r2, #1
  400846:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
  400848:	42ac      	cmp	r4, r5
  40084a:	d810      	bhi.n	40086e <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  40084c:	192b      	adds	r3, r5, r4
  40084e:	105b      	asrs	r3, r3, #1
  400850:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
  400852:	2a05      	cmp	r2, #5
  400854:	d80b      	bhi.n	40086e <process_ext_irq+0x3e>
  400856:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
  400858:	4905      	ldr	r1, [pc, #20]	; (400870 <process_ext_irq+0x40>)
  40085a:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  40085e:	6849      	ldr	r1, [r1, #4]
  400860:	4281      	cmp	r1, r0
  400862:	d0e9      	beq.n	400838 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  400864:	4281      	cmp	r1, r0
  400866:	d2ed      	bcs.n	400844 <process_ext_irq+0x14>
			lower = middle + 1;
  400868:	3201      	adds	r2, #1
  40086a:	b2d4      	uxtb	r4, r2
  40086c:	e7ec      	b.n	400848 <process_ext_irq+0x18>
  40086e:	bd38      	pop	{r3, r4, r5, pc}
  400870:	20400044 	.word	0x20400044

00400874 <ext_irq_init>:
{
  400874:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  400876:	2300      	movs	r3, #0
  400878:	e00a      	b.n	400890 <ext_irq_init+0x1c>
		ext_irqs[i].pin = 0xFFFFFFFF;
  40087a:	4a08      	ldr	r2, [pc, #32]	; (40089c <ext_irq_init+0x28>)
  40087c:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  400880:	f04f 30ff 	mov.w	r0, #4294967295
  400884:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  400886:	2100      	movs	r1, #0
  400888:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  40088c:	3301      	adds	r3, #1
  40088e:	b29b      	uxth	r3, r3
  400890:	2b05      	cmp	r3, #5
  400892:	d9f2      	bls.n	40087a <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
  400894:	4802      	ldr	r0, [pc, #8]	; (4008a0 <ext_irq_init+0x2c>)
  400896:	4b03      	ldr	r3, [pc, #12]	; (4008a4 <ext_irq_init+0x30>)
  400898:	4798      	blx	r3
}
  40089a:	bd08      	pop	{r3, pc}
  40089c:	20400044 	.word	0x20400044
  4008a0:	00400831 	.word	0x00400831
  4008a4:	00401295 	.word	0x00401295

004008a8 <ext_irq_register>:
{
  4008a8:	b5f0      	push	{r4, r5, r6, r7, lr}
  4008aa:	b083      	sub	sp, #12
  4008ac:	4605      	mov	r5, r0
	uint8_t i = 0, j = 0;
  4008ae:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
  4008b0:	2b05      	cmp	r3, #5
  4008b2:	d80e      	bhi.n	4008d2 <ext_irq_register+0x2a>
		if (ext_irqs[i].pin == pin) {
  4008b4:	4618      	mov	r0, r3
  4008b6:	4a2e      	ldr	r2, [pc, #184]	; (400970 <ext_irq_register+0xc8>)
  4008b8:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  4008bc:	6852      	ldr	r2, [r2, #4]
  4008be:	42aa      	cmp	r2, r5
  4008c0:	d002      	beq.n	4008c8 <ext_irq_register+0x20>
	for (; i < EXT_IRQ_AMOUNT; i++) {
  4008c2:	3301      	adds	r3, #1
  4008c4:	b2db      	uxtb	r3, r3
  4008c6:	e7f3      	b.n	4008b0 <ext_irq_register+0x8>
			ext_irqs[i].cb = cb;
  4008c8:	4b29      	ldr	r3, [pc, #164]	; (400970 <ext_irq_register+0xc8>)
  4008ca:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
			found          = true;
  4008ce:	2701      	movs	r7, #1
			break;
  4008d0:	e000      	b.n	4008d4 <ext_irq_register+0x2c>
	bool    found = false;
  4008d2:	2700      	movs	r7, #0
	if (NULL == cb) {
  4008d4:	b159      	cbz	r1, 4008ee <ext_irq_register+0x46>
	if (!found) {
  4008d6:	2f00      	cmp	r7, #0
  4008d8:	d13d      	bne.n	400956 <ext_irq_register+0xae>
  4008da:	2600      	movs	r6, #0
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4008dc:	2e05      	cmp	r6, #5
  4008de:	d813      	bhi.n	400908 <ext_irq_register+0x60>
			if (NULL == ext_irqs[i].cb) {
  4008e0:	4b23      	ldr	r3, [pc, #140]	; (400970 <ext_irq_register+0xc8>)
  4008e2:	f853 3036 	ldr.w	r3, [r3, r6, lsl #3]
  4008e6:	b143      	cbz	r3, 4008fa <ext_irq_register+0x52>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4008e8:	3601      	adds	r6, #1
  4008ea:	b2f6      	uxtb	r6, r6
  4008ec:	e7f6      	b.n	4008dc <ext_irq_register+0x34>
		if (!found) {
  4008ee:	2f00      	cmp	r7, #0
  4008f0:	d038      	beq.n	400964 <ext_irq_register+0xbc>
		return _ext_irq_enable(pin, false);
  4008f2:	4628      	mov	r0, r5
  4008f4:	4b1f      	ldr	r3, [pc, #124]	; (400974 <ext_irq_register+0xcc>)
  4008f6:	4798      	blx	r3
  4008f8:	e032      	b.n	400960 <ext_irq_register+0xb8>
				ext_irqs[i].cb  = cb;
  4008fa:	4b1d      	ldr	r3, [pc, #116]	; (400970 <ext_irq_register+0xc8>)
  4008fc:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
				ext_irqs[i].pin = pin;
  400900:	eb03 02c6 	add.w	r2, r3, r6, lsl #3
  400904:	6055      	str	r5, [r2, #4]
				found           = true;
  400906:	2701      	movs	r7, #1
  400908:	2300      	movs	r3, #0
  40090a:	e001      	b.n	400910 <ext_irq_register+0x68>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
  40090c:	3301      	adds	r3, #1
  40090e:	b2db      	uxtb	r3, r3
  400910:	2b05      	cmp	r3, #5
  400912:	bf98      	it	ls
  400914:	2e05      	cmpls	r6, #5
  400916:	d81e      	bhi.n	400956 <ext_irq_register+0xae>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
  400918:	46b6      	mov	lr, r6
  40091a:	4a15      	ldr	r2, [pc, #84]	; (400970 <ext_irq_register+0xc8>)
  40091c:	eb02 01c6 	add.w	r1, r2, r6, lsl #3
  400920:	6848      	ldr	r0, [r1, #4]
  400922:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  400926:	6852      	ldr	r2, [r2, #4]
  400928:	4290      	cmp	r0, r2
  40092a:	d2ef      	bcs.n	40090c <ext_irq_register+0x64>
  40092c:	f1b2 3fff 	cmp.w	r2, #4294967295
  400930:	d0ec      	beq.n	40090c <ext_irq_register+0x64>
				struct ext_irq tmp = ext_irqs[j];
  400932:	4c0f      	ldr	r4, [pc, #60]	; (400970 <ext_irq_register+0xc8>)
  400934:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
  400938:	e892 0003 	ldmia.w	r2, {r0, r1}
  40093c:	e88d 0003 	stmia.w	sp, {r0, r1}
				ext_irqs[j] = ext_irqs[i];
  400940:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
  400944:	e894 0003 	ldmia.w	r4, {r0, r1}
  400948:	e882 0003 	stmia.w	r2, {r0, r1}
				ext_irqs[i] = tmp;
  40094c:	e89d 0003 	ldmia.w	sp, {r0, r1}
  400950:	e884 0003 	stmia.w	r4, {r0, r1}
  400954:	e7da      	b.n	40090c <ext_irq_register+0x64>
	if (!found) {
  400956:	b147      	cbz	r7, 40096a <ext_irq_register+0xc2>
	return _ext_irq_enable(pin, true);
  400958:	2101      	movs	r1, #1
  40095a:	4628      	mov	r0, r5
  40095c:	4b05      	ldr	r3, [pc, #20]	; (400974 <ext_irq_register+0xcc>)
  40095e:	4798      	blx	r3
}
  400960:	b003      	add	sp, #12
  400962:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
  400964:	f06f 000c 	mvn.w	r0, #12
  400968:	e7fa      	b.n	400960 <ext_irq_register+0xb8>
		return ERR_INVALID_ARG;
  40096a:	f06f 000c 	mvn.w	r0, #12
  40096e:	e7f7      	b.n	400960 <ext_irq_register+0xb8>
  400970:	20400044 	.word	0x20400044
  400974:	004012bd 	.word	0x004012bd

00400978 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
  400978:	b510      	push	{r4, lr}
  40097a:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
  40097c:	8903      	ldrh	r3, [r0, #8]
  40097e:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  400982:	4614      	mov	r4, r2
  400984:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
  400986:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40098a:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
  40098e:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400990:	a901      	add	r1, sp, #4
  400992:	3814      	subs	r0, #20
  400994:	4b03      	ldr	r3, [pc, #12]	; (4009a4 <i2c_m_sync_write+0x2c>)
  400996:	4798      	blx	r3

	if (ret) {
  400998:	b910      	cbnz	r0, 4009a0 <i2c_m_sync_write+0x28>
		return ret;
	}

	return n;
}
  40099a:	4620      	mov	r0, r4
  40099c:	b004      	add	sp, #16
  40099e:	bd10      	pop	{r4, pc}
		return ret;
  4009a0:	4604      	mov	r4, r0
  4009a2:	e7fa      	b.n	40099a <i2c_m_sync_write+0x22>
  4009a4:	00401a69 	.word	0x00401a69

004009a8 <i2c_m_sync_read>:
{
  4009a8:	b510      	push	{r4, lr}
  4009aa:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
  4009ac:	8903      	ldrh	r3, [r0, #8]
  4009ae:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  4009b2:	4614      	mov	r4, r2
  4009b4:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
  4009b6:	f248 0301 	movw	r3, #32769	; 0x8001
  4009ba:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
  4009be:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  4009c0:	a901      	add	r1, sp, #4
  4009c2:	3814      	subs	r0, #20
  4009c4:	4b03      	ldr	r3, [pc, #12]	; (4009d4 <i2c_m_sync_read+0x2c>)
  4009c6:	4798      	blx	r3
	if (ret) {
  4009c8:	b910      	cbnz	r0, 4009d0 <i2c_m_sync_read+0x28>
}
  4009ca:	4620      	mov	r0, r4
  4009cc:	b004      	add	sp, #16
  4009ce:	bd10      	pop	{r4, pc}
		return ret;
  4009d0:	4604      	mov	r4, r0
  4009d2:	e7fa      	b.n	4009ca <i2c_m_sync_read+0x22>
  4009d4:	00401a69 	.word	0x00401a69

004009d8 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
  4009d8:	b538      	push	{r3, r4, r5, lr}
  4009da:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
  4009dc:	4604      	mov	r4, r0
  4009de:	225e      	movs	r2, #94	; 0x5e
  4009e0:	4908      	ldr	r1, [pc, #32]	; (400a04 <i2c_m_sync_init+0x2c>)
  4009e2:	3000      	adds	r0, #0
  4009e4:	bf18      	it	ne
  4009e6:	2001      	movne	r0, #1
  4009e8:	4b07      	ldr	r3, [pc, #28]	; (400a08 <i2c_m_sync_init+0x30>)
  4009ea:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
  4009ec:	4629      	mov	r1, r5
  4009ee:	4620      	mov	r0, r4
  4009f0:	4b06      	ldr	r3, [pc, #24]	; (400a0c <i2c_m_sync_init+0x34>)
  4009f2:	4798      	blx	r3
	if (init_status) {
  4009f4:	4603      	mov	r3, r0
  4009f6:	b918      	cbnz	r0, 400a00 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
  4009f8:	4a05      	ldr	r2, [pc, #20]	; (400a10 <i2c_m_sync_init+0x38>)
  4009fa:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
  4009fc:	4a05      	ldr	r2, [pc, #20]	; (400a14 <i2c_m_sync_init+0x3c>)
  4009fe:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
  400a00:	4618      	mov	r0, r3
  400a02:	bd38      	pop	{r3, r4, r5, pc}
  400a04:	0040213c 	.word	0x0040213c
  400a08:	00400e61 	.word	0x00400e61
  400a0c:	00401a21 	.word	0x00401a21
  400a10:	004009a9 	.word	0x004009a9
  400a14:	00400979 	.word	0x00400979

00400a18 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  400a18:	b570      	push	{r4, r5, r6, lr}
  400a1a:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  400a1c:	4604      	mov	r4, r0
  400a1e:	460d      	mov	r5, r1
  400a20:	2800      	cmp	r0, #0
  400a22:	bf18      	it	ne
  400a24:	2900      	cmpne	r1, #0
  400a26:	bf14      	ite	ne
  400a28:	2001      	movne	r0, #1
  400a2a:	2000      	moveq	r0, #0
  400a2c:	2234      	movs	r2, #52	; 0x34
  400a2e:	4904      	ldr	r1, [pc, #16]	; (400a40 <io_write+0x28>)
  400a30:	4b04      	ldr	r3, [pc, #16]	; (400a44 <io_write+0x2c>)
  400a32:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  400a34:	6823      	ldr	r3, [r4, #0]
  400a36:	4632      	mov	r2, r6
  400a38:	4629      	mov	r1, r5
  400a3a:	4620      	mov	r0, r4
  400a3c:	4798      	blx	r3
}
  400a3e:	bd70      	pop	{r4, r5, r6, pc}
  400a40:	00402158 	.word	0x00402158
  400a44:	00400e61 	.word	0x00400e61

00400a48 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  400a48:	b570      	push	{r4, r5, r6, lr}
  400a4a:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  400a4c:	4604      	mov	r4, r0
  400a4e:	460d      	mov	r5, r1
  400a50:	2800      	cmp	r0, #0
  400a52:	bf18      	it	ne
  400a54:	2900      	cmpne	r1, #0
  400a56:	bf14      	ite	ne
  400a58:	2001      	movne	r0, #1
  400a5a:	2000      	moveq	r0, #0
  400a5c:	223d      	movs	r2, #61	; 0x3d
  400a5e:	4904      	ldr	r1, [pc, #16]	; (400a70 <io_read+0x28>)
  400a60:	4b04      	ldr	r3, [pc, #16]	; (400a74 <io_read+0x2c>)
  400a62:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  400a64:	6863      	ldr	r3, [r4, #4]
  400a66:	4632      	mov	r2, r6
  400a68:	4629      	mov	r1, r5
  400a6a:	4620      	mov	r0, r4
  400a6c:	4798      	blx	r3
}
  400a6e:	bd70      	pop	{r4, r5, r6, pc}
  400a70:	00402158 	.word	0x00402158
  400a74:	00400e61 	.word	0x00400e61

00400a78 <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
  400a78:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.period) {
  400a7a:	6943      	ldr	r3, [r0, #20]
  400a7c:	b103      	cbz	r3, 400a80 <pwm_period_expired+0x8>
		descr->pwm_cb.period(descr);
  400a7e:	4798      	blx	r3
  400a80:	bd08      	pop	{r3, pc}

00400a82 <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
  400a82:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.error) {
  400a84:	6983      	ldr	r3, [r0, #24]
  400a86:	b103      	cbz	r3, 400a8a <pwm_detect_fault+0x8>
		descr->pwm_cb.error(descr);
  400a88:	4798      	blx	r3
  400a8a:	bd08      	pop	{r3, pc}

00400a8c <pwm_init>:
{
  400a8c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400a8e:	4604      	mov	r4, r0
  400a90:	460d      	mov	r5, r1
  400a92:	2800      	cmp	r0, #0
  400a94:	bf18      	it	ne
  400a96:	2900      	cmpne	r1, #0
  400a98:	bf14      	ite	ne
  400a9a:	2001      	movne	r0, #1
  400a9c:	2000      	moveq	r0, #0
  400a9e:	2233      	movs	r2, #51	; 0x33
  400aa0:	4906      	ldr	r1, [pc, #24]	; (400abc <pwm_init+0x30>)
  400aa2:	4b07      	ldr	r3, [pc, #28]	; (400ac0 <pwm_init+0x34>)
  400aa4:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
  400aa6:	4629      	mov	r1, r5
  400aa8:	4620      	mov	r0, r4
  400aaa:	4b06      	ldr	r3, [pc, #24]	; (400ac4 <pwm_init+0x38>)
  400aac:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
  400aae:	4b06      	ldr	r3, [pc, #24]	; (400ac8 <pwm_init+0x3c>)
  400ab0:	6023      	str	r3, [r4, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
  400ab2:	4b06      	ldr	r3, [pc, #24]	; (400acc <pwm_init+0x40>)
  400ab4:	6063      	str	r3, [r4, #4]
}
  400ab6:	2000      	movs	r0, #0
  400ab8:	bd38      	pop	{r3, r4, r5, pc}
  400aba:	bf00      	nop
  400abc:	0040216c 	.word	0x0040216c
  400ac0:	00400e61 	.word	0x00400e61
  400ac4:	00401475 	.word	0x00401475
  400ac8:	00400a79 	.word	0x00400a79
  400acc:	00400a83 	.word	0x00400a83

00400ad0 <pwm_enable>:
{
  400ad0:	b510      	push	{r4, lr}
	ASSERT(descr);
  400ad2:	4604      	mov	r4, r0
  400ad4:	224a      	movs	r2, #74	; 0x4a
  400ad6:	4909      	ldr	r1, [pc, #36]	; (400afc <pwm_enable+0x2c>)
  400ad8:	3000      	adds	r0, #0
  400ada:	bf18      	it	ne
  400adc:	2001      	movne	r0, #1
  400ade:	4b08      	ldr	r3, [pc, #32]	; (400b00 <pwm_enable+0x30>)
  400ae0:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
  400ae2:	4620      	mov	r0, r4
  400ae4:	4b07      	ldr	r3, [pc, #28]	; (400b04 <pwm_enable+0x34>)
  400ae6:	4798      	blx	r3
  400ae8:	b920      	cbnz	r0, 400af4 <pwm_enable+0x24>
	_pwm_enable(&descr->device);
  400aea:	4620      	mov	r0, r4
  400aec:	4b06      	ldr	r3, [pc, #24]	; (400b08 <pwm_enable+0x38>)
  400aee:	4798      	blx	r3
	return ERR_NONE;
  400af0:	2000      	movs	r0, #0
  400af2:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
  400af4:	f06f 0010 	mvn.w	r0, #16
}
  400af8:	bd10      	pop	{r4, pc}
  400afa:	bf00      	nop
  400afc:	0040216c 	.word	0x0040216c
  400b00:	00400e61 	.word	0x00400e61
  400b04:	004015f1 	.word	0x004015f1
  400b08:	004015ad 	.word	0x004015ad

00400b0c <spi_m_sync_set_func_ptr>:

/**
 *  \brief Initialize the SPI HAL instance function pointer for HPL APIs.
 */
void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi, void *const func)
{
  400b0c:	b538      	push	{r3, r4, r5, lr}
  400b0e:	460d      	mov	r5, r1
	ASSERT(spi);
  400b10:	4604      	mov	r4, r0
  400b12:	2239      	movs	r2, #57	; 0x39
  400b14:	4903      	ldr	r1, [pc, #12]	; (400b24 <spi_m_sync_set_func_ptr+0x18>)
  400b16:	3000      	adds	r0, #0
  400b18:	bf18      	it	ne
  400b1a:	2001      	movne	r0, #1
  400b1c:	4b02      	ldr	r3, [pc, #8]	; (400b28 <spi_m_sync_set_func_ptr+0x1c>)
  400b1e:	4798      	blx	r3
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
  400b20:	6025      	str	r5, [r4, #0]
  400b22:	bd38      	pop	{r3, r4, r5, pc}
  400b24:	00402184 	.word	0x00402184
  400b28:	00400e61 	.word	0x00400e61

00400b2c <spi_m_sync_init>:
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
  400b2c:	b538      	push	{r3, r4, r5, lr}
	int32_t rc = 0;
	ASSERT(spi && hw);
  400b2e:	4604      	mov	r4, r0
  400b30:	460d      	mov	r5, r1
  400b32:	2800      	cmp	r0, #0
  400b34:	bf18      	it	ne
  400b36:	2900      	cmpne	r1, #0
  400b38:	bf14      	ite	ne
  400b3a:	2001      	movne	r0, #1
  400b3c:	2000      	moveq	r0, #0
  400b3e:	2240      	movs	r2, #64	; 0x40
  400b40:	4909      	ldr	r1, [pc, #36]	; (400b68 <spi_m_sync_init+0x3c>)
  400b42:	4b0a      	ldr	r3, [pc, #40]	; (400b6c <spi_m_sync_init+0x40>)
  400b44:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
  400b46:	4620      	mov	r0, r4
  400b48:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
  400b4c:	4629      	mov	r1, r5
  400b4e:	4b08      	ldr	r3, [pc, #32]	; (400b70 <spi_m_sync_init+0x44>)
  400b50:	4798      	blx	r3

	if (rc < 0) {
  400b52:	2800      	cmp	r0, #0
  400b54:	db07      	blt.n	400b66 <spi_m_sync_init+0x3a>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
  400b56:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400b5a:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
  400b5c:	4b05      	ldr	r3, [pc, #20]	; (400b74 <spi_m_sync_init+0x48>)
  400b5e:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
  400b60:	4b05      	ldr	r3, [pc, #20]	; (400b78 <spi_m_sync_init+0x4c>)
  400b62:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
  400b64:	2000      	movs	r0, #0
}
  400b66:	bd38      	pop	{r3, r4, r5, pc}
  400b68:	00402184 	.word	0x00402184
  400b6c:	00400e61 	.word	0x00400e61
  400b70:	00401645 	.word	0x00401645
  400b74:	00400c21 	.word	0x00400c21
  400b78:	00400be5 	.word	0x00400be5

00400b7c <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
  400b7c:	b510      	push	{r4, lr}
	ASSERT(spi);
  400b7e:	4604      	mov	r4, r0
  400b80:	2257      	movs	r2, #87	; 0x57
  400b82:	4905      	ldr	r1, [pc, #20]	; (400b98 <spi_m_sync_enable+0x1c>)
  400b84:	3000      	adds	r0, #0
  400b86:	bf18      	it	ne
  400b88:	2001      	movne	r0, #1
  400b8a:	4b04      	ldr	r3, [pc, #16]	; (400b9c <spi_m_sync_enable+0x20>)
  400b8c:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
  400b8e:	1d20      	adds	r0, r4, #4
  400b90:	4b03      	ldr	r3, [pc, #12]	; (400ba0 <spi_m_sync_enable+0x24>)
  400b92:	4798      	blx	r3
  400b94:	bd10      	pop	{r4, pc}
  400b96:	bf00      	nop
  400b98:	00402184 	.word	0x00402184
  400b9c:	00400e61 	.word	0x00400e61
  400ba0:	004016ed 	.word	0x004016ed

00400ba4 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
  400ba4:	b530      	push	{r4, r5, lr}
  400ba6:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
  400ba8:	4605      	mov	r5, r0
  400baa:	460c      	mov	r4, r1
  400bac:	2800      	cmp	r0, #0
  400bae:	bf18      	it	ne
  400bb0:	2900      	cmpne	r1, #0
  400bb2:	bf14      	ite	ne
  400bb4:	2001      	movne	r0, #1
  400bb6:	2000      	moveq	r0, #0
  400bb8:	22b3      	movs	r2, #179	; 0xb3
  400bba:	4907      	ldr	r1, [pc, #28]	; (400bd8 <spi_m_sync_transfer+0x34>)
  400bbc:	4b07      	ldr	r3, [pc, #28]	; (400bdc <spi_m_sync_transfer+0x38>)
  400bbe:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
  400bc0:	6823      	ldr	r3, [r4, #0]
  400bc2:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
  400bc4:	6863      	ldr	r3, [r4, #4]
  400bc6:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
  400bc8:	68a3      	ldr	r3, [r4, #8]
  400bca:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
  400bcc:	a901      	add	r1, sp, #4
  400bce:	1d28      	adds	r0, r5, #4
  400bd0:	4b03      	ldr	r3, [pc, #12]	; (400be0 <spi_m_sync_transfer+0x3c>)
  400bd2:	4798      	blx	r3
}
  400bd4:	b005      	add	sp, #20
  400bd6:	bd30      	pop	{r4, r5, pc}
  400bd8:	00402184 	.word	0x00402184
  400bdc:	00400e61 	.word	0x00400e61
  400be0:	00401721 	.word	0x00401721

00400be4 <_spi_m_sync_io_write>:
{
  400be4:	b570      	push	{r4, r5, r6, lr}
  400be6:	b084      	sub	sp, #16
  400be8:	460e      	mov	r6, r1
  400bea:	4615      	mov	r5, r2
	ASSERT(io);
  400bec:	4604      	mov	r4, r0
  400bee:	22a3      	movs	r2, #163	; 0xa3
  400bf0:	4908      	ldr	r1, [pc, #32]	; (400c14 <_spi_m_sync_io_write+0x30>)
  400bf2:	3000      	adds	r0, #0
  400bf4:	bf18      	it	ne
  400bf6:	2001      	movne	r0, #1
  400bf8:	4b07      	ldr	r3, [pc, #28]	; (400c18 <_spi_m_sync_io_write+0x34>)
  400bfa:	4798      	blx	r3
	xfer.rxbuf = 0;
  400bfc:	2300      	movs	r3, #0
  400bfe:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
  400c00:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
  400c02:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400c04:	a901      	add	r1, sp, #4
  400c06:	f1a4 000c 	sub.w	r0, r4, #12
  400c0a:	4b04      	ldr	r3, [pc, #16]	; (400c1c <_spi_m_sync_io_write+0x38>)
  400c0c:	4798      	blx	r3
}
  400c0e:	b004      	add	sp, #16
  400c10:	bd70      	pop	{r4, r5, r6, pc}
  400c12:	bf00      	nop
  400c14:	00402184 	.word	0x00402184
  400c18:	00400e61 	.word	0x00400e61
  400c1c:	00400ba5 	.word	0x00400ba5

00400c20 <_spi_m_sync_io_read>:
{
  400c20:	b570      	push	{r4, r5, r6, lr}
  400c22:	b084      	sub	sp, #16
  400c24:	460e      	mov	r6, r1
  400c26:	4615      	mov	r5, r2
	ASSERT(io);
  400c28:	4604      	mov	r4, r0
  400c2a:	2287      	movs	r2, #135	; 0x87
  400c2c:	4908      	ldr	r1, [pc, #32]	; (400c50 <_spi_m_sync_io_read+0x30>)
  400c2e:	3000      	adds	r0, #0
  400c30:	bf18      	it	ne
  400c32:	2001      	movne	r0, #1
  400c34:	4b07      	ldr	r3, [pc, #28]	; (400c54 <_spi_m_sync_io_read+0x34>)
  400c36:	4798      	blx	r3
	xfer.rxbuf = buf;
  400c38:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
  400c3a:	2300      	movs	r3, #0
  400c3c:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
  400c3e:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400c40:	a901      	add	r1, sp, #4
  400c42:	f1a4 000c 	sub.w	r0, r4, #12
  400c46:	4b04      	ldr	r3, [pc, #16]	; (400c58 <_spi_m_sync_io_read+0x38>)
  400c48:	4798      	blx	r3
}
  400c4a:	b004      	add	sp, #16
  400c4c:	bd70      	pop	{r4, r5, r6, pc}
  400c4e:	bf00      	nop
  400c50:	00402184 	.word	0x00402184
  400c54:	00400e61 	.word	0x00400e61
  400c58:	00400ba5 	.word	0x00400ba5

00400c5c <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
  400c5c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(spi && io);
  400c5e:	4604      	mov	r4, r0
  400c60:	460d      	mov	r5, r1
  400c62:	2800      	cmp	r0, #0
  400c64:	bf18      	it	ne
  400c66:	2900      	cmpne	r1, #0
  400c68:	bf14      	ite	ne
  400c6a:	2001      	movne	r0, #1
  400c6c:	2000      	moveq	r0, #0
  400c6e:	22bd      	movs	r2, #189	; 0xbd
  400c70:	4903      	ldr	r1, [pc, #12]	; (400c80 <spi_m_sync_get_io_descriptor+0x24>)
  400c72:	4b04      	ldr	r3, [pc, #16]	; (400c84 <spi_m_sync_get_io_descriptor+0x28>)
  400c74:	4798      	blx	r3
	*io = &spi->io;
  400c76:	340c      	adds	r4, #12
  400c78:	602c      	str	r4, [r5, #0]
	return 0;
}
  400c7a:	2000      	movs	r0, #0
  400c7c:	bd38      	pop	{r3, r4, r5, pc}
  400c7e:	bf00      	nop
  400c80:	00402184 	.word	0x00402184
  400c84:	00400e61 	.word	0x00400e61

00400c88 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
  400c88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 * \return A pointer to the head of the given list or NULL if the list is
 * empty
 */
static inline void *list_get_head(const struct list_descriptor *const list)
{
	return (void *)list->head;
  400c8a:	6807      	ldr	r7, [r0, #0]
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);

	if (!head) {
  400c8c:	b117      	cbz	r7, 400c94 <timer_add_timer_task+0xc>
  400c8e:	463c      	mov	r4, r7
  400c90:	2600      	movs	r6, #0
  400c92:	e00b      	b.n	400cac <timer_add_timer_task+0x24>
		list_insert_as_head(list, new_task);
  400c94:	4b0e      	ldr	r3, [pc, #56]	; (400cd0 <timer_add_timer_task+0x48>)
  400c96:	4798      	blx	r3
		return;
  400c98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uint32_t time_left;

		if (it->time_label <= time) {
			time_left = it->interval - (time - it->time_label);
		} else {
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
  400c9a:	68a5      	ldr	r5, [r4, #8]
  400c9c:	442b      	add	r3, r5
  400c9e:	1a9b      	subs	r3, r3, r2
  400ca0:	3301      	adds	r3, #1
		}
		if (time_left >= new_task->interval)
  400ca2:	688d      	ldr	r5, [r1, #8]
  400ca4:	42ab      	cmp	r3, r5
  400ca6:	d209      	bcs.n	400cbc <timer_add_timer_task+0x34>
			break;
		prev = it;
  400ca8:	4626      	mov	r6, r4
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
  400caa:	6824      	ldr	r4, [r4, #0]
  400cac:	b134      	cbz	r4, 400cbc <timer_add_timer_task+0x34>
		if (it->time_label <= time) {
  400cae:	6863      	ldr	r3, [r4, #4]
  400cb0:	4293      	cmp	r3, r2
  400cb2:	d8f2      	bhi.n	400c9a <timer_add_timer_task+0x12>
			time_left = it->interval - (time - it->time_label);
  400cb4:	68a5      	ldr	r5, [r4, #8]
  400cb6:	1a9b      	subs	r3, r3, r2
  400cb8:	442b      	add	r3, r5
  400cba:	e7f2      	b.n	400ca2 <timer_add_timer_task+0x1a>
	}

	if (it == head) {
  400cbc:	42bc      	cmp	r4, r7
  400cbe:	d003      	beq.n	400cc8 <timer_add_timer_task+0x40>
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
  400cc0:	4630      	mov	r0, r6
  400cc2:	4b04      	ldr	r3, [pc, #16]	; (400cd4 <timer_add_timer_task+0x4c>)
  400cc4:	4798      	blx	r3
  400cc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		list_insert_as_head(list, new_task);
  400cc8:	4b01      	ldr	r3, [pc, #4]	; (400cd0 <timer_add_timer_task+0x48>)
  400cca:	4798      	blx	r3
  400ccc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400cce:	bf00      	nop
  400cd0:	00400e7d 	.word	0x00400e7d
  400cd4:	00400ea9 	.word	0x00400ea9

00400cd8 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
  400cd8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400cda:	6944      	ldr	r4, [r0, #20]
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
  400cdc:	6906      	ldr	r6, [r0, #16]
  400cde:	3601      	adds	r6, #1
  400ce0:	6106      	str	r6, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
  400ce2:	7e03      	ldrb	r3, [r0, #24]
  400ce4:	f013 0f01 	tst.w	r3, #1
  400ce8:	d105      	bne.n	400cf6 <timer_process_counted+0x1e>
  400cea:	7e03      	ldrb	r3, [r0, #24]
  400cec:	f013 0f02 	tst.w	r3, #2
  400cf0:	d101      	bne.n	400cf6 <timer_process_counted+0x1e>
  400cf2:	4605      	mov	r5, r0
  400cf4:	e009      	b.n	400d0a <timer_process_counted+0x32>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
  400cf6:	7e03      	ldrb	r3, [r0, #24]
  400cf8:	f043 0302 	orr.w	r3, r3, #2
  400cfc:	7603      	strb	r3, [r0, #24]
		return;
  400cfe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400d00:	696f      	ldr	r7, [r5, #20]
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);

		tmp->cb(tmp);
  400d02:	68e3      	ldr	r3, [r4, #12]
  400d04:	4620      	mov	r0, r4
  400d06:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
  400d08:	463c      	mov	r4, r7
	while (it && ((time - it->time_label) >= it->interval)) {
  400d0a:	b19c      	cbz	r4, 400d34 <timer_process_counted+0x5c>
  400d0c:	6863      	ldr	r3, [r4, #4]
  400d0e:	1af3      	subs	r3, r6, r3
  400d10:	68a2      	ldr	r2, [r4, #8]
  400d12:	4293      	cmp	r3, r2
  400d14:	d30e      	bcc.n	400d34 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
  400d16:	f105 0714 	add.w	r7, r5, #20
  400d1a:	4638      	mov	r0, r7
  400d1c:	4b06      	ldr	r3, [pc, #24]	; (400d38 <timer_process_counted+0x60>)
  400d1e:	4798      	blx	r3
		if (TIMER_TASK_REPEAT == tmp->mode) {
  400d20:	7c23      	ldrb	r3, [r4, #16]
  400d22:	2b01      	cmp	r3, #1
  400d24:	d1ec      	bne.n	400d00 <timer_process_counted+0x28>
			tmp->time_label = time;
  400d26:	6066      	str	r6, [r4, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
  400d28:	4632      	mov	r2, r6
  400d2a:	4621      	mov	r1, r4
  400d2c:	4638      	mov	r0, r7
  400d2e:	4b03      	ldr	r3, [pc, #12]	; (400d3c <timer_process_counted+0x64>)
  400d30:	4798      	blx	r3
  400d32:	e7e5      	b.n	400d00 <timer_process_counted+0x28>
  400d34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400d36:	bf00      	nop
  400d38:	00400eb1 	.word	0x00400eb1
  400d3c:	00400c89 	.word	0x00400c89

00400d40 <timer_init>:
{
  400d40:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400d42:	4604      	mov	r4, r0
  400d44:	460d      	mov	r5, r1
  400d46:	2800      	cmp	r0, #0
  400d48:	bf18      	it	ne
  400d4a:	2900      	cmpne	r1, #0
  400d4c:	bf14      	ite	ne
  400d4e:	2001      	movne	r0, #1
  400d50:	2000      	moveq	r0, #0
  400d52:	223b      	movs	r2, #59	; 0x3b
  400d54:	4905      	ldr	r1, [pc, #20]	; (400d6c <timer_init+0x2c>)
  400d56:	4b06      	ldr	r3, [pc, #24]	; (400d70 <timer_init+0x30>)
  400d58:	4798      	blx	r3
	_timer_init(&descr->device, hw);
  400d5a:	4629      	mov	r1, r5
  400d5c:	4620      	mov	r0, r4
  400d5e:	4b05      	ldr	r3, [pc, #20]	; (400d74 <timer_init+0x34>)
  400d60:	4798      	blx	r3
	descr->time                           = 0;
  400d62:	2000      	movs	r0, #0
  400d64:	6120      	str	r0, [r4, #16]
	descr->device.timer_cb.period_expired = timer_process_counted;
  400d66:	4b04      	ldr	r3, [pc, #16]	; (400d78 <timer_init+0x38>)
  400d68:	6023      	str	r3, [r4, #0]
}
  400d6a:	bd38      	pop	{r3, r4, r5, pc}
  400d6c:	004021a0 	.word	0x004021a0
  400d70:	00400e61 	.word	0x00400e61
  400d74:	004018e9 	.word	0x004018e9
  400d78:	00400cd9 	.word	0x00400cd9

00400d7c <timer_start>:
{
  400d7c:	b510      	push	{r4, lr}
	ASSERT(descr);
  400d7e:	4604      	mov	r4, r0
  400d80:	2253      	movs	r2, #83	; 0x53
  400d82:	4909      	ldr	r1, [pc, #36]	; (400da8 <timer_start+0x2c>)
  400d84:	3000      	adds	r0, #0
  400d86:	bf18      	it	ne
  400d88:	2001      	movne	r0, #1
  400d8a:	4b08      	ldr	r3, [pc, #32]	; (400dac <timer_start+0x30>)
  400d8c:	4798      	blx	r3
	if (_timer_is_started(&descr->device)) {
  400d8e:	4620      	mov	r0, r4
  400d90:	4b07      	ldr	r3, [pc, #28]	; (400db0 <timer_start+0x34>)
  400d92:	4798      	blx	r3
  400d94:	b920      	cbnz	r0, 400da0 <timer_start+0x24>
	_timer_start(&descr->device);
  400d96:	4620      	mov	r0, r4
  400d98:	4b06      	ldr	r3, [pc, #24]	; (400db4 <timer_start+0x38>)
  400d9a:	4798      	blx	r3
	return ERR_NONE;
  400d9c:	2000      	movs	r0, #0
  400d9e:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
  400da0:	f06f 0010 	mvn.w	r0, #16
}
  400da4:	bd10      	pop	{r4, pc}
  400da6:	bf00      	nop
  400da8:	004021a0 	.word	0x004021a0
  400dac:	00400e61 	.word	0x00400e61
  400db0:	004019ad 	.word	0x004019ad
  400db4:	004019a5 	.word	0x004019a5

00400db8 <timer_add_task>:
{
  400db8:	b570      	push	{r4, r5, r6, lr}
  400dba:	b082      	sub	sp, #8
	ASSERT(descr && task);
  400dbc:	4604      	mov	r4, r0
  400dbe:	460d      	mov	r5, r1
  400dc0:	2800      	cmp	r0, #0
  400dc2:	bf18      	it	ne
  400dc4:	2900      	cmpne	r1, #0
  400dc6:	bf14      	ite	ne
  400dc8:	2001      	movne	r0, #1
  400dca:	2000      	moveq	r0, #0
  400dcc:	227a      	movs	r2, #122	; 0x7a
  400dce:	491d      	ldr	r1, [pc, #116]	; (400e44 <timer_add_task+0x8c>)
  400dd0:	4b1d      	ldr	r3, [pc, #116]	; (400e48 <timer_add_task+0x90>)
  400dd2:	4798      	blx	r3
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
  400dd4:	7e23      	ldrb	r3, [r4, #24]
  400dd6:	f043 0301 	orr.w	r3, r3, #1
  400dda:	7623      	strb	r3, [r4, #24]
	if (is_list_element(&descr->tasks, task)) {
  400ddc:	f104 0614 	add.w	r6, r4, #20
  400de0:	4629      	mov	r1, r5
  400de2:	4630      	mov	r0, r6
  400de4:	4b19      	ldr	r3, [pc, #100]	; (400e4c <timer_add_task+0x94>)
  400de6:	4798      	blx	r3
  400de8:	b988      	cbnz	r0, 400e0e <timer_add_task+0x56>
	task->time_label = descr->time;
  400dea:	6923      	ldr	r3, [r4, #16]
  400dec:	606b      	str	r3, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
  400dee:	6922      	ldr	r2, [r4, #16]
  400df0:	4629      	mov	r1, r5
  400df2:	4630      	mov	r0, r6
  400df4:	4b16      	ldr	r3, [pc, #88]	; (400e50 <timer_add_task+0x98>)
  400df6:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
  400df8:	7e23      	ldrb	r3, [r4, #24]
  400dfa:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
  400dfe:	7623      	strb	r3, [r4, #24]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
  400e00:	7e23      	ldrb	r3, [r4, #24]
  400e02:	f013 0f02 	tst.w	r3, #2
  400e06:	d10e      	bne.n	400e26 <timer_add_task+0x6e>
	return ERR_NONE;
  400e08:	2000      	movs	r0, #0
}
  400e0a:	b002      	add	sp, #8
  400e0c:	bd70      	pop	{r4, r5, r6, pc}
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
  400e0e:	7e23      	ldrb	r3, [r4, #24]
  400e10:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
  400e14:	7623      	strb	r3, [r4, #24]
		ASSERT(false);
  400e16:	227f      	movs	r2, #127	; 0x7f
  400e18:	490a      	ldr	r1, [pc, #40]	; (400e44 <timer_add_task+0x8c>)
  400e1a:	2000      	movs	r0, #0
  400e1c:	4b0a      	ldr	r3, [pc, #40]	; (400e48 <timer_add_task+0x90>)
  400e1e:	4798      	blx	r3
		return ERR_ALREADY_INITIALIZED;
  400e20:	f06f 0011 	mvn.w	r0, #17
  400e24:	e7f1      	b.n	400e0a <timer_add_task+0x52>
		CRITICAL_SECTION_ENTER()
  400e26:	a801      	add	r0, sp, #4
  400e28:	4b0a      	ldr	r3, [pc, #40]	; (400e54 <timer_add_task+0x9c>)
  400e2a:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
  400e2c:	7e23      	ldrb	r3, [r4, #24]
  400e2e:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
  400e32:	7623      	strb	r3, [r4, #24]
		_timer_set_irq(&descr->device);
  400e34:	4620      	mov	r0, r4
  400e36:	4b08      	ldr	r3, [pc, #32]	; (400e58 <timer_add_task+0xa0>)
  400e38:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
  400e3a:	a801      	add	r0, sp, #4
  400e3c:	4b07      	ldr	r3, [pc, #28]	; (400e5c <timer_add_task+0xa4>)
  400e3e:	4798      	blx	r3
	return ERR_NONE;
  400e40:	2000      	movs	r0, #0
  400e42:	e7e2      	b.n	400e0a <timer_add_task+0x52>
  400e44:	004021a0 	.word	0x004021a0
  400e48:	00400e61 	.word	0x00400e61
  400e4c:	00400e67 	.word	0x00400e67
  400e50:	00400c89 	.word	0x00400c89
  400e54:	004007e1 	.word	0x004007e1
  400e58:	004019b9 	.word	0x004019b9
  400e5c:	004007ef 	.word	0x004007ef

00400e60 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  400e60:	b900      	cbnz	r0, 400e64 <assert+0x4>
		__asm("BKPT #0");
  400e62:	be00      	bkpt	0x0000
  400e64:	4770      	bx	lr

00400e66 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
  400e66:	6803      	ldr	r3, [r0, #0]
  400e68:	b11b      	cbz	r3, 400e72 <is_list_element+0xc>
		if (it == element) {
  400e6a:	428b      	cmp	r3, r1
  400e6c:	d003      	beq.n	400e76 <is_list_element+0x10>
	for (it = list->head; it; it = it->next) {
  400e6e:	681b      	ldr	r3, [r3, #0]
  400e70:	e7fa      	b.n	400e68 <is_list_element+0x2>
			return true;
		}
	}

	return false;
  400e72:	2000      	movs	r0, #0
  400e74:	4770      	bx	lr
			return true;
  400e76:	2001      	movs	r0, #1
}
  400e78:	4770      	bx	lr
	...

00400e7c <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
  400e7c:	b538      	push	{r3, r4, r5, lr}
  400e7e:	4604      	mov	r4, r0
  400e80:	460d      	mov	r5, r1
	ASSERT(!is_list_element(list, element));
  400e82:	4b06      	ldr	r3, [pc, #24]	; (400e9c <list_insert_as_head+0x20>)
  400e84:	4798      	blx	r3
  400e86:	f080 0001 	eor.w	r0, r0, #1
  400e8a:	2239      	movs	r2, #57	; 0x39
  400e8c:	4904      	ldr	r1, [pc, #16]	; (400ea0 <list_insert_as_head+0x24>)
  400e8e:	b2c0      	uxtb	r0, r0
  400e90:	4b04      	ldr	r3, [pc, #16]	; (400ea4 <list_insert_as_head+0x28>)
  400e92:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
  400e94:	6823      	ldr	r3, [r4, #0]
  400e96:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
  400e98:	6025      	str	r5, [r4, #0]
  400e9a:	bd38      	pop	{r3, r4, r5, pc}
  400e9c:	00400e67 	.word	0x00400e67
  400ea0:	004021b8 	.word	0x004021b8
  400ea4:	00400e61 	.word	0x00400e61

00400ea8 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
  400ea8:	6803      	ldr	r3, [r0, #0]
  400eaa:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
  400eac:	6001      	str	r1, [r0, #0]
  400eae:	4770      	bx	lr

00400eb0 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
  400eb0:	6803      	ldr	r3, [r0, #0]
  400eb2:	b11b      	cbz	r3, 400ebc <list_remove_head+0xc>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
  400eb4:	681a      	ldr	r2, [r3, #0]
  400eb6:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
  400eb8:	4618      	mov	r0, r3
  400eba:	4770      	bx	lr
	}

	return NULL;
  400ebc:	2000      	movs	r0, #0
}
  400ebe:	4770      	bx	lr

00400ec0 <_afec_init>:
 */
static int32_t _afec_init(void *const hw, const uint8_t i)
{
	uint8_t cnt;

	hri_afec_write_MR_reg(hw, _afecs[i].mr);
  400ec0:	2364      	movs	r3, #100	; 0x64
  400ec2:	4a1d      	ldr	r2, [pc, #116]	; (400f38 <_afec_init+0x78>)
  400ec4:	fb03 2301 	mla	r3, r3, r1, r2
  400ec8:	685a      	ldr	r2, [r3, #4]
}

static inline void hri_afec_write_MR_reg(const void *const hw, hri_afec_mr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_MR = data;
  400eca:	6042      	str	r2, [r0, #4]
	hri_afec_write_EMR_reg(hw, _afecs[i].emr);
  400ecc:	689a      	ldr	r2, [r3, #8]
}

static inline void hri_afec_write_EMR_reg(const void *const hw, hri_afec_emr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_EMR = data;
  400ece:	6082      	str	r2, [r0, #8]
	hri_afec_write_SEQ1R_reg(hw, _afecs[i].seq1r);
  400ed0:	68da      	ldr	r2, [r3, #12]
}

static inline void hri_afec_write_SEQ1R_reg(const void *const hw, hri_afec_seq1r_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_SEQ1R = data;
  400ed2:	60c2      	str	r2, [r0, #12]
	hri_afec_write_SEQ2R_reg(hw, _afecs[i].seq2r);
  400ed4:	691a      	ldr	r2, [r3, #16]
}

static inline void hri_afec_write_SEQ2R_reg(const void *const hw, hri_afec_seq2r_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_SEQ2R = data;
  400ed6:	6102      	str	r2, [r0, #16]
	hri_afec_write_CWR_reg(hw, _afecs[i].cwr);
  400ed8:	695a      	ldr	r2, [r3, #20]
}

static inline void hri_afec_write_CWR_reg(const void *const hw, hri_afec_cwr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_CWR = data;
  400eda:	6502      	str	r2, [r0, #80]	; 0x50
	hri_afec_write_CGR_reg(hw, _afecs[i].cgr);
  400edc:	699a      	ldr	r2, [r3, #24]
}

static inline void hri_afec_write_CGR_reg(const void *const hw, hri_afec_cgr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_CGR = data;
  400ede:	6542      	str	r2, [r0, #84]	; 0x54
	hri_afec_write_DIFFR_reg(hw, _afecs[i].diffr);
  400ee0:	69da      	ldr	r2, [r3, #28]
}

static inline void hri_afec_write_DIFFR_reg(const void *const hw, hri_afec_diffr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_DIFFR = data;
  400ee2:	6602      	str	r2, [r0, #96]	; 0x60
	hri_afec_write_ACR_reg(hw, _afecs[i].acr);
  400ee4:	6a1a      	ldr	r2, [r3, #32]
}

static inline void hri_afec_write_ACR_reg(const void *const hw, hri_afec_acr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_ACR = data;
  400ee6:	f8c0 2094 	str.w	r2, [r0, #148]	; 0x94
	hri_afec_write_SHMR_reg(hw, _afecs[i].shmr);
  400eea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
}

static inline void hri_afec_write_SHMR_reg(const void *const hw, hri_afec_shmr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_SHMR = data;
  400eec:	f8c0 20a0 	str.w	r2, [r0, #160]	; 0xa0
	hri_afec_write_COSR_reg(hw, _afecs[i].cosr);
  400ef0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
}

static inline void hri_afec_write_COSR_reg(const void *const hw, hri_afec_cosr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_COSR = data;
  400ef2:	f8c0 20d0 	str.w	r2, [r0, #208]	; 0xd0
	hri_afec_write_CVR_reg(hw, _afecs[i].cvr);
  400ef6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
}

static inline void hri_afec_write_CVR_reg(const void *const hw, hri_afec_cvr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_CVR = data;
  400ef8:	f8c0 20d4 	str.w	r2, [r0, #212]	; 0xd4
	hri_afec_write_CECR_reg(hw, _afecs[i].cecr);
  400efc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}

static inline void hri_afec_write_CECR_reg(const void *const hw, hri_afec_cecr_reg_t data)
{
	AFEC_CRITICAL_SECTION_ENTER();
	((Afec *)hw)->AFEC_CECR = data;
  400efe:	f8c0 30d8 	str.w	r3, [r0, #216]	; 0xd8

	for (cnt = 0; cnt < AFEC_CHANNEL_AMOUNT; cnt++) {
  400f02:	2200      	movs	r2, #0
  400f04:	2a0b      	cmp	r2, #11
  400f06:	d814      	bhi.n	400f32 <_afec_init+0x72>
{
  400f08:	b410      	push	{r4}
	((Afec *)hw)->AFEC_CSELR = data;
  400f0a:	6642      	str	r2, [r0, #100]	; 0x64
		hri_afec_write_CSELR_reg(hw, cnt);
		hri_afec_write_COCR_reg(hw, _afecs[i].cocr[cnt]);
  400f0c:	eb01 0381 	add.w	r3, r1, r1, lsl #2
  400f10:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  400f14:	4413      	add	r3, r2
  400f16:	330c      	adds	r3, #12
  400f18:	4c07      	ldr	r4, [pc, #28]	; (400f38 <_afec_init+0x78>)
  400f1a:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  400f1e:	685b      	ldr	r3, [r3, #4]
	((Afec *)hw)->AFEC_COCR = data;
  400f20:	66c3      	str	r3, [r0, #108]	; 0x6c
	for (cnt = 0; cnt < AFEC_CHANNEL_AMOUNT; cnt++) {
  400f22:	3201      	adds	r2, #1
  400f24:	b2d2      	uxtb	r2, r2
  400f26:	2a0b      	cmp	r2, #11
  400f28:	d9ef      	bls.n	400f0a <_afec_init+0x4a>
	}

	return ERR_NONE;
}
  400f2a:	2000      	movs	r0, #0
  400f2c:	f85d 4b04 	ldr.w	r4, [sp], #4
  400f30:	4770      	bx	lr
  400f32:	2000      	movs	r0, #0
  400f34:	4770      	bx	lr
  400f36:	bf00      	nop
  400f38:	004021d8 	.word	0x004021d8

00400f3c <_afec_get_hardware_index>:
{
  400f3c:	b508      	push	{r3, lr}
	if (hw == AFEC0) {
  400f3e:	4b09      	ldr	r3, [pc, #36]	; (400f64 <_afec_get_hardware_index+0x28>)
  400f40:	4298      	cmp	r0, r3
  400f42:	d00a      	beq.n	400f5a <_afec_get_hardware_index+0x1e>
	} else if (hw == AFEC1) {
  400f44:	f503 3320 	add.w	r3, r3, #163840	; 0x28000
  400f48:	4298      	cmp	r0, r3
  400f4a:	d008      	beq.n	400f5e <_afec_get_hardware_index+0x22>
	ASSERT(false);
  400f4c:	22a3      	movs	r2, #163	; 0xa3
  400f4e:	4906      	ldr	r1, [pc, #24]	; (400f68 <_afec_get_hardware_index+0x2c>)
  400f50:	2000      	movs	r0, #0
  400f52:	4b06      	ldr	r3, [pc, #24]	; (400f6c <_afec_get_hardware_index+0x30>)
  400f54:	4798      	blx	r3
	return 0;
  400f56:	2000      	movs	r0, #0
  400f58:	bd08      	pop	{r3, pc}
		return 0;
  400f5a:	2000      	movs	r0, #0
  400f5c:	bd08      	pop	{r3, pc}
		return 1;
  400f5e:	2001      	movs	r0, #1
}
  400f60:	bd08      	pop	{r3, pc}
  400f62:	bf00      	nop
  400f64:	4003c000 	.word	0x4003c000
  400f68:	0040223c 	.word	0x0040223c
  400f6c:	00400e61 	.word	0x00400e61

00400f70 <_afec_get_regs>:
{
  400f70:	b508      	push	{r3, lr}
	uint8_t n = _afec_get_hardware_index((const void *)hw_addr);
  400f72:	4b08      	ldr	r3, [pc, #32]	; (400f94 <_afec_get_regs+0x24>)
  400f74:	4798      	blx	r3
	for (i = 0; i < sizeof(_afecs) / sizeof(struct afec_configuration); i++) {
  400f76:	2300      	movs	r3, #0
  400f78:	b113      	cbz	r3, 400f80 <_afec_get_regs+0x10>
	return 0;
  400f7a:	2300      	movs	r3, #0
}
  400f7c:	4618      	mov	r0, r3
  400f7e:	bd08      	pop	{r3, pc}
		if (_afecs[i].number == n) {
  400f80:	2264      	movs	r2, #100	; 0x64
  400f82:	fb02 f203 	mul.w	r2, r2, r3
  400f86:	4904      	ldr	r1, [pc, #16]	; (400f98 <_afec_get_regs+0x28>)
  400f88:	5c8a      	ldrb	r2, [r1, r2]
  400f8a:	4290      	cmp	r0, r2
  400f8c:	d0f6      	beq.n	400f7c <_afec_get_regs+0xc>
	for (i = 0; i < sizeof(_afecs) / sizeof(struct afec_configuration); i++) {
  400f8e:	3301      	adds	r3, #1
  400f90:	b2db      	uxtb	r3, r3
  400f92:	e7f1      	b.n	400f78 <_afec_get_regs+0x8>
  400f94:	00400f3d 	.word	0x00400f3d
  400f98:	004021d8 	.word	0x004021d8

00400f9c <_adc_sync_init>:

/**
 * \brief Initialize ADC
 */
int32_t _adc_sync_init(struct _adc_sync_device *const device, void *const hw)
{
  400f9c:	b538      	push	{r3, r4, r5, lr}
  400f9e:	460c      	mov	r4, r1
	ASSERT(device);
  400fa0:	4605      	mov	r5, r0
  400fa2:	f44f 728d 	mov.w	r2, #282	; 0x11a
  400fa6:	4907      	ldr	r1, [pc, #28]	; (400fc4 <_adc_sync_init+0x28>)
  400fa8:	3000      	adds	r0, #0
  400faa:	bf18      	it	ne
  400fac:	2001      	movne	r0, #1
  400fae:	4b06      	ldr	r3, [pc, #24]	; (400fc8 <_adc_sync_init+0x2c>)
  400fb0:	4798      	blx	r3

	device->hw = hw;
  400fb2:	602c      	str	r4, [r5, #0]

	return _afec_init(hw, _afec_get_regs((uint32_t)hw));
  400fb4:	4620      	mov	r0, r4
  400fb6:	4b05      	ldr	r3, [pc, #20]	; (400fcc <_adc_sync_init+0x30>)
  400fb8:	4798      	blx	r3
  400fba:	4601      	mov	r1, r0
  400fbc:	4620      	mov	r0, r4
  400fbe:	4b04      	ldr	r3, [pc, #16]	; (400fd0 <_adc_sync_init+0x34>)
  400fc0:	4798      	blx	r3
}
  400fc2:	bd38      	pop	{r3, r4, r5, pc}
  400fc4:	0040223c 	.word	0x0040223c
  400fc8:	00400e61 	.word	0x00400e61
  400fcc:	00400f71 	.word	0x00400f71
  400fd0:	00400ec1 	.word	0x00400ec1

00400fd4 <_adc_sync_enable_channel>:
/**
 * \brief Enable ADC
 */
void _adc_sync_enable_channel(struct _adc_sync_device *const device, const uint8_t channel)
{
	hri_afec_set_CHSR_reg(device->hw, (1 << channel));
  400fd4:	6802      	ldr	r2, [r0, #0]
  400fd6:	2301      	movs	r3, #1
  400fd8:	fa03 f101 	lsl.w	r1, r3, r1
	((Afec *)hw)->AFEC_CHER = mask;
  400fdc:	6151      	str	r1, [r2, #20]
  400fde:	4770      	bx	lr

00400fe0 <_irq_set>:
/**
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
  400fe0:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400fe2:	2b00      	cmp	r3, #0
  400fe4:	db09      	blt.n	400ffa <_irq_set+0x1a>
  {
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400fe6:	095b      	lsrs	r3, r3, #5
  400fe8:	f000 001f 	and.w	r0, r0, #31
  400fec:	2201      	movs	r2, #1
  400fee:	fa02 f000 	lsl.w	r0, r2, r0
  400ff2:	3340      	adds	r3, #64	; 0x40
  400ff4:	4a01      	ldr	r2, [pc, #4]	; (400ffc <_irq_set+0x1c>)
  400ff6:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  400ffa:	4770      	bx	lr
  400ffc:	e000e100 	.word	0xe000e100

00401000 <_get_cycles_for_us>:
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
	return _get_cycles_for_us_internal(us, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  401000:	f44f 7396 	mov.w	r3, #300	; 0x12c
  401004:	fb03 f000 	mul.w	r0, r3, r0
  401008:	4770      	bx	lr
	...

0040100c <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  40100c:	b500      	push	{lr}
  40100e:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  401010:	a801      	add	r0, sp, #4
  401012:	4b0e      	ldr	r3, [pc, #56]	; (40104c <_init_chip+0x40>)
  401014:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  401016:	4a0e      	ldr	r2, [pc, #56]	; (401050 <_init_chip+0x44>)
  401018:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  40101c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  401020:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  401024:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401028:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  40102c:	a801      	add	r0, sp, #4
  40102e:	4b09      	ldr	r3, [pc, #36]	; (401054 <_init_chip+0x48>)
  401030:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  401032:	4a09      	ldr	r2, [pc, #36]	; (401058 <_init_chip+0x4c>)
  401034:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  401036:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  40103a:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  40103e:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  401040:	4b06      	ldr	r3, [pc, #24]	; (40105c <_init_chip+0x50>)
  401042:	4798      	blx	r3
}
  401044:	b003      	add	sp, #12
  401046:	f85d fb04 	ldr.w	pc, [sp], #4
  40104a:	bf00      	nop
  40104c:	004007e1 	.word	0x004007e1
  401050:	e000ed00 	.word	0xe000ed00
  401054:	004007ef 	.word	0x004007ef
  401058:	400e0c00 	.word	0x400e0c00
  40105c:	004013d1 	.word	0x004013d1

00401060 <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  401060:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  401062:	2500      	movs	r5, #0
  401064:	428d      	cmp	r5, r1
  401066:	d210      	bcs.n	40108a <_ffs+0x2a>
  401068:	2201      	movs	r2, #1
  40106a:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  40106c:	2b1f      	cmp	r3, #31
  40106e:	d80a      	bhi.n	401086 <_ffs+0x26>
			if (v[i] & bit) {
  401070:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  401074:	4222      	tst	r2, r4
  401076:	d102      	bne.n	40107e <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  401078:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  40107a:	3301      	adds	r3, #1
  40107c:	e7f6      	b.n	40106c <_ffs+0xc>
				return i * 32 + j;
  40107e:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  401082:	bc30      	pop	{r4, r5}
  401084:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  401086:	3501      	adds	r5, #1
  401088:	e7ec      	b.n	401064 <_ffs+0x4>
	return -1;
  40108a:	f04f 30ff 	mov.w	r0, #4294967295
  40108e:	e7f8      	b.n	401082 <_ffs+0x22>

00401090 <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  401090:	b510      	push	{r4, lr}
  401092:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  401094:	2300      	movs	r3, #0
  401096:	9301      	str	r3, [sp, #4]
  401098:	9302      	str	r3, [sp, #8]
  40109a:	9303      	str	r3, [sp, #12]
  40109c:	9304      	str	r3, [sp, #16]
  40109e:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  4010a0:	4b21      	ldr	r3, [pc, #132]	; (401128 <_ext_irq_handler+0x98>)
  4010a2:	6818      	ldr	r0, [r3, #0]
  4010a4:	22f8      	movs	r2, #248	; 0xf8
  4010a6:	4921      	ldr	r1, [pc, #132]	; (40112c <_ext_irq_handler+0x9c>)
  4010a8:	3000      	adds	r0, #0
  4010aa:	bf18      	it	ne
  4010ac:	2001      	movne	r0, #1
  4010ae:	4b20      	ldr	r3, [pc, #128]	; (401130 <_ext_irq_handler+0xa0>)
  4010b0:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  4010b2:	4b20      	ldr	r3, [pc, #128]	; (401134 <_ext_irq_handler+0xa4>)
  4010b4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  4010b6:	6c9b      	ldr	r3, [r3, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  4010b8:	4013      	ands	r3, r2
  4010ba:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  4010bc:	491e      	ldr	r1, [pc, #120]	; (401138 <_ext_irq_handler+0xa8>)
  4010be:	6cca      	ldr	r2, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  4010c0:	6c89      	ldr	r1, [r1, #72]	; 0x48
	flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	flags[1] = hri_pio_read_ISR_reg(PIOB);
	flags[1] &= hri_pio_read_IMR_reg(PIOB);
  4010c2:	400a      	ands	r2, r1
  4010c4:	9202      	str	r2, [sp, #8]
	flag_total |= flags[1];
  4010c6:	4313      	orrs	r3, r2
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  4010c8:	e025      	b.n	401116 <_ext_irq_handler+0x86>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  4010ca:	4b17      	ldr	r3, [pc, #92]	; (401128 <_ext_irq_handler+0x98>)
  4010cc:	681b      	ldr	r3, [r3, #0]
  4010ce:	4620      	mov	r0, r4
  4010d0:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  4010d2:	1163      	asrs	r3, r4, #5
  4010d4:	f004 041f 	and.w	r4, r4, #31
  4010d8:	2201      	movs	r2, #1
  4010da:	fa02 f404 	lsl.w	r4, r2, r4
  4010de:	aa06      	add	r2, sp, #24
  4010e0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  4010e4:	f853 2c14 	ldr.w	r2, [r3, #-20]
  4010e8:	ea22 0204 	bic.w	r2, r2, r4
  4010ec:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  4010f0:	2105      	movs	r1, #5
  4010f2:	a801      	add	r0, sp, #4
  4010f4:	4b11      	ldr	r3, [pc, #68]	; (40113c <_ext_irq_handler+0xac>)
  4010f6:	4798      	blx	r3
  4010f8:	4604      	mov	r4, r0
		while (-1 != pos) {
  4010fa:	f1b4 3fff 	cmp.w	r4, #4294967295
  4010fe:	d1e4      	bne.n	4010ca <_ext_irq_handler+0x3a>
	return ((Pio *)hw)->PIO_ISR;
  401100:	4a0c      	ldr	r2, [pc, #48]	; (401134 <_ext_irq_handler+0xa4>)
  401102:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  401104:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  401106:	400b      	ands	r3, r1
  401108:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  40110a:	490b      	ldr	r1, [pc, #44]	; (401138 <_ext_irq_handler+0xa8>)
  40110c:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  40110e:	6c8a      	ldr	r2, [r1, #72]	; 0x48
		flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
		flags[1] = hri_pio_read_ISR_reg(PIOB);
		flags[1] &= hri_pio_read_IMR_reg(PIOB);
  401110:	4002      	ands	r2, r0
  401112:	9202      	str	r2, [sp, #8]
		flag_total |= flags[1];
  401114:	4313      	orrs	r3, r2
	while (flag_total) {
  401116:	b12b      	cbz	r3, 401124 <_ext_irq_handler+0x94>
		pos = _ffs(flags, 5);
  401118:	2105      	movs	r1, #5
  40111a:	a801      	add	r0, sp, #4
  40111c:	4b07      	ldr	r3, [pc, #28]	; (40113c <_ext_irq_handler+0xac>)
  40111e:	4798      	blx	r3
  401120:	4604      	mov	r4, r0
		while (-1 != pos) {
  401122:	e7ea      	b.n	4010fa <_ext_irq_handler+0x6a>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  401124:	b006      	add	sp, #24
  401126:	bd10      	pop	{r4, pc}
  401128:	20400074 	.word	0x20400074
  40112c:	00402290 	.word	0x00402290
  401130:	00400e61 	.word	0x00400e61
  401134:	400e0e00 	.word	0x400e0e00
  401138:	400e1000 	.word	0x400e1000
  40113c:	00401061 	.word	0x00401061

00401140 <_pio_get_hardware_index>:
{
  401140:	b510      	push	{r4, lr}
	ASSERT(hw);
  401142:	4604      	mov	r4, r0
  401144:	22d2      	movs	r2, #210	; 0xd2
  401146:	4905      	ldr	r1, [pc, #20]	; (40115c <_pio_get_hardware_index+0x1c>)
  401148:	3000      	adds	r0, #0
  40114a:	bf18      	it	ne
  40114c:	2001      	movne	r0, #1
  40114e:	4b04      	ldr	r3, [pc, #16]	; (401160 <_pio_get_hardware_index+0x20>)
  401150:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  401152:	4804      	ldr	r0, [pc, #16]	; (401164 <_pio_get_hardware_index+0x24>)
  401154:	4420      	add	r0, r4
}
  401156:	f3c0 2047 	ubfx	r0, r0, #9, #8
  40115a:	bd10      	pop	{r4, pc}
  40115c:	00402290 	.word	0x00402290
  401160:	00400e61 	.word	0x00400e61
  401164:	bff1f200 	.word	0xbff1f200

00401168 <_pio_get_index>:
{
  401168:	b510      	push	{r4, lr}
	ASSERT(hw);
  40116a:	4604      	mov	r4, r0
  40116c:	22e0      	movs	r2, #224	; 0xe0
  40116e:	490d      	ldr	r1, [pc, #52]	; (4011a4 <_pio_get_index+0x3c>)
  401170:	3000      	adds	r0, #0
  401172:	bf18      	it	ne
  401174:	2001      	movne	r0, #1
  401176:	4b0c      	ldr	r3, [pc, #48]	; (4011a8 <_pio_get_index+0x40>)
  401178:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  40117a:	4620      	mov	r0, r4
  40117c:	4b0b      	ldr	r3, [pc, #44]	; (4011ac <_pio_get_index+0x44>)
  40117e:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  401180:	2300      	movs	r3, #0
  401182:	2b01      	cmp	r3, #1
  401184:	d80b      	bhi.n	40119e <_pio_get_index+0x36>
		if (_ext_irq[i].number == offset) {
  401186:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  40118a:	008a      	lsls	r2, r1, #2
  40118c:	4908      	ldr	r1, [pc, #32]	; (4011b0 <_pio_get_index+0x48>)
  40118e:	5c8a      	ldrb	r2, [r1, r2]
  401190:	4290      	cmp	r0, r2
  401192:	d002      	beq.n	40119a <_pio_get_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  401194:	3301      	adds	r3, #1
  401196:	b2db      	uxtb	r3, r3
  401198:	e7f3      	b.n	401182 <_pio_get_index+0x1a>
			return i;
  40119a:	b258      	sxtb	r0, r3
  40119c:	bd10      	pop	{r4, pc}
	return ERR_INVALID_DATA;
  40119e:	f04f 30ff 	mov.w	r0, #4294967295
}
  4011a2:	bd10      	pop	{r4, pc}
  4011a4:	00402290 	.word	0x00402290
  4011a8:	00400e61 	.word	0x00400e61
  4011ac:	00401141 	.word	0x00401141
  4011b0:	00402254 	.word	0x00402254

004011b4 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  4011b4:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  4011b6:	4604      	mov	r4, r0
  4011b8:	f240 1259 	movw	r2, #345	; 0x159
  4011bc:	4929      	ldr	r1, [pc, #164]	; (401264 <_pio_init+0xb0>)
  4011be:	3000      	adds	r0, #0
  4011c0:	bf18      	it	ne
  4011c2:	2001      	movne	r0, #1
  4011c4:	4b28      	ldr	r3, [pc, #160]	; (401268 <_pio_init+0xb4>)
  4011c6:	4798      	blx	r3

	i = _pio_get_index(hw);
  4011c8:	4620      	mov	r0, r4
  4011ca:	4b28      	ldr	r3, [pc, #160]	; (40126c <_pio_init+0xb8>)
  4011cc:	4798      	blx	r3
	if (i < 0) {
  4011ce:	2800      	cmp	r0, #0
  4011d0:	db43      	blt.n	40125a <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  4011d2:	4d27      	ldr	r5, [pc, #156]	; (401270 <_pio_init+0xbc>)
  4011d4:	00c2      	lsls	r2, r0, #3
  4011d6:	1a11      	subs	r1, r2, r0
  4011d8:	008b      	lsls	r3, r1, #2
  4011da:	442b      	add	r3, r5
  4011dc:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  4011de:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  4011e2:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  4011e4:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  4011e8:	6919      	ldr	r1, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  4011ea:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
  4011ee:	699b      	ldr	r3, [r3, #24]
	((Pio *)hw)->PIO_FELLSR = mask;
  4011f0:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  4011f4:	1a10      	subs	r0, r2, r0
  4011f6:	0083      	lsls	r3, r0, #2
  4011f8:	442b      	add	r3, r5
  4011fa:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  4011fc:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  401200:	4620      	mov	r0, r4
  401202:	4b1c      	ldr	r3, [pc, #112]	; (401274 <_pio_init+0xc0>)
  401204:	4798      	blx	r3
  401206:	4428      	add	r0, r5
  401208:	f990 3038 	ldrsb.w	r3, [r0, #56]	; 0x38
  if ((int32_t)(IRQn) >= 0)
  40120c:	2b00      	cmp	r3, #0
  40120e:	db0c      	blt.n	40122a <_pio_init+0x76>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401210:	095a      	lsrs	r2, r3, #5
  401212:	f003 001f 	and.w	r0, r3, #31
  401216:	2101      	movs	r1, #1
  401218:	4081      	lsls	r1, r0
  40121a:	3220      	adds	r2, #32
  40121c:	4816      	ldr	r0, [pc, #88]	; (401278 <_pio_init+0xc4>)
  40121e:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  401222:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401226:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  40122a:	2b00      	cmp	r3, #0
  40122c:	db08      	blt.n	401240 <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40122e:	095a      	lsrs	r2, r3, #5
  401230:	f003 001f 	and.w	r0, r3, #31
  401234:	2101      	movs	r1, #1
  401236:	4081      	lsls	r1, r0
  401238:	3260      	adds	r2, #96	; 0x60
  40123a:	480f      	ldr	r0, [pc, #60]	; (401278 <_pio_init+0xc4>)
  40123c:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  401240:	2b00      	cmp	r3, #0
  401242:	db0d      	blt.n	401260 <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401244:	0959      	lsrs	r1, r3, #5
  401246:	f003 031f 	and.w	r3, r3, #31
  40124a:	2201      	movs	r2, #1
  40124c:	fa02 f303 	lsl.w	r3, r2, r3
  401250:	4a09      	ldr	r2, [pc, #36]	; (401278 <_pio_init+0xc4>)
  401252:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  401256:	2000      	movs	r0, #0
  401258:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  40125a:	f06f 0010 	mvn.w	r0, #16
  40125e:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  401260:	2000      	movs	r0, #0
}
  401262:	bd38      	pop	{r3, r4, r5, pc}
  401264:	00402290 	.word	0x00402290
  401268:	00400e61 	.word	0x00400e61
  40126c:	00401169 	.word	0x00401169
  401270:	00402254 	.word	0x00402254
  401274:	00401141 	.word	0x00401141
  401278:	e000e100 	.word	0xe000e100

0040127c <PIOB_Handler>:
{
  40127c:	b508      	push	{r3, lr}
	_ext_irq_handler();
  40127e:	4b01      	ldr	r3, [pc, #4]	; (401284 <PIOB_Handler+0x8>)
  401280:	4798      	blx	r3
  401282:	bd08      	pop	{r3, pc}
  401284:	00401091 	.word	0x00401091

00401288 <PIOA_Handler>:
{
  401288:	b508      	push	{r3, lr}
	_ext_irq_handler();
  40128a:	4b01      	ldr	r3, [pc, #4]	; (401290 <PIOA_Handler+0x8>)
  40128c:	4798      	blx	r3
  40128e:	bd08      	pop	{r3, pc}
  401290:	00401091 	.word	0x00401091

00401294 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  401294:	b538      	push	{r3, r4, r5, lr}
  401296:	4605      	mov	r5, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  401298:	4804      	ldr	r0, [pc, #16]	; (4012ac <_ext_irq_init+0x18>)
  40129a:	4c05      	ldr	r4, [pc, #20]	; (4012b0 <_ext_irq_init+0x1c>)
  40129c:	47a0      	blx	r4
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	_pio_init(PIOB);
  40129e:	4805      	ldr	r0, [pc, #20]	; (4012b4 <_ext_irq_init+0x20>)
  4012a0:	47a0      	blx	r4

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  4012a2:	4b05      	ldr	r3, [pc, #20]	; (4012b8 <_ext_irq_init+0x24>)
  4012a4:	601d      	str	r5, [r3, #0]

	return ERR_NONE;
}
  4012a6:	2000      	movs	r0, #0
  4012a8:	bd38      	pop	{r3, r4, r5, pc}
  4012aa:	bf00      	nop
  4012ac:	400e0e00 	.word	0x400e0e00
  4012b0:	004011b5 	.word	0x004011b5
  4012b4:	400e1000 	.word	0x400e1000
  4012b8:	20400074 	.word	0x20400074

004012bc <_ext_irq_enable>:

	return ERR_NONE;
}

int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
  4012bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4012c0:	4604      	mov	r4, r0
  4012c2:	460f      	mov	r7, r1
	void *   hw   = PIOA;
	uint32_t temp = 0;

	ASSERT(pin < 160);
  4012c4:	f8df 8050 	ldr.w	r8, [pc, #80]	; 401318 <_ext_irq_enable+0x5c>
  4012c8:	f44f 72d3 	mov.w	r2, #422	; 0x1a6
  4012cc:	4641      	mov	r1, r8
  4012ce:	289f      	cmp	r0, #159	; 0x9f
  4012d0:	bf8c      	ite	hi
  4012d2:	2000      	movhi	r0, #0
  4012d4:	2001      	movls	r0, #1
  4012d6:	4e0e      	ldr	r6, [pc, #56]	; (401310 <_ext_irq_enable+0x54>)
  4012d8:	47b0      	blx	r6

	hw   = _get_hardware_instance(pin);
  4012da:	b2e5      	uxtb	r5, r4
	ASSERT(pin < 160);
  4012dc:	22c3      	movs	r2, #195	; 0xc3
  4012de:	4641      	mov	r1, r8
  4012e0:	2d9f      	cmp	r5, #159	; 0x9f
  4012e2:	bf8c      	ite	hi
  4012e4:	2000      	movhi	r0, #0
  4012e6:	2001      	movls	r0, #1
  4012e8:	47b0      	blx	r6
	return (void *)((uint32_t)PIOA + (pin >> 5) * 0x200);
  4012ea:	096d      	lsrs	r5, r5, #5
  4012ec:	4b09      	ldr	r3, [pc, #36]	; (401314 <_ext_irq_enable+0x58>)
  4012ee:	eb03 2545 	add.w	r5, r3, r5, lsl #9
	temp = pin & 31;
  4012f2:	f004 041f 	and.w	r4, r4, #31

	if (enable) {
  4012f6:	b937      	cbnz	r7, 401306 <_ext_irq_enable+0x4a>
		hri_pio_set_IMR_reg(hw, 1ul << temp);
	} else {
		hri_pio_clear_IMR_reg(hw, 1ul << temp);
  4012f8:	2301      	movs	r3, #1
  4012fa:	fa03 f404 	lsl.w	r4, r3, r4
	((Pio *)hw)->PIO_IDR = mask;
  4012fe:	646c      	str	r4, [r5, #68]	; 0x44
	}

	return ERR_NONE;
}
  401300:	2000      	movs	r0, #0
  401302:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		hri_pio_set_IMR_reg(hw, 1ul << temp);
  401306:	2301      	movs	r3, #1
  401308:	fa03 f404 	lsl.w	r4, r3, r4
	((Pio *)hw)->PIO_IER = mask;
  40130c:	642c      	str	r4, [r5, #64]	; 0x40
  40130e:	e7f7      	b.n	401300 <_ext_irq_enable+0x44>
  401310:	00400e61 	.word	0x00400e61
  401314:	400e0e00 	.word	0x400e0e00
  401318:	00402290 	.word	0x00402290

0040131c <_pmc_init_sources>:
}

static inline void hri_pmc_set_CKGR_MOR_reg(const void *const hw, hri_pmc_ckgr_mor_reg_t mask)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_MOR |= mask;
  40131c:	4a14      	ldr	r2, [pc, #80]	; (401370 <_pmc_init_sources+0x54>)
  40131e:	6a11      	ldr	r1, [r2, #32]
  401320:	4b14      	ldr	r3, [pc, #80]	; (401374 <_pmc_init_sources+0x58>)
  401322:	430b      	orrs	r3, r1
  401324:	6213      	str	r3, [r2, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCRCS) > 0;
  401326:	4b12      	ldr	r3, [pc, #72]	; (401370 <_pmc_init_sources+0x54>)
  401328:	6e9b      	ldr	r3, [r3, #104]	; 0x68

#if (CONF_CLK_MAINCK_ENABLE == 1)
#if (CONF_OSC12M_ENABLE && (CONF_CLK_GEN_MAINCK_SRC == CLK_SRC_OPTION_OSC12M))
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	hri_pmc_set_CKGR_MOR_reg(PMC, (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN));
	while (!hri_pmc_get_SR_MOSCRCS_bit(PMC)) {
  40132a:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  40132e:	d0fa      	beq.n	401326 <_pmc_init_sources+0xa>
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  401330:	490f      	ldr	r1, [pc, #60]	; (401370 <_pmc_init_sources+0x54>)
  401332:	6a0a      	ldr	r2, [r1, #32]
		/* Wait until the Fast RC to stabilize */
	}
	/* Change Fast RC oscillator frequency */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCRCF_Msk;
  401334:	f022 0270 	bic.w	r2, r2, #112	; 0x70
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCF(CONF_OSC12M_SELECTOR);
  401338:	4b0f      	ldr	r3, [pc, #60]	; (401378 <_pmc_init_sources+0x5c>)
  40133a:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  40133c:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCRCS) > 0;
  40133e:	4b0c      	ldr	r3, [pc, #48]	; (401370 <_pmc_init_sources+0x54>)
  401340:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCRCS_bit(PMC)) {
  401342:	f413 3f00 	tst.w	r3, #131072	; 0x20000
  401346:	d0fa      	beq.n	40133e <_pmc_init_sources+0x22>
	return ((Pmc *)hw)->CKGR_MOR;
  401348:	4b09      	ldr	r3, [pc, #36]	; (401370 <_pmc_init_sources+0x54>)
  40134a:	6a1a      	ldr	r2, [r3, #32]
		/* Wait until the Fast RC to stabilize */
	}
	/* Switch to Fast RC */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCSEL;
  40134c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
	data |= CKGR_MOR_KEY_PASSWD;
  401350:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
	((Pmc *)hw)->CKGR_MOR = data;
  401354:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  401356:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  401358:	4a08      	ldr	r2, [pc, #32]	; (40137c <_pmc_init_sources+0x60>)
  40135a:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  40135c:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  40135e:	4a08      	ldr	r2, [pc, #32]	; (401380 <_pmc_init_sources+0x64>)
  401360:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  401362:	4b03      	ldr	r3, [pc, #12]	; (401370 <_pmc_init_sources+0x54>)
  401364:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  401366:	f013 0f02 	tst.w	r3, #2
  40136a:	d0fa      	beq.n	401362 <_pmc_init_sources+0x46>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  40136c:	4770      	bx	lr
  40136e:	bf00      	nop
  401370:	400e0600 	.word	0x400e0600
  401374:	00370008 	.word	0x00370008
  401378:	00370020 	.word	0x00370020
  40137c:	f800ffff 	.word	0xf800ffff
  401380:	20183f01 	.word	0x20183f01

00401384 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  401384:	4a11      	ldr	r2, [pc, #68]	; (4013cc <_pmc_init_master_clock+0x48>)
  401386:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  401388:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  40138c:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  40138e:	4b0f      	ldr	r3, [pc, #60]	; (4013cc <_pmc_init_master_clock+0x48>)
  401390:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  401392:	f013 0f08 	tst.w	r3, #8
  401396:	d0fa      	beq.n	40138e <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  401398:	4a0c      	ldr	r2, [pc, #48]	; (4013cc <_pmc_init_master_clock+0x48>)
  40139a:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  40139c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  4013a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  4013a4:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4013a6:	4b09      	ldr	r3, [pc, #36]	; (4013cc <_pmc_init_master_clock+0x48>)
  4013a8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4013aa:	f013 0f08 	tst.w	r3, #8
  4013ae:	d0fa      	beq.n	4013a6 <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  4013b0:	4a06      	ldr	r2, [pc, #24]	; (4013cc <_pmc_init_master_clock+0x48>)
  4013b2:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  4013b4:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  4013b8:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  4013bc:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  4013be:	4b03      	ldr	r3, [pc, #12]	; (4013cc <_pmc_init_master_clock+0x48>)
  4013c0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  4013c2:	f013 0f08 	tst.w	r3, #8
  4013c6:	d0fa      	beq.n	4013be <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  4013c8:	4770      	bx	lr
  4013ca:	bf00      	nop
  4013cc:	400e0600 	.word	0x400e0600

004013d0 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  4013d0:	b508      	push	{r3, lr}
	_pmc_init_sources();
  4013d2:	4b02      	ldr	r3, [pc, #8]	; (4013dc <_pmc_init+0xc>)
  4013d4:	4798      	blx	r3
	_pmc_init_master_clock();
  4013d6:	4b02      	ldr	r3, [pc, #8]	; (4013e0 <_pmc_init+0x10>)
  4013d8:	4798      	blx	r3
  4013da:	bd08      	pop	{r3, pc}
  4013dc:	0040131d 	.word	0x0040131d
  4013e0:	00401385 	.word	0x00401385

004013e4 <_pwm_get_cfg>:
 */
static const struct _pwm_cfg *_pwm_get_cfg(void *const hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  4013e4:	2300      	movs	r3, #0
  4013e6:	2b01      	cmp	r3, #1
  4013e8:	d80f      	bhi.n	40140a <_pwm_get_cfg+0x26>
		if (_pwms[i].hw == hw) {
  4013ea:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
  4013ee:	008a      	lsls	r2, r1, #2
  4013f0:	4907      	ldr	r1, [pc, #28]	; (401410 <_pwm_get_cfg+0x2c>)
  4013f2:	588a      	ldr	r2, [r1, r2]
  4013f4:	4282      	cmp	r2, r0
  4013f6:	d002      	beq.n	4013fe <_pwm_get_cfg+0x1a>
	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  4013f8:	3301      	adds	r3, #1
  4013fa:	b2db      	uxtb	r3, r3
  4013fc:	e7f3      	b.n	4013e6 <_pwm_get_cfg+0x2>
			return (_pwms + i);
  4013fe:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  401402:	009a      	lsls	r2, r3, #2
  401404:	4608      	mov	r0, r1
  401406:	4410      	add	r0, r2
  401408:	4770      	bx	lr
		}
	}

	return NULL;
  40140a:	2000      	movs	r0, #0
}
  40140c:	4770      	bx	lr
  40140e:	bf00      	nop
  401410:	004022ac 	.word	0x004022ac

00401414 <_pwm_init_irq_param>:
/**
 * \brief Init irq param with the given pwm hardware instance
 */
static void _pwm_init_irq_param(const void *const hw, struct _pwm_device *dev)
{
	if (hw == PWM0) {
  401414:	4b06      	ldr	r3, [pc, #24]	; (401430 <_pwm_init_irq_param+0x1c>)
  401416:	4298      	cmp	r0, r3
  401418:	d003      	beq.n	401422 <_pwm_init_irq_param+0xe>
		_pwm0_dev = dev;
	}
	if (hw == PWM1) {
  40141a:	4b06      	ldr	r3, [pc, #24]	; (401434 <_pwm_init_irq_param+0x20>)
  40141c:	4298      	cmp	r0, r3
  40141e:	d003      	beq.n	401428 <_pwm_init_irq_param+0x14>
  401420:	4770      	bx	lr
		_pwm0_dev = dev;
  401422:	4b05      	ldr	r3, [pc, #20]	; (401438 <_pwm_init_irq_param+0x24>)
  401424:	6019      	str	r1, [r3, #0]
  401426:	e7f8      	b.n	40141a <_pwm_init_irq_param+0x6>
		_pwm1_dev = dev;
  401428:	4b03      	ldr	r3, [pc, #12]	; (401438 <_pwm_init_irq_param+0x24>)
  40142a:	6059      	str	r1, [r3, #4]
	}
}
  40142c:	e7f8      	b.n	401420 <_pwm_init_irq_param+0xc>
  40142e:	bf00      	nop
  401430:	40020000 	.word	0x40020000
  401434:	4005c000 	.word	0x4005c000
  401438:	20400078 	.word	0x20400078

0040143c <_pwm_interrupt_handler>:
 * \internal interrupt handler for PWM
 *
 * \param[in] instance PWM instance number
 */
static void _pwm_interrupt_handler(struct _pwm_device *device)
{
  40143c:	b508      	push	{r3, lr}
	if (hri_pwm_read_ISR1_reg(device->hw)) {
  40143e:	6903      	ldr	r3, [r0, #16]
	return tmp;
}

static inline hri_pwm_isr1_reg_t hri_pwm_read_ISR1_reg(const void *const hw)
{
	return ((Pwm *)hw)->PWM_ISR1;
  401440:	69db      	ldr	r3, [r3, #28]
  401442:	b113      	cbz	r3, 40144a <_pwm_interrupt_handler+0xe>
		if (NULL != device->callback.pwm_period_cb) {
  401444:	6803      	ldr	r3, [r0, #0]
  401446:	b103      	cbz	r3, 40144a <_pwm_interrupt_handler+0xe>
			device->callback.pwm_period_cb(device);
  401448:	4798      	blx	r3
  40144a:	bd08      	pop	{r3, pc}

0040144c <PWM0_Handler>:

/**
 * \internal PWM interrupt handler
 */
void PWM0_Handler(void)
{
  40144c:	b508      	push	{r3, lr}
	_pwm_interrupt_handler(_pwm0_dev);
  40144e:	4b02      	ldr	r3, [pc, #8]	; (401458 <PWM0_Handler+0xc>)
  401450:	6818      	ldr	r0, [r3, #0]
  401452:	4b02      	ldr	r3, [pc, #8]	; (40145c <PWM0_Handler+0x10>)
  401454:	4798      	blx	r3
  401456:	bd08      	pop	{r3, pc}
  401458:	20400078 	.word	0x20400078
  40145c:	0040143d 	.word	0x0040143d

00401460 <PWM1_Handler>:

/**
 * \internal PWM interrupt handler
 */
void PWM1_Handler(void)
{
  401460:	b508      	push	{r3, lr}
	_pwm_interrupt_handler(_pwm1_dev);
  401462:	4b02      	ldr	r3, [pc, #8]	; (40146c <PWM1_Handler+0xc>)
  401464:	6858      	ldr	r0, [r3, #4]
  401466:	4b02      	ldr	r3, [pc, #8]	; (401470 <PWM1_Handler+0x10>)
  401468:	4798      	blx	r3
  40146a:	bd08      	pop	{r3, pc}
  40146c:	20400078 	.word	0x20400078
  401470:	0040143d 	.word	0x0040143d

00401474 <_pwm_init>:
}

int32_t _pwm_init(struct _pwm_device *const device, void *const hw)
{
  401474:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401476:	4606      	mov	r6, r0
	ASSERT(hw);
  401478:	460c      	mov	r4, r1
  40147a:	1c08      	adds	r0, r1, #0
  40147c:	bf18      	it	ne
  40147e:	2001      	movne	r0, #1
  401480:	f44f 72bf 	mov.w	r2, #382	; 0x17e
  401484:	4944      	ldr	r1, [pc, #272]	; (401598 <_pwm_init+0x124>)
  401486:	4b45      	ldr	r3, [pc, #276]	; (40159c <_pwm_init+0x128>)
  401488:	4798      	blx	r3
	int8_t                      i;
	const struct _pwm_cfg *     cfg;
	const struct _pwm_ch_cfg *  ch;
	const struct _pwm_comp_cfg *comp;

	cfg = _pwm_get_cfg(hw);
  40148a:	4620      	mov	r0, r4
  40148c:	4b44      	ldr	r3, [pc, #272]	; (4015a0 <_pwm_init+0x12c>)
  40148e:	4798      	blx	r3
  401490:	4605      	mov	r5, r0

	device->hw = hw;
  401492:	6134      	str	r4, [r6, #16]
	/* Init PMW */
	hri_pwm_write_CLK_reg(hw, cfg->pwm_clk);
  401494:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_pwm_write_CLK_reg(const void *const hw, hri_pwm_clk_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_CLK = data;
  401496:	6023      	str	r3, [r4, #0]
	hri_pwm_write_ELMR_reg(hw, 0, cfg->pwm_elmr0);
  401498:	68c3      	ldr	r3, [r0, #12]
}

static inline void hri_pwm_write_ELMR_reg(const void *const hw, uint8_t index, hri_pwm_elmr_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ELMR[index] = data;
  40149a:	67e3      	str	r3, [r4, #124]	; 0x7c
	hri_pwm_write_ELMR_reg(hw, 1, cfg->pwm_elmr1);
  40149c:	6903      	ldr	r3, [r0, #16]
  40149e:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	hri_pwm_write_FMR_reg(hw, cfg->pwm_fmr);
  4014a2:	6943      	ldr	r3, [r0, #20]
	((Pwm *)hw)->PWM_FMR = data;
  4014a4:	65e3      	str	r3, [r4, #92]	; 0x5c
	hri_pwm_write_FPV1_reg(hw, cfg->pwm_fpv1);
  4014a6:	6983      	ldr	r3, [r0, #24]
	((Pwm *)hw)->PWM_FPV1 = data;
  4014a8:	66a3      	str	r3, [r4, #104]	; 0x68
	hri_pwm_write_FPV2_reg(hw, cfg->pwm_fpv2);
  4014aa:	69c3      	ldr	r3, [r0, #28]
}

static inline void hri_pwm_write_FPV2_reg(const void *const hw, hri_pwm_fpv2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_FPV2 = data;
  4014ac:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	hri_pwm_write_FPE_reg(hw, cfg->pwm_fpe);
  4014b0:	6a03      	ldr	r3, [r0, #32]
	((Pwm *)hw)->PWM_FPE = data;
  4014b2:	66e3      	str	r3, [r4, #108]	; 0x6c
	hri_pwm_write_ETRG1_reg(hw, cfg->pwm_etrg1);
  4014b4:	6a43      	ldr	r3, [r0, #36]	; 0x24
}

static inline void hri_pwm_write_ETRG1_reg(const void *const hw, hri_pwm_etrg1_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG1 = data;
  4014b6:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	hri_pwm_write_ETRG2_reg(hw, cfg->pwm_etrg2);
  4014ba:	6a83      	ldr	r3, [r0, #40]	; 0x28
}

static inline void hri_pwm_write_ETRG2_reg(const void *const hw, hri_pwm_etrg2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG2 = data;
  4014bc:	f8c4 344c 	str.w	r3, [r4, #1100]	; 0x44c

	/* Init Channel */
	for (i = 0; i < cfg->ch_num; i++) {
  4014c0:	2300      	movs	r3, #0
  4014c2:	e019      	b.n	4014f8 <_pwm_init+0x84>
		ch = cfg->ch + i;
  4014c4:	6b2f      	ldr	r7, [r5, #48]	; 0x30
  4014c6:	0118      	lsls	r0, r3, #4
  4014c8:	eb07 0e00 	add.w	lr, r7, r0
		hri_pwm_write_CMR_reg(hw, ch->index, ch->mode);
  4014cc:	5c3a      	ldrb	r2, [r7, r0]
  4014ce:	f8de 1004 	ldr.w	r1, [lr, #4]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CMR = data;
  4014d2:	3210      	adds	r2, #16
  4014d4:	0152      	lsls	r2, r2, #5
  4014d6:	50a1      	str	r1, [r4, r2]
		hri_pwm_write_CDTY_reg(hw, ch->index, ch->duty_cycle);
  4014d8:	5c3a      	ldrb	r2, [r7, r0]
  4014da:	f8de 100c 	ldr.w	r1, [lr, #12]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CDTY = data;
  4014de:	3210      	adds	r2, #16
  4014e0:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  4014e4:	6051      	str	r1, [r2, #4]
		hri_pwm_write_CPRD_reg(hw, ch->index, ch->period);
  4014e6:	5c3a      	ldrb	r2, [r7, r0]
  4014e8:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CPRD = data;
  4014ec:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  4014f0:	f8c2 120c 	str.w	r1, [r2, #524]	; 0x20c
	for (i = 0; i < cfg->ch_num; i++) {
  4014f4:	3301      	adds	r3, #1
  4014f6:	b25b      	sxtb	r3, r3
  4014f8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  4014fa:	4293      	cmp	r3, r2
  4014fc:	d3e2      	bcc.n	4014c4 <_pwm_init+0x50>
  4014fe:	2300      	movs	r3, #0
  401500:	e014      	b.n	40152c <_pwm_init+0xb8>
	}
	/* Init comparison */
	for (i = 0; i < cfg->comp_num; i++) {
		comp = cfg->comp + i;
  401502:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  401504:	eb03 0043 	add.w	r0, r3, r3, lsl #1
  401508:	0082      	lsls	r2, r0, #2
  40150a:	eb01 0e02 	add.w	lr, r1, r2
		hri_pwm_write_CMPM_reg(hw, comp->index, comp->comp_cmpm);
  40150e:	5c88      	ldrb	r0, [r1, r2]
  401510:	f8de 7004 	ldr.w	r7, [lr, #4]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPM = data;
  401514:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  401518:	f8c0 7138 	str.w	r7, [r0, #312]	; 0x138
		hri_pwm_write_CMPV_reg(hw, comp->index, comp->comp_cmpv);
  40151c:	5c8a      	ldrb	r2, [r1, r2]
  40151e:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPV = data;
  401522:	3213      	adds	r2, #19
  401524:	0112      	lsls	r2, r2, #4
  401526:	50a1      	str	r1, [r4, r2]
	for (i = 0; i < cfg->comp_num; i++) {
  401528:	3301      	adds	r3, #1
  40152a:	b25b      	sxtb	r3, r3
  40152c:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  40152e:	4293      	cmp	r3, r2
  401530:	d3e7      	bcc.n	401502 <_pwm_init+0x8e>
	}

	_pwm_init_irq_param(hw, device);
  401532:	4631      	mov	r1, r6
  401534:	4620      	mov	r0, r4
  401536:	4b1b      	ldr	r3, [pc, #108]	; (4015a4 <_pwm_init+0x130>)
  401538:	4798      	blx	r3
	NVIC_DisableIRQ(cfg->irq);
  40153a:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  40153e:	2b00      	cmp	r3, #0
  401540:	db0d      	blt.n	40155e <_pwm_init+0xea>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401542:	095a      	lsrs	r2, r3, #5
  401544:	f003 031f 	and.w	r3, r3, #31
  401548:	2101      	movs	r1, #1
  40154a:	fa01 f303 	lsl.w	r3, r1, r3
  40154e:	3220      	adds	r2, #32
  401550:	4915      	ldr	r1, [pc, #84]	; (4015a8 <_pwm_init+0x134>)
  401552:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  401556:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  40155a:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(cfg->irq);
  40155e:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  401562:	2b00      	cmp	r3, #0
  401564:	db09      	blt.n	40157a <_pwm_init+0x106>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401566:	095a      	lsrs	r2, r3, #5
  401568:	f003 031f 	and.w	r3, r3, #31
  40156c:	2101      	movs	r1, #1
  40156e:	fa01 f303 	lsl.w	r3, r1, r3
  401572:	3260      	adds	r2, #96	; 0x60
  401574:	490c      	ldr	r1, [pc, #48]	; (4015a8 <_pwm_init+0x134>)
  401576:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	NVIC_EnableIRQ(cfg->irq);
  40157a:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  40157e:	2b00      	cmp	r3, #0
  401580:	db08      	blt.n	401594 <_pwm_init+0x120>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401582:	0959      	lsrs	r1, r3, #5
  401584:	f003 031f 	and.w	r3, r3, #31
  401588:	2201      	movs	r2, #1
  40158a:	fa02 f303 	lsl.w	r3, r2, r3
  40158e:	4a06      	ldr	r2, [pc, #24]	; (4015a8 <_pwm_init+0x134>)
  401590:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

	return ERR_NONE;
}
  401594:	2000      	movs	r0, #0
  401596:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401598:	00402374 	.word	0x00402374
  40159c:	00400e61 	.word	0x00400e61
  4015a0:	004013e5 	.word	0x004013e5
  4015a4:	00401415 	.word	0x00401415
  4015a8:	e000e100 	.word	0xe000e100

004015ac <_pwm_enable>:

	hri_pwm_write_DIS_reg(device->hw, PWM_DIS_MASK);
}

void _pwm_enable(struct _pwm_device *const device)
{
  4015ac:	b538      	push	{r3, r4, r5, lr}
	ASSERT(device);
  4015ae:	4604      	mov	r4, r0
  4015b0:	f240 12b5 	movw	r2, #437	; 0x1b5
  4015b4:	490b      	ldr	r1, [pc, #44]	; (4015e4 <_pwm_enable+0x38>)
  4015b6:	3000      	adds	r0, #0
  4015b8:	bf18      	it	ne
  4015ba:	2001      	movne	r0, #1
  4015bc:	4b0a      	ldr	r3, [pc, #40]	; (4015e8 <_pwm_enable+0x3c>)
  4015be:	4798      	blx	r3
	int8_t                 i;
	const struct _pwm_cfg *cfg;

	cfg = _pwm_get_cfg(device->hw);
  4015c0:	6920      	ldr	r0, [r4, #16]
  4015c2:	4b0a      	ldr	r3, [pc, #40]	; (4015ec <_pwm_enable+0x40>)
  4015c4:	4798      	blx	r3

	for (i = 0; i < cfg->ch_num; i++) {
  4015c6:	2300      	movs	r3, #0
  4015c8:	e008      	b.n	4015dc <_pwm_enable+0x30>
		hri_pwm_write_ENA_reg(device->hw, 0x1u << cfg->ch[i].index);
  4015ca:	6921      	ldr	r1, [r4, #16]
  4015cc:	6b05      	ldr	r5, [r0, #48]	; 0x30
  4015ce:	011a      	lsls	r2, r3, #4
  4015d0:	5cad      	ldrb	r5, [r5, r2]
  4015d2:	2201      	movs	r2, #1
  4015d4:	40aa      	lsls	r2, r5
}

static inline void hri_pwm_write_ENA_reg(const void *const hw, hri_pwm_ena_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ENA = data;
  4015d6:	604a      	str	r2, [r1, #4]
	for (i = 0; i < cfg->ch_num; i++) {
  4015d8:	3301      	adds	r3, #1
  4015da:	b25b      	sxtb	r3, r3
  4015dc:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  4015de:	4293      	cmp	r3, r2
  4015e0:	d3f3      	bcc.n	4015ca <_pwm_enable+0x1e>
	}
}
  4015e2:	bd38      	pop	{r3, r4, r5, pc}
  4015e4:	00402374 	.word	0x00402374
  4015e8:	00400e61 	.word	0x00400e61
  4015ec:	004013e5 	.word	0x004013e5

004015f0 <_pwm_is_enabled>:
		hri_pwm_write_CPRDUPD_reg(device->hw, cfg->ch[i].index, period);
	}
}

bool _pwm_is_enabled(const struct _pwm_device *const device)
{
  4015f0:	b510      	push	{r4, lr}
	ASSERT(device);
  4015f2:	4604      	mov	r4, r0
  4015f4:	f44f 72ef 	mov.w	r2, #478	; 0x1de
  4015f8:	4907      	ldr	r1, [pc, #28]	; (401618 <_pwm_is_enabled+0x28>)
  4015fa:	3000      	adds	r0, #0
  4015fc:	bf18      	it	ne
  4015fe:	2001      	movne	r0, #1
  401600:	4b06      	ldr	r3, [pc, #24]	; (40161c <_pwm_is_enabled+0x2c>)
  401602:	4798      	blx	r3
	uint8_t status = hri_pwm_get_SR_reg(device->hw, 0x0F);
  401604:	6923      	ldr	r3, [r4, #16]
	tmp = ((Pwm *)hw)->PWM_SR;
  401606:	68db      	ldr	r3, [r3, #12]
	if (status == 0) {
  401608:	f013 0f0f 	tst.w	r3, #15
  40160c:	d001      	beq.n	401612 <_pwm_is_enabled+0x22>
		return false;
	} else {
		return true;
  40160e:	2001      	movs	r0, #1
	}
}
  401610:	bd10      	pop	{r4, pc}
		return false;
  401612:	2000      	movs	r0, #0
  401614:	bd10      	pop	{r4, pc}
  401616:	bf00      	nop
  401618:	00402374 	.word	0x00402374
  40161c:	00400e61 	.word	0x00400e61

00401620 <_pwm_get_pwm>:
 * \brief Retrieve pwm helper functions
 */
struct _pwm_hpl_interface *_pwm_get_pwm(void)
{
	return NULL;
}
  401620:	2000      	movs	r0, #0
  401622:	4770      	bx	lr

00401624 <_spi_sync_enable>:
}

static inline void hri_spi_write_CR_reg(const void *const hw, hri_spi_cr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_CR = data;
  401624:	2301      	movs	r3, #1
  401626:	6003      	str	r3, [r0, #0]
static int32_t _spi_sync_enable(void *const hw)
{
	hri_spi_write_CR_reg(hw, SPI_CR_SPIEN);

	return ERR_NONE;
}
  401628:	2000      	movs	r0, #0
  40162a:	4770      	bx	lr

0040162c <_spi_get_hardware_index>:
 * \brief Retrieve ordinal number of the given SPI hardware instance
 */
static uint8_t _spi_get_hardware_index(const void *const hw)
{

	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  40162c:	4b04      	ldr	r3, [pc, #16]	; (401640 <_spi_get_hardware_index+0x14>)
  40162e:	4403      	add	r3, r0
  401630:	f3c3 4307 	ubfx	r3, r3, #16, #8

	if (index == 5) {
  401634:	2b05      	cmp	r3, #5
  401636:	d001      	beq.n	40163c <_spi_get_hardware_index+0x10>
		return 1;
	} else {
		return 0;
  401638:	2000      	movs	r0, #0
	}
}
  40163a:	4770      	bx	lr
		return 1;
  40163c:	2001      	movs	r0, #1
  40163e:	4770      	bx	lr
  401640:	bfff8000 	.word	0xbfff8000

00401644 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  401644:	b570      	push	{r4, r5, r6, lr}
  401646:	4606      	mov	r6, r0
  401648:	460c      	mov	r4, r1
	uint8_t n = _spi_get_hardware_index((const void *)hw_addr);
  40164a:	4608      	mov	r0, r1
  40164c:	4b20      	ldr	r3, [pc, #128]	; (4016d0 <_spi_m_sync_init+0x8c>)
  40164e:	4798      	blx	r3
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  401650:	2300      	movs	r3, #0
  401652:	b33b      	cbz	r3, 4016a4 <_spi_m_sync_init+0x60>
	return NULL;
  401654:	2500      	movs	r5, #0
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  401656:	f240 122f 	movw	r2, #303	; 0x12f
  40165a:	491e      	ldr	r1, [pc, #120]	; (4016d4 <_spi_m_sync_init+0x90>)
  40165c:	2e00      	cmp	r6, #0
  40165e:	bf18      	it	ne
  401660:	2c00      	cmpne	r4, #0
  401662:	bf14      	ite	ne
  401664:	2001      	movne	r0, #1
  401666:	2000      	moveq	r0, #0
  401668:	4b1b      	ldr	r3, [pc, #108]	; (4016d8 <_spi_m_sync_init+0x94>)
  40166a:	4798      	blx	r3

	if (regs == NULL) {
  40166c:	b355      	cbz	r5, 4016c4 <_spi_m_sync_init+0x80>
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  40166e:	6923      	ldr	r3, [r4, #16]
		return ERR_INVALID_ARG;
	}

	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  401670:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401674:	d129      	bne.n	4016ca <_spi_m_sync_init+0x86>
	((Spi *)hw)->SPI_CR = data;
  401676:	2380      	movs	r3, #128	; 0x80
  401678:	6023      	str	r3, [r4, #0]
		return ERR_DENIED;
	}
	hri_spi_write_CR_reg(hw, SPI_CR_SWRST);
	dev->prvt = hw;
  40167a:	6034      	str	r4, [r6, #0]
	hri_spi_write_CR_reg(hw, (regs->cr & ~(SPI_CR_SPIEN | SPI_CR_SPIDIS | SPI_CR_SWRST | SPI_CR_LASTXFER)));
  40167c:	686a      	ldr	r2, [r5, #4]
  40167e:	4b17      	ldr	r3, [pc, #92]	; (4016dc <_spi_m_sync_init+0x98>)
  401680:	4013      	ands	r3, r2
  401682:	6023      	str	r3, [r4, #0]
	hri_spi_write_MR_reg(hw, ((regs->mr | SPI_MR_PCS(0x0E) | SPI_MR_MODFDIS) & ~SPI_MR_LLB));
  401684:	68ab      	ldr	r3, [r5, #8]
  401686:	4a16      	ldr	r2, [pc, #88]	; (4016e0 <_spi_m_sync_init+0x9c>)
  401688:	401a      	ands	r2, r3
  40168a:	4b16      	ldr	r3, [pc, #88]	; (4016e4 <_spi_m_sync_init+0xa0>)
  40168c:	4313      	orrs	r3, r2
	((Spi *)hw)->SPI_MR = data;
  40168e:	6063      	str	r3, [r4, #4]
	hri_spi_write_CSR_reg(hw, 0, regs->csr);
  401690:	68eb      	ldr	r3, [r5, #12]
	((Spi *)hw)->SPI_CSR[index] = data;
  401692:	6323      	str	r3, [r4, #48]	; 0x30

	dev->dummy_byte = regs->dummy_byte;
  401694:	8a2b      	ldrh	r3, [r5, #16]
  401696:	80f3      	strh	r3, [r6, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  401698:	68eb      	ldr	r3, [r5, #12]
  40169a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  40169e:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
  4016a0:	2000      	movs	r0, #0
  4016a2:	bd70      	pop	{r4, r5, r6, pc}
		if (spi_regs[i].number == n) {
  4016a4:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  4016a8:	008a      	lsls	r2, r1, #2
  4016aa:	490f      	ldr	r1, [pc, #60]	; (4016e8 <_spi_m_sync_init+0xa4>)
  4016ac:	5c8a      	ldrb	r2, [r1, r2]
  4016ae:	4290      	cmp	r0, r2
  4016b0:	d002      	beq.n	4016b8 <_spi_m_sync_init+0x74>
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  4016b2:	3301      	adds	r3, #1
  4016b4:	b2db      	uxtb	r3, r3
  4016b6:	e7cc      	b.n	401652 <_spi_m_sync_init+0xe>
			return &spi_regs[i];
  4016b8:	eb03 0583 	add.w	r5, r3, r3, lsl #2
  4016bc:	00ab      	lsls	r3, r5, #2
  4016be:	460d      	mov	r5, r1
  4016c0:	441d      	add	r5, r3
  4016c2:	e7c8      	b.n	401656 <_spi_m_sync_init+0x12>
		return ERR_INVALID_ARG;
  4016c4:	f06f 000c 	mvn.w	r0, #12
  4016c8:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
  4016ca:	f06f 0010 	mvn.w	r0, #16
}
  4016ce:	bd70      	pop	{r4, r5, r6, pc}
  4016d0:	0040162d 	.word	0x0040162d
  4016d4:	004023a0 	.word	0x004023a0
  4016d8:	00400e61 	.word	0x00400e61
  4016dc:	feffff7c 	.word	0xfeffff7c
  4016e0:	fff1ff6f 	.word	0xfff1ff6f
  4016e4:	000e0010 	.word	0x000e0010
  4016e8:	0040238c 	.word	0x0040238c

004016ec <_spi_m_sync_enable>:

	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
  4016ec:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  4016ee:	4604      	mov	r4, r0
  4016f0:	b168      	cbz	r0, 40170e <_spi_m_sync_enable+0x22>
  4016f2:	6803      	ldr	r3, [r0, #0]
  4016f4:	b14b      	cbz	r3, 40170a <_spi_m_sync_enable+0x1e>
  4016f6:	2001      	movs	r0, #1
  4016f8:	f240 126d 	movw	r2, #365	; 0x16d
  4016fc:	4905      	ldr	r1, [pc, #20]	; (401714 <_spi_m_sync_enable+0x28>)
  4016fe:	4b06      	ldr	r3, [pc, #24]	; (401718 <_spi_m_sync_enable+0x2c>)
  401700:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
  401702:	6820      	ldr	r0, [r4, #0]
  401704:	4b05      	ldr	r3, [pc, #20]	; (40171c <_spi_m_sync_enable+0x30>)
  401706:	4798      	blx	r3
}
  401708:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
  40170a:	2000      	movs	r0, #0
  40170c:	e7f4      	b.n	4016f8 <_spi_m_sync_enable+0xc>
  40170e:	2000      	movs	r0, #0
  401710:	e7f2      	b.n	4016f8 <_spi_m_sync_enable+0xc>
  401712:	bf00      	nop
  401714:	004023a0 	.word	0x004023a0
  401718:	00400e61 	.word	0x00400e61
  40171c:	00401625 	.word	0x00401625

00401720 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
  401720:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401724:	b086      	sub	sp, #24
  401726:	4607      	mov	r7, r0
  401728:	460d      	mov	r5, r1
	void *                 hw   = dev->prvt;
  40172a:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
  40172c:	680b      	ldr	r3, [r1, #0]
  40172e:	9301      	str	r3, [sp, #4]
  401730:	684b      	ldr	r3, [r1, #4]
  401732:	9302      	str	r3, [sp, #8]
  401734:	2300      	movs	r3, #0
  401736:	9303      	str	r3, [sp, #12]
  401738:	9304      	str	r3, [sp, #16]
  40173a:	7903      	ldrb	r3, [r0, #4]
  40173c:	f88d 3014 	strb.w	r3, [sp, #20]

	ASSERT(dev && hw);
  401740:	1c26      	adds	r6, r4, #0
  401742:	bf18      	it	ne
  401744:	2601      	movne	r6, #1
  401746:	f44f 720b 	mov.w	r2, #556	; 0x22c
  40174a:	4933      	ldr	r1, [pc, #204]	; (401818 <_spi_m_sync_trans+0xf8>)
  40174c:	2800      	cmp	r0, #0
  40174e:	bf0c      	ite	eq
  401750:	2000      	moveq	r0, #0
  401752:	f006 0001 	andne.w	r0, r6, #1
  401756:	4b31      	ldr	r3, [pc, #196]	; (40181c <_spi_m_sync_trans+0xfc>)
  401758:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  40175a:	6923      	ldr	r3, [r4, #16]

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_spi_get_SR_SPIENS_bit(hw)) {
  40175c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401760:	d122      	bne.n	4017a8 <_spi_m_sync_trans+0x88>
		return ERR_NOT_INITIALIZED;
  401762:	f06f 0013 	mvn.w	r0, #19
  401766:	e053      	b.n	401810 <_spi_m_sync_trans+0xf0>
		return false;
  401768:	2300      	movs	r3, #0
  40176a:	e035      	b.n	4017d8 <_spi_m_sync_trans+0xb8>
			data |= (*ctrl->txbuf) << 8;
  40176c:	7850      	ldrb	r0, [r2, #1]
  40176e:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			ctrl->txbuf++;
  401772:	3202      	adds	r2, #2
  401774:	9201      	str	r2, [sp, #4]
	ctrl->txcnt++;
  401776:	3301      	adds	r3, #1
  401778:	9303      	str	r3, [sp, #12]
}

static inline void hri_spi_write_TDR_reg(const void *const hw, hri_spi_tdr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_TDR = data;
  40177a:	60e1      	str	r1, [r4, #12]
	return ((Spi *)hw)->SPI_SR;
  40177c:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ASSERT(hw);
  401780:	f240 221d 	movw	r2, #541	; 0x21d
  401784:	4924      	ldr	r1, [pc, #144]	; (401818 <_spi_m_sync_trans+0xf8>)
  401786:	4630      	mov	r0, r6
  401788:	4b24      	ldr	r3, [pc, #144]	; (40181c <_spi_m_sync_trans+0xfc>)
  40178a:	4798      	blx	r3
	if (SPI_SR_OVRES & iflag) {
  40178c:	f018 0f08 	tst.w	r8, #8
  401790:	d038      	beq.n	401804 <_spi_m_sync_trans+0xe4>
		return ERR_OVERFLOW;
  401792:	f06f 0012 	mvn.w	r0, #18
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
			}
		}
		rc = _spi_err_check(hri_spi_read_SR_reg(hw), hw);
		if (rc < 0) {
  401796:	2800      	cmp	r0, #0
  401798:	db36      	blt.n	401808 <_spi_m_sync_trans+0xe8>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
  40179a:	9803      	ldr	r0, [sp, #12]
  40179c:	68ab      	ldr	r3, [r5, #8]
  40179e:	4298      	cmp	r0, r3
  4017a0:	d302      	bcc.n	4017a8 <_spi_m_sync_trans+0x88>
  4017a2:	9a04      	ldr	r2, [sp, #16]
  4017a4:	4293      	cmp	r3, r2
  4017a6:	d92f      	bls.n	401808 <_spi_m_sync_trans+0xe8>
  4017a8:	6923      	ldr	r3, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_RDRF)) {
  4017aa:	f013 0f01 	tst.w	r3, #1
  4017ae:	d0db      	beq.n	401768 <_spi_m_sync_trans+0x48>
	return (((Spi *)hw)->SPI_RDR & SPI_RDR_RD_Msk) >> SPI_RDR_RD_Pos;
  4017b0:	68a3      	ldr	r3, [r4, #8]
  4017b2:	b29b      	uxth	r3, r3
	if (ctrl->rxbuf) {
  4017b4:	9a02      	ldr	r2, [sp, #8]
  4017b6:	b15a      	cbz	r2, 4017d0 <_spi_m_sync_trans+0xb0>
		*ctrl->rxbuf++ = (uint8_t)data;
  4017b8:	1c51      	adds	r1, r2, #1
  4017ba:	9102      	str	r1, [sp, #8]
  4017bc:	7013      	strb	r3, [r2, #0]
		if (ctrl->char_size > 1) {
  4017be:	f89d 2014 	ldrb.w	r2, [sp, #20]
  4017c2:	2a01      	cmp	r2, #1
  4017c4:	d904      	bls.n	4017d0 <_spi_m_sync_trans+0xb0>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
  4017c6:	460a      	mov	r2, r1
  4017c8:	3101      	adds	r1, #1
  4017ca:	9102      	str	r1, [sp, #8]
  4017cc:	0a1b      	lsrs	r3, r3, #8
  4017ce:	7013      	strb	r3, [r2, #0]
	ctrl->rxcnt++;
  4017d0:	9b04      	ldr	r3, [sp, #16]
  4017d2:	3301      	adds	r3, #1
  4017d4:	9304      	str	r3, [sp, #16]
	return true;
  4017d6:	2301      	movs	r3, #1
		if (!_spi_rx_check_and_receive(hw, &ctrl)) {
  4017d8:	2b00      	cmp	r3, #0
  4017da:	d1cf      	bne.n	40177c <_spi_m_sync_trans+0x5c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
  4017dc:	9b03      	ldr	r3, [sp, #12]
  4017de:	9a04      	ldr	r2, [sp, #16]
  4017e0:	429a      	cmp	r2, r3
  4017e2:	d3cb      	bcc.n	40177c <_spi_m_sync_trans+0x5c>
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
  4017e4:	88f9      	ldrh	r1, [r7, #6]
	return ((Spi *)hw)->SPI_SR;
  4017e6:	6922      	ldr	r2, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_TDRE)) {
  4017e8:	f012 0f02 	tst.w	r2, #2
  4017ec:	d0c6      	beq.n	40177c <_spi_m_sync_trans+0x5c>
	if (ctrl->txbuf) {
  4017ee:	9a01      	ldr	r2, [sp, #4]
  4017f0:	2a00      	cmp	r2, #0
  4017f2:	d0c0      	beq.n	401776 <_spi_m_sync_trans+0x56>
		data = *ctrl->txbuf++;
  4017f4:	1c51      	adds	r1, r2, #1
  4017f6:	9101      	str	r1, [sp, #4]
  4017f8:	7811      	ldrb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
  4017fa:	f89d 0014 	ldrb.w	r0, [sp, #20]
  4017fe:	2801      	cmp	r0, #1
  401800:	d8b4      	bhi.n	40176c <_spi_m_sync_trans+0x4c>
  401802:	e7b8      	b.n	401776 <_spi_m_sync_trans+0x56>
	return ERR_NONE;
  401804:	2000      	movs	r0, #0
  401806:	e7c6      	b.n	401796 <_spi_m_sync_trans+0x76>
	tmp = ((Spi *)hw)->SPI_SR;
  401808:	6923      	ldr	r3, [r4, #16]
	while (!(hri_spi_get_SR_reg(hw, SPI_SR_TXEMPTY))) {
  40180a:	f413 7f00 	tst.w	r3, #512	; 0x200
  40180e:	d0fb      	beq.n	401808 <_spi_m_sync_trans+0xe8>

	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
  401810:	b006      	add	sp, #24
  401812:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401816:	bf00      	nop
  401818:	004023a0 	.word	0x004023a0
  40181c:	00400e61 	.word	0x00400e61

00401820 <_spi_get_spi_m_sync>:
 * \brief Retrieve usart sync helper functions
 */
void *_spi_get_spi_m_sync(void)
{
	return (void *)NULL;
}
  401820:	2000      	movs	r0, #0
  401822:	4770      	bx	lr

00401824 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  401824:	4b03      	ldr	r3, [pc, #12]	; (401834 <_system_time_init+0x10>)
  401826:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  40182a:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  40182c:	2205      	movs	r2, #5
  40182e:	601a      	str	r2, [r3, #0]
  401830:	4770      	bx	lr
  401832:	bf00      	nop
  401834:	e000e010 	.word	0xe000e010

00401838 <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  401838:	b508      	push	{r3, lr}
	_system_time_init(hw);
  40183a:	4b01      	ldr	r3, [pc, #4]	; (401840 <_delay_init+0x8>)
  40183c:	4798      	blx	r3
  40183e:	bd08      	pop	{r3, pc}
  401840:	00401825 	.word	0x00401825

00401844 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
  401844:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
  401846:	e00d      	b.n	401864 <_delay_cycles+0x20>
		SysTick->LOAD = 0xFFFFFF;
  401848:	4b0d      	ldr	r3, [pc, #52]	; (401880 <_delay_cycles+0x3c>)
  40184a:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
  40184e:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
  401850:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  401852:	4b0b      	ldr	r3, [pc, #44]	; (401880 <_delay_cycles+0x3c>)
  401854:	681b      	ldr	r3, [r3, #0]
  401856:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  40185a:	d0fa      	beq.n	401852 <_delay_cycles+0xe>
			;
		buf -= 0xFFFFFF;
  40185c:	f101 417f 	add.w	r1, r1, #4278190080	; 0xff000000
  401860:	3101      	adds	r1, #1
	while (n--) {
  401862:	4610      	mov	r0, r2
  401864:	1e43      	subs	r3, r0, #1
  401866:	b2da      	uxtb	r2, r3
  401868:	2800      	cmp	r0, #0
  40186a:	d1ed      	bne.n	401848 <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
  40186c:	4b04      	ldr	r3, [pc, #16]	; (401880 <_delay_cycles+0x3c>)
  40186e:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
  401870:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  401872:	4b03      	ldr	r3, [pc, #12]	; (401880 <_delay_cycles+0x3c>)
  401874:	681b      	ldr	r3, [r3, #0]
  401876:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  40187a:	d0fa      	beq.n	401872 <_delay_cycles+0x2e>
		;
}
  40187c:	4770      	bx	lr
  40187e:	bf00      	nop
  401880:	e000e010 	.word	0xe000e010

00401884 <get_cfg>:

static struct tc_configuration *get_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
  401884:	2300      	movs	r3, #0
  401886:	b13b      	cbz	r3, 401898 <get_cfg+0x14>
		if (_tcs[i].hw == hw) {
			return &(_tcs[i]);
		}
	}

	return NULL;
  401888:	2000      	movs	r0, #0
  40188a:	4770      	bx	lr
			return &(_tcs[i]);
  40188c:	eb03 04c3 	add.w	r4, r3, r3, lsl #3
  401890:	00a3      	lsls	r3, r4, #2
  401892:	4608      	mov	r0, r1
  401894:	4418      	add	r0, r3
  401896:	e00c      	b.n	4018b2 <get_cfg+0x2e>
{
  401898:	b410      	push	{r4}
		if (_tcs[i].hw == hw) {
  40189a:	eb03 01c3 	add.w	r1, r3, r3, lsl #3
  40189e:	008a      	lsls	r2, r1, #2
  4018a0:	4905      	ldr	r1, [pc, #20]	; (4018b8 <get_cfg+0x34>)
  4018a2:	588a      	ldr	r2, [r1, r2]
  4018a4:	4282      	cmp	r2, r0
  4018a6:	d0f1      	beq.n	40188c <get_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
  4018a8:	3301      	adds	r3, #1
  4018aa:	b2db      	uxtb	r3, r3
  4018ac:	2b00      	cmp	r3, #0
  4018ae:	d0f4      	beq.n	40189a <get_cfg+0x16>
	return NULL;
  4018b0:	2000      	movs	r0, #0
}
  4018b2:	f85d 4b04 	ldr.w	r4, [sp], #4
  4018b6:	4770      	bx	lr
  4018b8:	20400000 	.word	0x20400000

004018bc <_tc_init_irq_param>:
/**
 * \brief Init irq param with the given tc hardware instance
 */
static void _tc_init_irq_param(const void *const hw, void *dev)
{
	if (hw == TC0) {
  4018bc:	4b03      	ldr	r3, [pc, #12]	; (4018cc <_tc_init_irq_param+0x10>)
  4018be:	4298      	cmp	r0, r3
  4018c0:	d000      	beq.n	4018c4 <_tc_init_irq_param+0x8>
  4018c2:	4770      	bx	lr
		_tc0_dev = (struct _timer_device *)dev;
  4018c4:	4b02      	ldr	r3, [pc, #8]	; (4018d0 <_tc_init_irq_param+0x14>)
  4018c6:	6019      	str	r1, [r3, #0]
	}
}
  4018c8:	e7fb      	b.n	4018c2 <_tc_init_irq_param+0x6>
  4018ca:	bf00      	nop
  4018cc:	4000c000 	.word	0x4000c000
  4018d0:	20400098 	.word	0x20400098

004018d4 <tc_interrupt_handler>:
 * \internal TC interrupt handler
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
  4018d4:	b508      	push	{r3, lr}
	void *const hw = device->hw;
  4018d6:	68c3      	ldr	r3, [r0, #12]
	return (((Tc *)hw)->TcChannel[submodule_index].TC_SR & TC_SR_CPBS) > 0;
}

static inline bool hri_tc_get_SR_CPCS_bit(const void *const hw, uint8_t submodule_index)
{
	return (((Tc *)hw)->TcChannel[submodule_index].TC_SR & TC_SR_CPCS) > 0;
  4018d8:	6a1b      	ldr	r3, [r3, #32]

	if (hri_tc_get_SR_CPCS_bit(hw, 0)) {
  4018da:	f013 0f10 	tst.w	r3, #16
  4018de:	d100      	bne.n	4018e2 <tc_interrupt_handler+0xe>
  4018e0:	bd08      	pop	{r3, pc}
		device->timer_cb.period_expired(device);
  4018e2:	6803      	ldr	r3, [r0, #0]
  4018e4:	4798      	blx	r3
	}
}
  4018e6:	e7fb      	b.n	4018e0 <tc_interrupt_handler+0xc>

004018e8 <_timer_init>:
{
  4018e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4018ea:	4607      	mov	r7, r0
  4018ec:	460c      	mov	r4, r1
	struct tc_configuration *cfg     = get_cfg(hw);
  4018ee:	4608      	mov	r0, r1
  4018f0:	4b27      	ldr	r3, [pc, #156]	; (401990 <_timer_init+0xa8>)
  4018f2:	4798      	blx	r3
  4018f4:	4605      	mov	r5, r0
	uint32_t                 ch_mode = cfg->channel_mode;
  4018f6:	6886      	ldr	r6, [r0, #8]
	device->hw = hw;
  4018f8:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
  4018fa:	2291      	movs	r2, #145	; 0x91
  4018fc:	4925      	ldr	r1, [pc, #148]	; (401994 <_timer_init+0xac>)
  4018fe:	2001      	movs	r0, #1
  401900:	4b25      	ldr	r3, [pc, #148]	; (401998 <_timer_init+0xb0>)
  401902:	4798      	blx	r3
	if (ch_mode & TC_CMR_WAVE) {
  401904:	f416 4f00 	tst.w	r6, #32768	; 0x8000
  401908:	d001      	beq.n	40190e <_timer_init+0x26>
		ch_mode |= (0x02 << 13) | (0x01 << 16) | (0x02 << 18);
  40190a:	f446 2614 	orr.w	r6, r6, #606208	; 0x94000
}

static inline void hri_tc_write_CMR_reg(const void *const hw, uint8_t submodule_index, hri_tc_cmr_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TcChannel[submodule_index].TC_CMR = data;
  40190e:	6066      	str	r6, [r4, #4]
	hri_tc_write_RA_reg(hw, 0, cfg->ra);
  401910:	696b      	ldr	r3, [r5, #20]
}

static inline void hri_tc_write_RA_reg(const void *const hw, uint8_t submodule_index, hri_tc_ra_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TcChannel[submodule_index].TC_RA = data;
  401912:	6163      	str	r3, [r4, #20]
	hri_tc_write_RB_reg(hw, 0, cfg->rb);
  401914:	69ab      	ldr	r3, [r5, #24]
}

static inline void hri_tc_write_RB_reg(const void *const hw, uint8_t submodule_index, hri_tc_rb_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TcChannel[submodule_index].TC_RB = data;
  401916:	61a3      	str	r3, [r4, #24]
	hri_tc_write_EMR_reg(hw, 0, cfg->ext_mode);
  401918:	68eb      	ldr	r3, [r5, #12]
}

static inline void hri_tc_write_EMR_reg(const void *const hw, uint8_t submodule_index, hri_tc_emr_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TcChannel[submodule_index].TC_EMR = data;
  40191a:	6323      	str	r3, [r4, #48]	; 0x30
	hri_tc_write_RC_reg(hw, 0, cfg->rc);
  40191c:	69eb      	ldr	r3, [r5, #28]
	((Tc *)hw)->TcChannel[submodule_index].TC_RC = data;
  40191e:	61e3      	str	r3, [r4, #28]
	((Tc *)hw)->TcChannel[submodule_index].TC_IER = mask;
  401920:	2310      	movs	r3, #16
  401922:	6263      	str	r3, [r4, #36]	; 0x24
	hri_tc_write_FMR_reg(hw, cfg->fmr);
  401924:	692b      	ldr	r3, [r5, #16]
}

static inline void hri_tc_write_FMR_reg(const void *const hw, hri_tc_fmr_reg_t data)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->TC_FMR = data;
  401926:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
	_tc_init_irq_param(hw, device);
  40192a:	4639      	mov	r1, r7
  40192c:	4620      	mov	r0, r4
  40192e:	4b1b      	ldr	r3, [pc, #108]	; (40199c <_timer_init+0xb4>)
  401930:	4798      	blx	r3
	NVIC_DisableIRQ(cfg->irq);
  401932:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  401936:	2b00      	cmp	r3, #0
  401938:	db0d      	blt.n	401956 <_timer_init+0x6e>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40193a:	095a      	lsrs	r2, r3, #5
  40193c:	f003 031f 	and.w	r3, r3, #31
  401940:	2101      	movs	r1, #1
  401942:	fa01 f303 	lsl.w	r3, r1, r3
  401946:	3220      	adds	r2, #32
  401948:	4915      	ldr	r1, [pc, #84]	; (4019a0 <_timer_init+0xb8>)
  40194a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  40194e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401952:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(cfg->irq);
  401956:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  40195a:	2b00      	cmp	r3, #0
  40195c:	db09      	blt.n	401972 <_timer_init+0x8a>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40195e:	095a      	lsrs	r2, r3, #5
  401960:	f003 031f 	and.w	r3, r3, #31
  401964:	2101      	movs	r1, #1
  401966:	fa01 f303 	lsl.w	r3, r1, r3
  40196a:	3260      	adds	r2, #96	; 0x60
  40196c:	490c      	ldr	r1, [pc, #48]	; (4019a0 <_timer_init+0xb8>)
  40196e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	NVIC_EnableIRQ(cfg->irq);
  401972:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  401976:	2b00      	cmp	r3, #0
  401978:	db08      	blt.n	40198c <_timer_init+0xa4>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40197a:	0959      	lsrs	r1, r3, #5
  40197c:	f003 031f 	and.w	r3, r3, #31
  401980:	2201      	movs	r2, #1
  401982:	fa02 f303 	lsl.w	r3, r2, r3
  401986:	4a06      	ldr	r2, [pc, #24]	; (4019a0 <_timer_init+0xb8>)
  401988:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
}
  40198c:	2000      	movs	r0, #0
  40198e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401990:	00401885 	.word	0x00401885
  401994:	004023b8 	.word	0x004023b8
  401998:	00400e61 	.word	0x00400e61
  40199c:	004018bd 	.word	0x004018bd
  4019a0:	e000e100 	.word	0xe000e100

004019a4 <_timer_start>:
	hri_tc_write_CCR_reg(device->hw, 0, TC_CCR_CLKEN | TC_CCR_SWTRG);
  4019a4:	68c3      	ldr	r3, [r0, #12]
	((Tc *)hw)->TcChannel[submodule_index].TC_CCR = data;
  4019a6:	2205      	movs	r2, #5
  4019a8:	601a      	str	r2, [r3, #0]
  4019aa:	4770      	bx	lr

004019ac <_timer_is_started>:
	return hri_tc_get_SR_CLKSTA_bit(device->hw, 0);
  4019ac:	68c3      	ldr	r3, [r0, #12]
	return (((Tc *)hw)->TcChannel[submodule_index].TC_SR & TC_SR_CLKSTA) > 0;
  4019ae:	6a18      	ldr	r0, [r3, #32]
}
  4019b0:	f3c0 4000 	ubfx	r0, r0, #16, #1
  4019b4:	4770      	bx	lr
	...

004019b8 <_timer_set_irq>:
{
  4019b8:	b508      	push	{r3, lr}
	struct tc_configuration *cfg = get_cfg(device->hw);
  4019ba:	68c0      	ldr	r0, [r0, #12]
  4019bc:	4b02      	ldr	r3, [pc, #8]	; (4019c8 <_timer_set_irq+0x10>)
  4019be:	4798      	blx	r3
	_irq_set((IRQn_Type)(cfg->irq));
  4019c0:	7900      	ldrb	r0, [r0, #4]
  4019c2:	4b02      	ldr	r3, [pc, #8]	; (4019cc <_timer_set_irq+0x14>)
  4019c4:	4798      	blx	r3
  4019c6:	bd08      	pop	{r3, pc}
  4019c8:	00401885 	.word	0x00401885
  4019cc:	00400fe1 	.word	0x00400fe1

004019d0 <_tc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_tc_get_timer(void)
{
	return NULL;
}
  4019d0:	2000      	movs	r0, #0
  4019d2:	4770      	bx	lr

004019d4 <TC0_Handler>:

/**
 * \brief TC interrupt handler
 */
void TC0_Handler(void)
{
  4019d4:	b508      	push	{r3, lr}
	tc_interrupt_handler(_tc0_dev);
  4019d6:	4b02      	ldr	r3, [pc, #8]	; (4019e0 <TC0_Handler+0xc>)
  4019d8:	6818      	ldr	r0, [r3, #0]
  4019da:	4b02      	ldr	r3, [pc, #8]	; (4019e4 <TC0_Handler+0x10>)
  4019dc:	4798      	blx	r3
  4019de:	bd08      	pop	{r3, pc}
  4019e0:	20400098 	.word	0x20400098
  4019e4:	004018d5 	.word	0x004018d5

004019e8 <_get_i2cm_sync_cfg>:
 */
static const struct _i2cm_sync_cfg *_get_i2cm_sync_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  4019e8:	2300      	movs	r3, #0
  4019ea:	b13b      	cbz	r3, 4019fc <_get_i2cm_sync_cfg+0x14>
		if (_i2cm_sync_cfgs[i].hw == hw) {
			return &(_i2cm_sync_cfgs[i]);
		}
	}
	return NULL;
  4019ec:	2000      	movs	r0, #0
  4019ee:	4770      	bx	lr
			return &(_i2cm_sync_cfgs[i]);
  4019f0:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  4019f4:	00e3      	lsls	r3, r4, #3
  4019f6:	4608      	mov	r0, r1
  4019f8:	4418      	add	r0, r3
  4019fa:	e00c      	b.n	401a16 <_get_i2cm_sync_cfg+0x2e>
{
  4019fc:	b410      	push	{r4}
		if (_i2cm_sync_cfgs[i].hw == hw) {
  4019fe:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  401a02:	00ca      	lsls	r2, r1, #3
  401a04:	4905      	ldr	r1, [pc, #20]	; (401a1c <_get_i2cm_sync_cfg+0x34>)
  401a06:	588a      	ldr	r2, [r1, r2]
  401a08:	4282      	cmp	r2, r0
  401a0a:	d0f1      	beq.n	4019f0 <_get_i2cm_sync_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  401a0c:	3301      	adds	r3, #1
  401a0e:	b2db      	uxtb	r3, r3
  401a10:	2b00      	cmp	r3, #0
  401a12:	d0f4      	beq.n	4019fe <_get_i2cm_sync_cfg+0x16>
	return NULL;
  401a14:	2000      	movs	r0, #0
}
  401a16:	f85d 4b04 	ldr.w	r4, [sp], #4
  401a1a:	4770      	bx	lr
  401a1c:	004023cc 	.word	0x004023cc

00401a20 <_i2c_m_sync_init>:

int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const dev, void *const hw)
{
  401a20:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && hw);
  401a22:	4604      	mov	r4, r0
  401a24:	460d      	mov	r5, r1
  401a26:	2800      	cmp	r0, #0
  401a28:	bf18      	it	ne
  401a2a:	2900      	cmpne	r1, #0
  401a2c:	bf14      	ite	ne
  401a2e:	2001      	movne	r0, #1
  401a30:	2000      	moveq	r0, #0
  401a32:	2278      	movs	r2, #120	; 0x78
  401a34:	4909      	ldr	r1, [pc, #36]	; (401a5c <_i2c_m_sync_init+0x3c>)
  401a36:	4b0a      	ldr	r3, [pc, #40]	; (401a60 <_i2c_m_sync_init+0x40>)
  401a38:	4798      	blx	r3

	const struct _i2cm_sync_cfg *cfg;

	dev->hw = hw;
  401a3a:	6125      	str	r5, [r4, #16]
	cfg     = _get_i2cm_sync_cfg(dev->hw);
  401a3c:	4628      	mov	r0, r5
  401a3e:	4b09      	ldr	r3, [pc, #36]	; (401a64 <_i2c_m_sync_init+0x44>)
  401a40:	4798      	blx	r3

	// hri_twihs_write_CR_reg(hw, TWIHS_CR_SWRST);
	// hri_twihs_read_RHR_reg(hw);
	hri_twihs_write_CR_reg(dev->hw, cfg->ctrl);
  401a42:	6843      	ldr	r3, [r0, #4]
}

static inline void hri_twihs_write_CR_reg(const void *const hw, hri_twihs_cr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_CR = data;
  401a44:	602b      	str	r3, [r5, #0]
	hri_twihs_write_SMBTR_reg(dev->hw, cfg->smbtr);
  401a46:	6923      	ldr	r3, [r4, #16]
  401a48:	6882      	ldr	r2, [r0, #8]
	((Twihs *)hw)->TWIHS_SMBTR = data;
  401a4a:	639a      	str	r2, [r3, #56]	; 0x38
	hri_twihs_write_FILTR_reg(dev->hw, cfg->filtr);
  401a4c:	6923      	ldr	r3, [r4, #16]
  401a4e:	68c2      	ldr	r2, [r0, #12]
	((Twihs *)hw)->TWIHS_FILTR = data;
  401a50:	645a      	str	r2, [r3, #68]	; 0x44
	hri_twihs_write_CWGR_reg(dev->hw, cfg->cwgr);
  401a52:	6923      	ldr	r3, [r4, #16]
  401a54:	6902      	ldr	r2, [r0, #16]
	((Twihs *)hw)->TWIHS_CWGR = data;
  401a56:	611a      	str	r2, [r3, #16]

	return ERR_NONE;
}
  401a58:	2000      	movs	r0, #0
  401a5a:	bd38      	pop	{r3, r4, r5, pc}
  401a5c:	004023e4 	.word	0x004023e4
  401a60:	00400e61 	.word	0x00400e61
  401a64:	004019e9 	.word	0x004019e9

00401a68 <_i2c_m_sync_transfer>:

	return ERR_NONE;
}

int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
  401a68:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && msg);
  401a6a:	4604      	mov	r4, r0
  401a6c:	460d      	mov	r5, r1
  401a6e:	2800      	cmp	r0, #0
  401a70:	bf18      	it	ne
  401a72:	2900      	cmpne	r1, #0
  401a74:	bf14      	ite	ne
  401a76:	2001      	movne	r0, #1
  401a78:	2000      	moveq	r0, #0
  401a7a:	22ba      	movs	r2, #186	; 0xba
  401a7c:	4952      	ldr	r1, [pc, #328]	; (401bc8 <_i2c_m_sync_transfer+0x160>)
  401a7e:	4b53      	ldr	r3, [pc, #332]	; (401bcc <_i2c_m_sync_transfer+0x164>)
  401a80:	4798      	blx	r3

	if (dev->service.msg.flags & I2C_M_BUSY) {
  401a82:	8863      	ldrh	r3, [r4, #2]
  401a84:	f413 7f80 	tst.w	r3, #256	; 0x100
  401a88:	f040 809a 	bne.w	401bc0 <_i2c_m_sync_transfer+0x158>
		return I2C_ERR_BUSY;
	}

	if (msg->flags & I2C_M_RD) {
  401a8c:	886b      	ldrh	r3, [r5, #2]
  401a8e:	f013 0f01 	tst.w	r3, #1
  401a92:	d118      	bne.n	401ac6 <_i2c_m_sync_transfer+0x5e>
{
	uint32_t i;
	uint32_t sr;
	int      ret = ERR_NONE;

	msg->flags |= I2C_M_BUSY;
  401a94:	886b      	ldrh	r3, [r5, #2]
  401a96:	b29b      	uxth	r3, r3
  401a98:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401a9c:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401a9e:	882b      	ldrh	r3, [r5, #0]
  401aa0:	f413 6f80 	tst.w	r3, #1024	; 0x400
  401aa4:	d05f      	beq.n	401b66 <_i2c_m_sync_transfer+0xfe>
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1));
  401aa6:	6922      	ldr	r2, [r4, #16]
  401aa8:	0a1b      	lsrs	r3, r3, #8
  401aaa:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401aae:	041b      	lsls	r3, r3, #16
  401ab0:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401ab4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Twihs *)hw)->TWIHS_MMR = data;
  401ab8:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  401aba:	6923      	ldr	r3, [r4, #16]
  401abc:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401abe:	60da      	str	r2, [r3, #12]
	for (i = 0; i < msg->len; i++) {
		/* Wait for data is transferred from TWIHS_THR or if NACK is detected */
		do {
			sr = hri_twihs_read_SR_reg(dev->hw);
			if (sr & TWIHS_SR_NACK) {
				ret = I2C_NACK;
  401ac0:	2000      	movs	r0, #0
  401ac2:	4601      	mov	r1, r0
  401ac4:	e05c      	b.n	401b80 <_i2c_m_sync_transfer+0x118>

static inline int32_t _i2c_m_sync_read(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
	uint32_t i;

	msg->flags |= I2C_M_BUSY;
  401ac6:	886b      	ldrh	r3, [r5, #2]
  401ac8:	b29b      	uxth	r3, r3
  401aca:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401ace:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401ad0:	882b      	ldrh	r3, [r5, #0]
  401ad2:	f413 6f80 	tst.w	r3, #1024	; 0x400
  401ad6:	d022      	beq.n	401b1e <_i2c_m_sync_transfer+0xb6>
		hri_twihs_write_MMR_reg(dev->hw,
  401ad8:	6922      	ldr	r2, [r4, #16]
		                        TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1) | TWIHS_MMR_MREAD);
  401ada:	0a1b      	lsrs	r3, r3, #8
  401adc:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401ae0:	041b      	lsls	r3, r3, #16
  401ae2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401ae6:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
	((Twihs *)hw)->TWIHS_MMR = data;
  401aea:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  401aec:	6923      	ldr	r3, [r4, #16]
  401aee:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401af0:	60da      	str	r2, [r3, #12]
	} else {
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
	}
	/* In single data byte master read, the START and STOP must both be set */
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  401af2:	6923      	ldr	r3, [r4, #16]
  401af4:	686a      	ldr	r2, [r5, #4]
  401af6:	2a01      	cmp	r2, #1
  401af8:	d019      	beq.n	401b2e <_i2c_m_sync_transfer+0xc6>
  401afa:	2201      	movs	r2, #1
	((Twihs *)hw)->TWIHS_CR = data;
  401afc:	601a      	str	r2, [r3, #0]

	for (i = 0; i < msg->len; i++) {
  401afe:	2100      	movs	r1, #0
  401b00:	686b      	ldr	r3, [r5, #4]
  401b02:	4299      	cmp	r1, r3
  401b04:	d222      	bcs.n	401b4c <_i2c_m_sync_transfer+0xe4>
		/* Wait for a byte has been received in TWIHS_RHR since last read */
		while (!hri_twihs_get_SR_RXRDY_bit(dev->hw)) {
  401b06:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_RXRDY) > 0;
  401b08:	6a1a      	ldr	r2, [r3, #32]
  401b0a:	f012 0f02 	tst.w	r2, #2
  401b0e:	d110      	bne.n	401b32 <_i2c_m_sync_transfer+0xca>
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_NACK) > 0;
  401b10:	6a1b      	ldr	r3, [r3, #32]
			/* Check whether slave acknowledge received after the address byte */
			if (hri_twihs_get_SR_NACK_bit(dev->hw))
  401b12:	f413 7f80 	tst.w	r3, #256	; 0x100
  401b16:	d0f6      	beq.n	401b06 <_i2c_m_sync_transfer+0x9e>
				return I2C_NACK;
  401b18:	f06f 0001 	mvn.w	r0, #1
		return _i2c_m_sync_read(dev, msg);
  401b1c:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
  401b1e:	6922      	ldr	r2, [r4, #16]
  401b20:	041b      	lsls	r3, r3, #16
  401b22:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401b26:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Twihs *)hw)->TWIHS_MMR = data;
  401b2a:	6053      	str	r3, [r2, #4]
  401b2c:	e7e1      	b.n	401af2 <_i2c_m_sync_transfer+0x8a>
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  401b2e:	2203      	movs	r2, #3
  401b30:	e7e4      	b.n	401afc <_i2c_m_sync_transfer+0x94>
		};

		msg->buffer[i] = hri_twihs_read_RHR_reg(dev->hw);
  401b32:	68aa      	ldr	r2, [r5, #8]
	return ((Twihs *)hw)->TWIHS_RHR;
  401b34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401b36:	5453      	strb	r3, [r2, r1]
		/* In multiple data bytes master read, the STOP must be set after the
		 * last data received but one */
		if (i == (msg->len - 2)) {
  401b38:	686b      	ldr	r3, [r5, #4]
  401b3a:	3b02      	subs	r3, #2
  401b3c:	4299      	cmp	r1, r3
  401b3e:	d001      	beq.n	401b44 <_i2c_m_sync_transfer+0xdc>
	for (i = 0; i < msg->len; i++) {
  401b40:	3101      	adds	r1, #1
  401b42:	e7dd      	b.n	401b00 <_i2c_m_sync_transfer+0x98>
			hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401b44:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401b46:	2202      	movs	r2, #2
  401b48:	601a      	str	r2, [r3, #0]
  401b4a:	e7f9      	b.n	401b40 <_i2c_m_sync_transfer+0xd8>
		}
	}

	while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401b4c:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  401b4e:	6a1b      	ldr	r3, [r3, #32]
  401b50:	f013 0f01 	tst.w	r3, #1
  401b54:	d0fa      	beq.n	401b4c <_i2c_m_sync_transfer+0xe4>
	};
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401b56:	8863      	ldrh	r3, [r4, #2]
  401b58:	b29b      	uxth	r3, r3
  401b5a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401b5e:	b29b      	uxth	r3, r3
  401b60:	8063      	strh	r3, [r4, #2]

	return ERR_NONE;
  401b62:	2000      	movs	r0, #0
  401b64:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr));
  401b66:	6922      	ldr	r2, [r4, #16]
  401b68:	041b      	lsls	r3, r3, #16
  401b6a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
	((Twihs *)hw)->TWIHS_MMR = data;
  401b6e:	6053      	str	r3, [r2, #4]
  401b70:	e7a6      	b.n	401ac0 <_i2c_m_sync_transfer+0x58>
				ret = I2C_NACK;
  401b72:	f06f 0001 	mvn.w	r0, #1
		if (ret != ERR_NONE)
  401b76:	b978      	cbnz	r0, 401b98 <_i2c_m_sync_transfer+0x130>
		hri_twihs_write_THR_reg(dev->hw, msg->buffer[i]);
  401b78:	68ab      	ldr	r3, [r5, #8]
  401b7a:	5c5b      	ldrb	r3, [r3, r1]
}

static inline void hri_twihs_write_THR_reg(const void *const hw, hri_twihs_thr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_THR = data;
  401b7c:	6353      	str	r3, [r2, #52]	; 0x34
	for (i = 0; i < msg->len; i++) {
  401b7e:	3101      	adds	r1, #1
  401b80:	686b      	ldr	r3, [r5, #4]
  401b82:	4299      	cmp	r1, r3
  401b84:	d208      	bcs.n	401b98 <_i2c_m_sync_transfer+0x130>
			sr = hri_twihs_read_SR_reg(dev->hw);
  401b86:	6922      	ldr	r2, [r4, #16]
	return ((Twihs *)hw)->TWIHS_SR;
  401b88:	6a13      	ldr	r3, [r2, #32]
			if (sr & TWIHS_SR_NACK) {
  401b8a:	f413 7f80 	tst.w	r3, #256	; 0x100
  401b8e:	d1f0      	bne.n	401b72 <_i2c_m_sync_transfer+0x10a>
		} while (!(sr & TWIHS_SR_TXRDY));
  401b90:	f013 0f04 	tst.w	r3, #4
  401b94:	d0f7      	beq.n	401b86 <_i2c_m_sync_transfer+0x11e>
  401b96:	e7ee      	b.n	401b76 <_i2c_m_sync_transfer+0x10e>
	if (msg->flags & I2C_M_STOP) {
  401b98:	886b      	ldrh	r3, [r5, #2]
  401b9a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401b9e:	d106      	bne.n	401bae <_i2c_m_sync_transfer+0x146>
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401ba0:	8863      	ldrh	r3, [r4, #2]
  401ba2:	b29b      	uxth	r3, r3
  401ba4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401ba8:	b29b      	uxth	r3, r3
  401baa:	8063      	strh	r3, [r4, #2]
		return _i2c_m_sync_write(dev, msg);
  401bac:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401bae:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401bb0:	2202      	movs	r2, #2
  401bb2:	601a      	str	r2, [r3, #0]
		while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401bb4:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  401bb6:	6a1b      	ldr	r3, [r3, #32]
  401bb8:	f013 0f01 	tst.w	r3, #1
  401bbc:	d0fa      	beq.n	401bb4 <_i2c_m_sync_transfer+0x14c>
  401bbe:	e7ef      	b.n	401ba0 <_i2c_m_sync_transfer+0x138>
		return I2C_ERR_BUSY;
  401bc0:	f06f 0005 	mvn.w	r0, #5
}
  401bc4:	bd38      	pop	{r3, r4, r5, pc}
  401bc6:	bf00      	nop
  401bc8:	004023e4 	.word	0x004023e4
  401bcc:	00400e61 	.word	0x00400e61

00401bd0 <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
  401bd0:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
  401bd2:	4604      	mov	r4, r0
  401bd4:	b168      	cbz	r0, 401bf2 <_wdt_init+0x22>
  401bd6:	6803      	ldr	r3, [r0, #0]
  401bd8:	b14b      	cbz	r3, 401bee <_wdt_init+0x1e>
  401bda:	2001      	movs	r0, #1
  401bdc:	2233      	movs	r2, #51	; 0x33
  401bde:	4906      	ldr	r1, [pc, #24]	; (401bf8 <_wdt_init+0x28>)
  401be0:	4b06      	ldr	r3, [pc, #24]	; (401bfc <_wdt_init+0x2c>)
  401be2:	4798      	blx	r3

	hri_wdt_write_MR_reg(dev->hw, (hri_wdt_mr_reg_t)WDT_CONFIGURATION);
  401be4:	6823      	ldr	r3, [r4, #0]
}

static inline void hri_wdt_write_MR_reg(const void *const hw, hri_wdt_mr_reg_t data)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR = data;
  401be6:	4a06      	ldr	r2, [pc, #24]	; (401c00 <_wdt_init+0x30>)
  401be8:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
}
  401bea:	2000      	movs	r0, #0
  401bec:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->hw);
  401bee:	2000      	movs	r0, #0
  401bf0:	e7f4      	b.n	401bdc <_wdt_init+0xc>
  401bf2:	2000      	movs	r0, #0
  401bf4:	e7f2      	b.n	401bdc <_wdt_init+0xc>
  401bf6:	bf00      	nop
  401bf8:	00402400 	.word	0x00402400
  401bfc:	00400e61 	.word	0x00400e61
  401c00:	3fffafff 	.word	0x3fffafff

00401c04 <timer_task_cb>:
static struct timer_task task_0;

int x=0;

static void timer_task_cb(const struct timer_task *const timer_task){
	x++;
  401c04:	4a02      	ldr	r2, [pc, #8]	; (401c10 <timer_task_cb+0xc>)
  401c06:	6813      	ldr	r3, [r2, #0]
  401c08:	3301      	adds	r3, #1
  401c0a:	6013      	str	r3, [r2, #0]
  401c0c:	4770      	bx	lr
  401c0e:	bf00      	nop
  401c10:	2040009c 	.word	0x2040009c

00401c14 <main>:
	



int main(void)
{
  401c14:	b510      	push	{r4, lr}
  401c16:	b08a      	sub	sp, #40	; 0x28
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  401c18:	4b39      	ldr	r3, [pc, #228]	; (401d00 <main+0xec>)
  401c1a:	4798      	blx	r3
	
	task_0.interval = 1;
  401c1c:	4939      	ldr	r1, [pc, #228]	; (401d04 <main+0xf0>)
  401c1e:	2301      	movs	r3, #1
  401c20:	60cb      	str	r3, [r1, #12]
	task_0.cb = timer_task_cb;
  401c22:	4a39      	ldr	r2, [pc, #228]	; (401d08 <main+0xf4>)
  401c24:	610a      	str	r2, [r1, #16]
	task_0.mode = TIMER_TASK_REPEAT;
  401c26:	750b      	strb	r3, [r1, #20]
	
	timer_add_task(&TIMER_0, &task_0);
  401c28:	4c38      	ldr	r4, [pc, #224]	; (401d0c <main+0xf8>)
  401c2a:	3104      	adds	r1, #4
  401c2c:	4620      	mov	r0, r4
  401c2e:	4b38      	ldr	r3, [pc, #224]	; (401d10 <main+0xfc>)
  401c30:	4798      	blx	r3
	timer_start(&TIMER_0);
  401c32:	4620      	mov	r0, r4
  401c34:	4b37      	ldr	r3, [pc, #220]	; (401d14 <main+0x100>)
  401c36:	4798      	blx	r3
	/*Initialize the IMU, making sure to pass in the address of the start of the float array that will hold the quaternion coefficients*/
	
	//init_IMU(&imu_vector_buffer[0]);
	
	uint8_t robot_ID;
	NPP_init(&robot_ID);
  401c38:	f10d 0027 	add.w	r0, sp, #39	; 0x27
  401c3c:	4b36      	ldr	r3, [pc, #216]	; (401d18 <main+0x104>)
  401c3e:	4798      	blx	r3
	
	gpio_set_pin_level(LED0, robot_ID & 0b0001);
  401c40:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	void *const hw = port_to_reg(port);
	if (level) {
  401c44:	f013 0f01 	tst.w	r3, #1
  401c48:	d02f      	beq.n	401caa <main+0x96>
	((Pio *)hw)->PIO_SODR = mask;
  401c4a:	2180      	movs	r1, #128	; 0x80
  401c4c:	4a33      	ldr	r2, [pc, #204]	; (401d1c <main+0x108>)
  401c4e:	6311      	str	r1, [r2, #48]	; 0x30
  401c50:	f013 0f02 	tst.w	r3, #2
  401c54:	d02d      	beq.n	401cb2 <main+0x9e>
  401c56:	f44f 7180 	mov.w	r1, #256	; 0x100
  401c5a:	4a30      	ldr	r2, [pc, #192]	; (401d1c <main+0x108>)
  401c5c:	6311      	str	r1, [r2, #48]	; 0x30
  401c5e:	f013 0f04 	tst.w	r3, #4
  401c62:	d02b      	beq.n	401cbc <main+0xa8>
  401c64:	f44f 7100 	mov.w	r1, #512	; 0x200
  401c68:	4a2c      	ldr	r2, [pc, #176]	; (401d1c <main+0x108>)
  401c6a:	6311      	str	r1, [r2, #48]	; 0x30
  401c6c:	f013 0f08 	tst.w	r3, #8
  401c70:	d029      	beq.n	401cc6 <main+0xb2>
  401c72:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401c76:	4b29      	ldr	r3, [pc, #164]	; (401d1c <main+0x108>)
  401c78:	631a      	str	r2, [r3, #48]	; 0x30
	gpio_set_pin_level(LED1, robot_ID & 0b0010);
	gpio_set_pin_level(LED2, robot_ID & 0b0100);
	gpio_set_pin_level(LED3, robot_ID & 0b1000);
	
	uint8_t data_store[32];
	memset(&data_store[0], 0, sizeof(uint8_t)*32);
  401c7a:	2220      	movs	r2, #32
  401c7c:	2100      	movs	r1, #0
  401c7e:	a801      	add	r0, sp, #4
  401c80:	4b27      	ldr	r3, [pc, #156]	; (401d20 <main+0x10c>)
  401c82:	4798      	blx	r3
	nRF24_init(data_store);
  401c84:	a801      	add	r0, sp, #4
  401c86:	4b27      	ldr	r3, [pc, #156]	; (401d24 <main+0x110>)
  401c88:	4798      	blx	r3
	delay_us(500); //Should be 200 us, setting higher for testing
  401c8a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  401c8e:	4b26      	ldr	r3, [pc, #152]	; (401d28 <main+0x114>)
  401c90:	4798      	blx	r3
	nRF24_enter_receive();
  401c92:	4b26      	ldr	r3, [pc, #152]	; (401d2c <main+0x118>)
  401c94:	4798      	blx	r3
	pwm_enable(&PWM_0);
  401c96:	4826      	ldr	r0, [pc, #152]	; (401d30 <main+0x11c>)
  401c98:	4c26      	ldr	r4, [pc, #152]	; (401d34 <main+0x120>)
  401c9a:	47a0      	blx	r4
	pwm_enable(&PWM_1);
  401c9c:	4826      	ldr	r0, [pc, #152]	; (401d38 <main+0x124>)
  401c9e:	47a0      	blx	r4
	set_pwm_motor_1(&(PWM_0.device), 878);
	set_pwm_motor_2(&(PWM_0.device), 878);
	set_pwm_motor_3(&(PWM_0.device), 878);
	set_pwm_dribbler_motor(&(PWM_1.device), 878);
	*/
	adc_sync_enable_channel(&ADC_0, 0);
  401ca0:	2100      	movs	r1, #0
  401ca2:	4826      	ldr	r0, [pc, #152]	; (401d3c <main+0x128>)
  401ca4:	4b26      	ldr	r3, [pc, #152]	; (401d40 <main+0x12c>)
  401ca6:	4798      	blx	r3
  401ca8:	e01f      	b.n	401cea <main+0xd6>
	((Pio *)hw)->PIO_CODR = mask;
  401caa:	2180      	movs	r1, #128	; 0x80
  401cac:	4a1b      	ldr	r2, [pc, #108]	; (401d1c <main+0x108>)
  401cae:	6351      	str	r1, [r2, #52]	; 0x34
  401cb0:	e7ce      	b.n	401c50 <main+0x3c>
  401cb2:	f44f 7180 	mov.w	r1, #256	; 0x100
  401cb6:	4a19      	ldr	r2, [pc, #100]	; (401d1c <main+0x108>)
  401cb8:	6351      	str	r1, [r2, #52]	; 0x34
  401cba:	e7d0      	b.n	401c5e <main+0x4a>
  401cbc:	f44f 7100 	mov.w	r1, #512	; 0x200
  401cc0:	4a16      	ldr	r2, [pc, #88]	; (401d1c <main+0x108>)
  401cc2:	6351      	str	r1, [r2, #52]	; 0x34
  401cc4:	e7d2      	b.n	401c6c <main+0x58>
  401cc6:	f44f 6280 	mov.w	r2, #1024	; 0x400
  401cca:	4b14      	ldr	r3, [pc, #80]	; (401d1c <main+0x108>)
  401ccc:	635a      	str	r2, [r3, #52]	; 0x34
  401cce:	e7d4      	b.n	401c7a <main+0x66>
		IMU for new quaternion coefficients before it is ready with the next set of them. (also really only relevant for the demo code, in
		reality it doesn't matter if we ask for coefficients before the IMU is ready with new ones, as the function will just return the last
		valid coefficients it collected in the event that the IMU isn't ready with new ones) */
		if(nRF_24_is_data_available(1)){ //There is data for me to collect :)
			nRF24_receive_data(data_store);
			for(int i = 0; i < 32; i++){
  401cd0:	3301      	adds	r3, #1
  401cd2:	2b1f      	cmp	r3, #31
  401cd4:	ddfc      	ble.n	401cd0 <main+0xbc>
			gpio_set_pin_level(LED2, data_store[0] & 0b0100);
			gpio_set_pin_level(LED3, data_store[0] & 0b1000);
			memset(&data_store[0], 0, sizeof(uint8_t)*32);
			*/
			
			NPP_process(&data_store[0], &robot_ID);
  401cd6:	f10d 0127 	add.w	r1, sp, #39	; 0x27
  401cda:	a801      	add	r0, sp, #4
  401cdc:	4b19      	ldr	r3, [pc, #100]	; (401d44 <main+0x130>)
  401cde:	4798      	blx	r3
			memset(&data_store[0], 0, sizeof(uint8_t)*32);
  401ce0:	2220      	movs	r2, #32
  401ce2:	2100      	movs	r1, #0
  401ce4:	a801      	add	r0, sp, #4
  401ce6:	4b0e      	ldr	r3, [pc, #56]	; (401d20 <main+0x10c>)
  401ce8:	4798      	blx	r3
		if(nRF_24_is_data_available(1)){ //There is data for me to collect :)
  401cea:	2001      	movs	r0, #1
  401cec:	4b16      	ldr	r3, [pc, #88]	; (401d48 <main+0x134>)
  401cee:	4798      	blx	r3
  401cf0:	2800      	cmp	r0, #0
  401cf2:	d0fa      	beq.n	401cea <main+0xd6>
			nRF24_receive_data(data_store);
  401cf4:	a801      	add	r0, sp, #4
  401cf6:	4b15      	ldr	r3, [pc, #84]	; (401d4c <main+0x138>)
  401cf8:	4798      	blx	r3
			for(int i = 0; i < 32; i++){
  401cfa:	2300      	movs	r3, #0
  401cfc:	e7e9      	b.n	401cd2 <main+0xbe>
  401cfe:	bf00      	nop
  401d00:	004001c5 	.word	0x004001c5
  401d04:	2040009c 	.word	0x2040009c
  401d08:	00401c05 	.word	0x00401c05
  401d0c:	2040012c 	.word	0x2040012c
  401d10:	00400db9 	.word	0x00400db9
  401d14:	00400d7d 	.word	0x00400d7d
  401d18:	00401d51 	.word	0x00401d51
  401d1c:	400e1400 	.word	0x400e1400
  401d20:	004020f5 	.word	0x004020f5
  401d24:	00401f79 	.word	0x00401f79
  401d28:	00400811 	.word	0x00400811
  401d2c:	00402055 	.word	0x00402055
  401d30:	204000b4 	.word	0x204000b4
  401d34:	00400ad1 	.word	0x00400ad1
  401d38:	204000f0 	.word	0x204000f0
  401d3c:	204000d0 	.word	0x204000d0
  401d40:	004007b5 	.word	0x004007b5
  401d44:	00401da9 	.word	0x00401da9
  401d48:	0040202d 	.word	0x0040202d
  401d4c:	00401ef9 	.word	0x00401ef9

00401d50 <NPP_init>:
	return ((Pio *)hw)->PIO_PDSR;
  401d50:	4a0a      	ldr	r2, [pc, #40]	; (401d7c <NPP_init+0x2c>)
  401d52:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
  401d54:	f3c3 3300 	ubfx	r3, r3, #12, #1
  401d58:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
  401d5a:	f3c1 3140 	ubfx	r1, r1, #13, #1
uint8_t kicker; //kicker information
uint8_t chipper; //chipper information


void NPP_init(uint8_t *robot_ID){
	*robot_ID = gpio_get_pin_level(DipSwitch0) + //reads dip switches 3-0 to set robot_ID
  401d5e:	eb03 0341 	add.w	r3, r3, r1, lsl #1
  401d62:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
  401d64:	f3c1 3180 	ubfx	r1, r1, #14, #1
				(gpio_get_pin_level(DipSwitch1) << 1) +
  401d68:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  401d6c:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  401d6e:	f3c2 32c0 	ubfx	r2, r2, #15, #1
				(gpio_get_pin_level(DipSwitch2) << 2) +
				(gpio_get_pin_level(DipSwitch3) << 3);
  401d72:	00d2      	lsls	r2, r2, #3
				(gpio_get_pin_level(DipSwitch2) << 2) +
  401d74:	fa52 f383 	uxtab	r3, r2, r3
	*robot_ID = gpio_get_pin_level(DipSwitch0) + //reads dip switches 3-0 to set robot_ID
  401d78:	7003      	strb	r3, [r0, #0]
  401d7a:	4770      	bx	lr
  401d7c:	400e1400 	.word	0x400e1400

00401d80 <two_byte_to_float>:
	}
}

//converts two bytes into floating point
void two_byte_to_float(float *velocity, uint8_t *data, uint8_t byte_location){
	int16_t velocity_mod = data[byte_location] + (data[byte_location + 1] << 8);
  401d80:	5c8b      	ldrb	r3, [r1, r2]
  401d82:	4411      	add	r1, r2
  401d84:	784a      	ldrb	r2, [r1, #1]
  401d86:	eb03 2302 	add.w	r3, r3, r2, lsl #8
  401d8a:	b21b      	sxth	r3, r3
	*velocity =	(float)velocity_mod/VELOCITY_MODIFIER;
  401d8c:	ee07 3a90 	vmov	s15, r3
  401d90:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  401d94:	eddf 6a03 	vldr	s13, [pc, #12]	; 401da4 <two_byte_to_float+0x24>
  401d98:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  401d9c:	ed80 7a00 	vstr	s14, [r0]
  401da0:	4770      	bx	lr
  401da2:	bf00      	nop
  401da4:	42c80000 	.word	0x42c80000

00401da8 <NPP_process>:
void NPP_process(uint8_t *data, uint8_t *robot_ID){
  401da8:	b538      	push	{r3, r4, r5, lr}
	if((data[0] & 0xF) == *robot_ID){ //target robot ID number
  401daa:	7803      	ldrb	r3, [r0, #0]
  401dac:	780a      	ldrb	r2, [r1, #0]
  401dae:	f003 030f 	and.w	r3, r3, #15
  401db2:	429a      	cmp	r2, r3
  401db4:	d000      	beq.n	401db8 <NPP_process+0x10>
  401db6:	bd38      	pop	{r3, r4, r5, pc}
  401db8:	4604      	mov	r4, r0
		two_byte_to_float(&velocity_motor_0, data, MOTOR_0_BYTE);
  401dba:	2201      	movs	r2, #1
  401dbc:	4601      	mov	r1, r0
  401dbe:	480d      	ldr	r0, [pc, #52]	; (401df4 <NPP_process+0x4c>)
  401dc0:	4d0d      	ldr	r5, [pc, #52]	; (401df8 <NPP_process+0x50>)
  401dc2:	47a8      	blx	r5
		two_byte_to_float(&velocity_motor_1, data, MOTOR_1_BYTE);
  401dc4:	2203      	movs	r2, #3
  401dc6:	4621      	mov	r1, r4
  401dc8:	480c      	ldr	r0, [pc, #48]	; (401dfc <NPP_process+0x54>)
  401dca:	47a8      	blx	r5
		two_byte_to_float(&velocity_motor_2, data, MOTOR_2_BYTE);
  401dcc:	2205      	movs	r2, #5
  401dce:	4621      	mov	r1, r4
  401dd0:	480b      	ldr	r0, [pc, #44]	; (401e00 <NPP_process+0x58>)
  401dd2:	47a8      	blx	r5
		two_byte_to_float(&velocity_motor_3, data, MOTOR_3_BYTE);
  401dd4:	2207      	movs	r2, #7
  401dd6:	4621      	mov	r1, r4
  401dd8:	480a      	ldr	r0, [pc, #40]	; (401e04 <NPP_process+0x5c>)
  401dda:	47a8      	blx	r5
		two_byte_to_float(&velocity_motor_dribbler, data, MOTOR_DRIBBLER_BYTE);
  401ddc:	2209      	movs	r2, #9
  401dde:	4621      	mov	r1, r4
  401de0:	4809      	ldr	r0, [pc, #36]	; (401e08 <NPP_process+0x60>)
  401de2:	47a8      	blx	r5
		kicker = data[KICKER_BYTE];
  401de4:	7ae2      	ldrb	r2, [r4, #11]
  401de6:	4b09      	ldr	r3, [pc, #36]	; (401e0c <NPP_process+0x64>)
  401de8:	701a      	strb	r2, [r3, #0]
		chipper = data[CHIPPER_BYTE];
  401dea:	7b22      	ldrb	r2, [r4, #12]
  401dec:	4b08      	ldr	r3, [pc, #32]	; (401e10 <NPP_process+0x68>)
  401dee:	701a      	strb	r2, [r3, #0]
}
  401df0:	e7e1      	b.n	401db6 <NPP_process+0xe>
  401df2:	bf00      	nop
  401df4:	20400158 	.word	0x20400158
  401df8:	00401d81 	.word	0x00401d81
  401dfc:	2040015c 	.word	0x2040015c
  401e00:	2040014c 	.word	0x2040014c
  401e04:	20400154 	.word	0x20400154
  401e08:	20400148 	.word	0x20400148
  401e0c:	20400150 	.word	0x20400150
  401e10:	20400151 	.word	0x20400151

00401e14 <nRF24_write_to_register>:
/* The io_descriptor and pointer for the received byte array are declared. */
struct io_descriptor *spi_0_io;
uint8_t* global_data_pointer;

/* This function takes in a byte indicating which of the nRF24's registers should be written to, and then a single byte of data to write to that register */
void nRF24_write_to_register(uint8_t registerd, uint8_t data){
  401e14:	b530      	push	{r4, r5, lr}
  401e16:	b083      	sub	sp, #12
	memset(&buffer[0], 0, sizeof(uint8_t)*2);
	/* Set bits 7:5 to be equal to the Write to Register SPI command word (001). 32 = 0010 000. */
	buffer[0] = buffer[0] | 32;
	/* Set bits 4:0 to be equal to the 5 bit long register number to write to. If editing this code later, be careful not to use the word register as a variable, as it is a reserved
	word by another library we use. */
	buffer[0] = (buffer[0]) | registerd;
  401e18:	f040 0020 	orr.w	r0, r0, #32
  401e1c:	f88d 0004 	strb.w	r0, [sp, #4]
	/* Set the second byte of the buffer equal to the passed in data to be written to the register */
	buffer[1] = data;
  401e20:	f88d 1005 	strb.w	r1, [sp, #5]
	((Pio *)hw)->PIO_CODR = mask;
  401e24:	4c05      	ldr	r4, [pc, #20]	; (401e3c <nRF24_write_to_register+0x28>)
  401e26:	2508      	movs	r5, #8
  401e28:	6365      	str	r5, [r4, #52]	; 0x34
	/* Send the constructed packet to the nRF24 over SPI */
	gpio_set_pin_level(RF24_CSN, false); //Drive low before doing SPI transmissions
	io_write(spi_0_io, buffer, 2); //Write the constructed 2 byte packet to the nRF24 over SPI
  401e2a:	2202      	movs	r2, #2
  401e2c:	a901      	add	r1, sp, #4
  401e2e:	4b04      	ldr	r3, [pc, #16]	; (401e40 <nRF24_write_to_register+0x2c>)
  401e30:	6818      	ldr	r0, [r3, #0]
  401e32:	4b04      	ldr	r3, [pc, #16]	; (401e44 <nRF24_write_to_register+0x30>)
  401e34:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401e36:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //Drive back to high after doing SPI transmissions
}
  401e38:	b003      	add	sp, #12
  401e3a:	bd30      	pop	{r4, r5, pc}
  401e3c:	400e1000 	.word	0x400e1000
  401e40:	20400164 	.word	0x20400164
  401e44:	00400a19 	.word	0x00400a19

00401e48 <nRF24_write_to_register_multi_byte>:

/* This function takes in a byte indicating which of the nRF24's registers should be written to, a pointer to multiple bytes of data to be written to that register, and the length
(in number of bytes) of the data to be sent to the register */
void nRF24_write_to_register_multi_byte(uint8_t registerd, uint8_t *data, int length){
  401e48:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  401e4c:	b083      	sub	sp, #12
  401e4e:	4688      	mov	r8, r1
  401e50:	4691      	mov	r9, r2
	buffer = 0;
	/* Set bits 7:5 to be equal to the Write to Register SPI command word (001). 32 = 0010 000. */
	buffer = buffer | 32;
	/* Set bits 4:0 to be equal to the 5 bit long register number to write to. If editing this code later, be careful not to use the word register as a variable, as it is a reserved
	word by another library we use. */
	buffer = buffer | registerd;
  401e52:	f040 0020 	orr.w	r0, r0, #32
  401e56:	a902      	add	r1, sp, #8
  401e58:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401e5c:	4c08      	ldr	r4, [pc, #32]	; (401e80 <nRF24_write_to_register_multi_byte+0x38>)
  401e5e:	2508      	movs	r5, #8
  401e60:	6365      	str	r5, [r4, #52]	; 0x34
	/* Send the constructed packet to the nRF24 over SPI */
	gpio_set_pin_level(RF24_CSN, false); //Drive low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1); //Write the constructed 1 byte (does not contain any of the data to be written to the register) packet to the nRF24 over SPI
  401e62:	4f08      	ldr	r7, [pc, #32]	; (401e84 <nRF24_write_to_register_multi_byte+0x3c>)
  401e64:	2201      	movs	r2, #1
  401e66:	6838      	ldr	r0, [r7, #0]
  401e68:	4e07      	ldr	r6, [pc, #28]	; (401e88 <nRF24_write_to_register_multi_byte+0x40>)
  401e6a:	47b0      	blx	r6
	io_write(spi_0_io, data, length); //Write all of the data to be written to the register to the nRF24 over SPI
  401e6c:	fa1f f289 	uxth.w	r2, r9
  401e70:	4641      	mov	r1, r8
  401e72:	6838      	ldr	r0, [r7, #0]
  401e74:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  401e76:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //Drive back to high after doing SPI transmissions
}
  401e78:	b003      	add	sp, #12
  401e7a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401e7e:	bf00      	nop
  401e80:	400e1000 	.word	0x400e1000
  401e84:	20400164 	.word	0x20400164
  401e88:	00400a19 	.word	0x00400a19

00401e8c <nRF24_read_from_register>:

/* This function takes in a byte indicating which of the nRF24's registers should be read from, and then reads in a single byte from that register and returns it to the function caller */
uint8_t nRF24_read_from_register(uint8_t registerd){
  401e8c:	b570      	push	{r4, r5, r6, lr}
  401e8e:	b082      	sub	sp, #8
	/* Initialize a 1 byte buffer to all zeros. Bits 7:5 will be the Read to Register SPI command word (000), and then bits 4:0 will be the 5 bit long register number to read from */
	uint8_t buffer;
	buffer = 0;
	/* Set bits 4:0 to be equal to the 5 bit long register number to write to. If editing this code later, be careful not to use the word register as a variable, as it is a reserved
	word by another library we use. */
	buffer = buffer | registerd;
  401e90:	a902      	add	r1, sp, #8
  401e92:	f801 0d02 	strb.w	r0, [r1, #-2]!
	((Pio *)hw)->PIO_CODR = mask;
  401e96:	4c09      	ldr	r4, [pc, #36]	; (401ebc <nRF24_read_from_register+0x30>)
  401e98:	2508      	movs	r5, #8
  401e9a:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //Drive low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1); /* Write the constructed 1 byte packet to the nRF24 over SPI. This will tell the nRF24 that the next time we read, we would like it to return the 1 byte
  401e9c:	4e08      	ldr	r6, [pc, #32]	; (401ec0 <nRF24_read_from_register+0x34>)
  401e9e:	2201      	movs	r2, #1
  401ea0:	6830      	ldr	r0, [r6, #0]
  401ea2:	4b08      	ldr	r3, [pc, #32]	; (401ec4 <nRF24_read_from_register+0x38>)
  401ea4:	4798      	blx	r3
	of data from the target register */
	io_read(spi_0_io, &in_byte, 1); /* Read the 1 byte of data into the in_byte buffer */
  401ea6:	2201      	movs	r2, #1
  401ea8:	f10d 0107 	add.w	r1, sp, #7
  401eac:	6830      	ldr	r0, [r6, #0]
  401eae:	4b06      	ldr	r3, [pc, #24]	; (401ec8 <nRF24_read_from_register+0x3c>)
  401eb0:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401eb2:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //Drive back to high after doing SPI transmissions
	/* Return the 1 read byte back to the function caller */
	return in_byte;
}
  401eb4:	f89d 0007 	ldrb.w	r0, [sp, #7]
  401eb8:	b002      	add	sp, #8
  401eba:	bd70      	pop	{r4, r5, r6, pc}
  401ebc:	400e1000 	.word	0x400e1000
  401ec0:	20400164 	.word	0x20400164
  401ec4:	00400a19 	.word	0x00400a19
  401ec8:	00400a49 	.word	0x00400a49

00401ecc <nRF24_send_SPI_command>:
	io_read(spi_0_io, data_pointer, length); /* Read the multiple bytes of data into the pointer that was passed in as a parameter */
	gpio_set_pin_level(RF24_CSN, true); //Drive back to high after doing SPI transmissions
}

/* This function will send a raw SPI command to the nRF24, without reading or writing to or from a particular register. */
void nRF24_send_SPI_command(uint8_t command){
  401ecc:	b530      	push	{r4, r5, lr}
  401ece:	b083      	sub	sp, #12
  401ed0:	a902      	add	r1, sp, #8
  401ed2:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401ed6:	4c05      	ldr	r4, [pc, #20]	; (401eec <nRF24_send_SPI_command+0x20>)
  401ed8:	2508      	movs	r5, #8
  401eda:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //Drive low before doing SPI transmissions
	io_write(spi_0_io, &command, 1); //Send the 1 byte command that was received as a parameter to the nRF24 over SPI
  401edc:	2201      	movs	r2, #1
  401ede:	4b04      	ldr	r3, [pc, #16]	; (401ef0 <nRF24_send_SPI_command+0x24>)
  401ee0:	6818      	ldr	r0, [r3, #0]
  401ee2:	4b04      	ldr	r3, [pc, #16]	; (401ef4 <nRF24_send_SPI_command+0x28>)
  401ee4:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401ee6:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //Drive back to high after doing SPI transmissions
}
  401ee8:	b003      	add	sp, #12
  401eea:	bd30      	pop	{r4, r5, pc}
  401eec:	400e1000 	.word	0x400e1000
  401ef0:	20400164 	.word	0x20400164
  401ef4:	00400a19 	.word	0x00400a19

00401ef8 <nRF24_receive_data>:
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
	gpio_set_pin_level(RF24_CE, true);
}

void nRF24_receive_data(){
  401ef8:	b570      	push	{r4, r5, r6, lr}
  401efa:	b082      	sub	sp, #8
	uint8_t cmd = R_RX_PAYLOAD;
  401efc:	a902      	add	r1, sp, #8
  401efe:	2361      	movs	r3, #97	; 0x61
  401f00:	f801 3d01 	strb.w	r3, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401f04:	4c13      	ldr	r4, [pc, #76]	; (401f54 <nRF24_receive_data+0x5c>)
  401f06:	2508      	movs	r5, #8
  401f08:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &cmd, 1);
  401f0a:	4e13      	ldr	r6, [pc, #76]	; (401f58 <nRF24_receive_data+0x60>)
  401f0c:	2201      	movs	r2, #1
  401f0e:	6830      	ldr	r0, [r6, #0]
  401f10:	4b12      	ldr	r3, [pc, #72]	; (401f5c <nRF24_receive_data+0x64>)
  401f12:	4798      	blx	r3
	io_read(spi_0_io, global_data_pointer, 32);
  401f14:	2220      	movs	r2, #32
  401f16:	4b12      	ldr	r3, [pc, #72]	; (401f60 <nRF24_receive_data+0x68>)
  401f18:	6819      	ldr	r1, [r3, #0]
  401f1a:	6830      	ldr	r0, [r6, #0]
  401f1c:	4b11      	ldr	r3, [pc, #68]	; (401f64 <nRF24_receive_data+0x6c>)
  401f1e:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401f20:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	delay_us(11); //Make sure we had enough time to grab the data before flushing
  401f22:	200b      	movs	r0, #11
  401f24:	4b10      	ldr	r3, [pc, #64]	; (401f68 <nRF24_receive_data+0x70>)
  401f26:	4798      	blx	r3
	cmd = FLUSH_RX;
  401f28:	20e2      	movs	r0, #226	; 0xe2
  401f2a:	f88d 0007 	strb.w	r0, [sp, #7]
	nRF24_send_SPI_command(cmd);
  401f2e:	4b0f      	ldr	r3, [pc, #60]	; (401f6c <nRF24_receive_data+0x74>)
  401f30:	4798      	blx	r3
	uint8_t status_read = nRF24_read_from_register(STATUS);
  401f32:	2007      	movs	r0, #7
  401f34:	4b0e      	ldr	r3, [pc, #56]	; (401f70 <nRF24_receive_data+0x78>)
  401f36:	4798      	blx	r3
	status_read = status_read | 64;
  401f38:	f040 0140 	orr.w	r1, r0, #64	; 0x40
	nRF24_write_to_register(STATUS, status_read);
  401f3c:	b2c9      	uxtb	r1, r1
  401f3e:	2007      	movs	r0, #7
  401f40:	4b0c      	ldr	r3, [pc, #48]	; (401f74 <nRF24_receive_data+0x7c>)
  401f42:	4798      	blx	r3
	//uint8_t charray[64];
	for(int x = 0; x < 32; x++){
  401f44:	2300      	movs	r3, #0
  401f46:	e000      	b.n	401f4a <nRF24_receive_data+0x52>
  401f48:	3301      	adds	r3, #1
  401f4a:	2b1f      	cmp	r3, #31
  401f4c:	ddfc      	ble.n	401f48 <nRF24_receive_data+0x50>
		//printf("%02x ", global_data_pointer[x]);
	}
	//printf("\r\n");
}
  401f4e:	b002      	add	sp, #8
  401f50:	bd70      	pop	{r4, r5, r6, pc}
  401f52:	bf00      	nop
  401f54:	400e1000 	.word	0x400e1000
  401f58:	20400164 	.word	0x20400164
  401f5c:	00400a19 	.word	0x00400a19
  401f60:	20400160 	.word	0x20400160
  401f64:	00400a49 	.word	0x00400a49
  401f68:	00400811 	.word	0x00400811
  401f6c:	00401ecd 	.word	0x00401ecd
  401f70:	00401e8d 	.word	0x00401e8d
  401f74:	00401e15 	.word	0x00401e15

00401f78 <nRF24_init>:
void nRF24_init(uint8_t* data_pointer){
  401f78:	b530      	push	{r4, r5, lr}
  401f7a:	b083      	sub	sp, #12
  401f7c:	4605      	mov	r5, r0
	spi_m_sync_get_io_descriptor(&SPI_0, &spi_0_io);
  401f7e:	4c1f      	ldr	r4, [pc, #124]	; (401ffc <nRF24_init+0x84>)
  401f80:	491f      	ldr	r1, [pc, #124]	; (402000 <nRF24_init+0x88>)
  401f82:	4620      	mov	r0, r4
  401f84:	4b1f      	ldr	r3, [pc, #124]	; (402004 <nRF24_init+0x8c>)
  401f86:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
  401f88:	4620      	mov	r0, r4
  401f8a:	4b1f      	ldr	r3, [pc, #124]	; (402008 <nRF24_init+0x90>)
  401f8c:	4798      	blx	r3
	global_data_pointer = data_pointer;
  401f8e:	4b1f      	ldr	r3, [pc, #124]	; (40200c <nRF24_init+0x94>)
  401f90:	601d      	str	r5, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  401f92:	2504      	movs	r5, #4
  401f94:	4b1e      	ldr	r3, [pc, #120]	; (402010 <nRF24_init+0x98>)
  401f96:	635d      	str	r5, [r3, #52]	; 0x34
	nRF24_write_to_register(CONFIG,0); //0000 0000 Keep us in power down mode, IRQ pin assertion set to default, CRC disabled, RX / TX control in RX mode
  401f98:	2100      	movs	r1, #0
  401f9a:	4608      	mov	r0, r1
  401f9c:	4c1d      	ldr	r4, [pc, #116]	; (402014 <nRF24_init+0x9c>)
  401f9e:	47a0      	blx	r4
	uint8_t status_read = nRF24_read_from_register(STATUS);
  401fa0:	2007      	movs	r0, #7
  401fa2:	4b1d      	ldr	r3, [pc, #116]	; (402018 <nRF24_init+0xa0>)
  401fa4:	4798      	blx	r3
	status_read = status_read | 64;
  401fa6:	f040 0140 	orr.w	r1, r0, #64	; 0x40
	nRF24_write_to_register(STATUS, status_read);
  401faa:	b2c9      	uxtb	r1, r1
  401fac:	2007      	movs	r0, #7
  401fae:	47a0      	blx	r4
	nRF24_write_to_register(EN_AA,0); //0000 0000 no auto ACK
  401fb0:	2100      	movs	r1, #0
  401fb2:	2001      	movs	r0, #1
  401fb4:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR,0); //0000 0000 disable all RX pipes
  401fb6:	2100      	movs	r1, #0
  401fb8:	2002      	movs	r0, #2
  401fba:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_AW,3); //0000 0011 5 byte tx rx address fields
  401fbc:	2103      	movs	r1, #3
  401fbe:	4608      	mov	r0, r1
  401fc0:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_RETR,0); //0000 0000 no auto retransmission
  401fc2:	2100      	movs	r1, #0
  401fc4:	4628      	mov	r0, r5
  401fc6:	47a0      	blx	r4
	nRF24_write_to_register(RF_CH,120); //0111 1000 first bit must be 0, 0111 1000 = 120, freq = 2400 + 120 = 2520 = 2.52 GHz, tested to have low interference in UH
  401fc8:	2178      	movs	r1, #120	; 0x78
  401fca:	2005      	movs	r0, #5
  401fcc:	47a0      	blx	r4
	nRF24_write_to_register(RF_SETUP,6); //0000 0110 1 Mbps and maximum power output
  401fce:	2106      	movs	r1, #6
  401fd0:	4608      	mov	r0, r1
  401fd2:	47a0      	blx	r4
	uint8_t tx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA}; //Needs to be the same on the other nRF24L01+ device
  401fd4:	4b11      	ldr	r3, [pc, #68]	; (40201c <nRF24_init+0xa4>)
  401fd6:	e893 0003 	ldmia.w	r3, {r0, r1}
  401fda:	9000      	str	r0, [sp, #0]
  401fdc:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(TX_ADDR, &tx_address[0], 5);
  401fe0:	2205      	movs	r2, #5
  401fe2:	4669      	mov	r1, sp
  401fe4:	2010      	movs	r0, #16
  401fe6:	4b0e      	ldr	r3, [pc, #56]	; (402020 <nRF24_init+0xa8>)
  401fe8:	4798      	blx	r3
	nRF24_write_to_register(CONFIG,2); //0000 0020 enter standby-1, disable checksums
  401fea:	2102      	movs	r1, #2
  401fec:	2000      	movs	r0, #0
  401fee:	47a0      	blx	r4
	ext_irq_register(PB1, nRF24_receive_data); //enable interrupt	
  401ff0:	490c      	ldr	r1, [pc, #48]	; (402024 <nRF24_init+0xac>)
  401ff2:	2021      	movs	r0, #33	; 0x21
  401ff4:	4b0c      	ldr	r3, [pc, #48]	; (402028 <nRF24_init+0xb0>)
  401ff6:	4798      	blx	r3
}
  401ff8:	b003      	add	sp, #12
  401ffa:	bd30      	pop	{r4, r5, pc}
  401ffc:	204000d8 	.word	0x204000d8
  402000:	20400164 	.word	0x20400164
  402004:	00400c5d 	.word	0x00400c5d
  402008:	00400b7d 	.word	0x00400b7d
  40200c:	20400160 	.word	0x20400160
  402010:	400e1400 	.word	0x400e1400
  402014:	00401e15 	.word	0x00401e15
  402018:	00401e8d 	.word	0x00401e8d
  40201c:	00402418 	.word	0x00402418
  402020:	00401e49 	.word	0x00401e49
  402024:	00401ef9 	.word	0x00401ef9
  402028:	004008a9 	.word	0x004008a9

0040202c <nRF_24_is_data_available>:
uint8_t nRF_24_is_data_available(int pipe_num){
  40202c:	b508      	push	{r3, lr}
	status_reg = nRF24_read_from_register(STATUS);
  40202e:	2007      	movs	r0, #7
  402030:	4b06      	ldr	r3, [pc, #24]	; (40204c <nRF_24_is_data_available+0x20>)
  402032:	4798      	blx	r3
	if((status_reg&(1<<6))&&(status_reg&(1<<1))){ //1<<6 is the data ready rx fifo interrupt and 1<<1 is the data from pipe 1 ready to read 
  402034:	f000 0042 	and.w	r0, r0, #66	; 0x42
  402038:	2842      	cmp	r0, #66	; 0x42
  40203a:	d001      	beq.n	402040 <nRF_24_is_data_available+0x14>
	return 0;
  40203c:	2000      	movs	r0, #0
}
  40203e:	bd08      	pop	{r3, pc}
		nRF24_write_to_register(STATUS, (1<<6)); //clear data ready rx fifo
  402040:	2140      	movs	r1, #64	; 0x40
  402042:	2007      	movs	r0, #7
  402044:	4b02      	ldr	r3, [pc, #8]	; (402050 <nRF_24_is_data_available+0x24>)
  402046:	4798      	blx	r3
		return 1;
  402048:	2001      	movs	r0, #1
  40204a:	bd08      	pop	{r3, pc}
  40204c:	00401e8d 	.word	0x00401e8d
  402050:	00401e15 	.word	0x00401e15

00402054 <nRF24_enter_receive>:
void nRF24_enter_receive(){ //You are in receive at the end of this call
  402054:	b510      	push	{r4, lr}
  402056:	b082      	sub	sp, #8
	config_reg = nRF24_read_from_register(CONFIG);
  402058:	2000      	movs	r0, #0
  40205a:	4b0f      	ldr	r3, [pc, #60]	; (402098 <nRF24_enter_receive+0x44>)
  40205c:	4798      	blx	r3
	config_reg = config_reg | 1; //XXXX XXX1 PRIM_RX to 1
  40205e:	f040 0101 	orr.w	r1, r0, #1
	nRF24_write_to_register(CONFIG, config_reg);
  402062:	b2c9      	uxtb	r1, r1
  402064:	2000      	movs	r0, #0
  402066:	4c0d      	ldr	r4, [pc, #52]	; (40209c <nRF24_enter_receive+0x48>)
  402068:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR, 2); //0000 0010 set data pipe 1 to on
  40206a:	2102      	movs	r1, #2
  40206c:	4608      	mov	r0, r1
  40206e:	47a0      	blx	r4
	uint8_t rx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  402070:	4b0b      	ldr	r3, [pc, #44]	; (4020a0 <nRF24_enter_receive+0x4c>)
  402072:	e893 0003 	ldmia.w	r3, {r0, r1}
  402076:	9000      	str	r0, [sp, #0]
  402078:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
  40207c:	2205      	movs	r2, #5
  40207e:	4669      	mov	r1, sp
  402080:	200b      	movs	r0, #11
  402082:	4b08      	ldr	r3, [pc, #32]	; (4020a4 <nRF24_enter_receive+0x50>)
  402084:	4798      	blx	r3
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
  402086:	2120      	movs	r1, #32
  402088:	2012      	movs	r0, #18
  40208a:	47a0      	blx	r4
	((Pio *)hw)->PIO_SODR = mask;
  40208c:	2204      	movs	r2, #4
  40208e:	4b06      	ldr	r3, [pc, #24]	; (4020a8 <nRF24_enter_receive+0x54>)
  402090:	631a      	str	r2, [r3, #48]	; 0x30
}
  402092:	b002      	add	sp, #8
  402094:	bd10      	pop	{r4, pc}
  402096:	bf00      	nop
  402098:	00401e8d 	.word	0x00401e8d
  40209c:	00401e15 	.word	0x00401e15
  4020a0:	00402418 	.word	0x00402418
  4020a4:	00401e49 	.word	0x00401e49
  4020a8:	400e1400 	.word	0x400e1400

004020ac <__libc_init_array>:
  4020ac:	b570      	push	{r4, r5, r6, lr}
  4020ae:	4e0d      	ldr	r6, [pc, #52]	; (4020e4 <__libc_init_array+0x38>)
  4020b0:	4c0d      	ldr	r4, [pc, #52]	; (4020e8 <__libc_init_array+0x3c>)
  4020b2:	1ba4      	subs	r4, r4, r6
  4020b4:	10a4      	asrs	r4, r4, #2
  4020b6:	2500      	movs	r5, #0
  4020b8:	42a5      	cmp	r5, r4
  4020ba:	d109      	bne.n	4020d0 <__libc_init_array+0x24>
  4020bc:	4e0b      	ldr	r6, [pc, #44]	; (4020ec <__libc_init_array+0x40>)
  4020be:	4c0c      	ldr	r4, [pc, #48]	; (4020f0 <__libc_init_array+0x44>)
  4020c0:	f000 f9ae 	bl	402420 <_init>
  4020c4:	1ba4      	subs	r4, r4, r6
  4020c6:	10a4      	asrs	r4, r4, #2
  4020c8:	2500      	movs	r5, #0
  4020ca:	42a5      	cmp	r5, r4
  4020cc:	d105      	bne.n	4020da <__libc_init_array+0x2e>
  4020ce:	bd70      	pop	{r4, r5, r6, pc}
  4020d0:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4020d4:	4798      	blx	r3
  4020d6:	3501      	adds	r5, #1
  4020d8:	e7ee      	b.n	4020b8 <__libc_init_array+0xc>
  4020da:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4020de:	4798      	blx	r3
  4020e0:	3501      	adds	r5, #1
  4020e2:	e7f2      	b.n	4020ca <__libc_init_array+0x1e>
  4020e4:	0040242c 	.word	0x0040242c
  4020e8:	0040242c 	.word	0x0040242c
  4020ec:	0040242c 	.word	0x0040242c
  4020f0:	00402430 	.word	0x00402430

004020f4 <memset>:
  4020f4:	4402      	add	r2, r0
  4020f6:	4603      	mov	r3, r0
  4020f8:	4293      	cmp	r3, r2
  4020fa:	d100      	bne.n	4020fe <memset+0xa>
  4020fc:	4770      	bx	lr
  4020fe:	f803 1b01 	strb.w	r1, [r3], #1
  402102:	e7f9      	b.n	4020f8 <memset+0x4>
  402104:	682f2e2e 	.word	0x682f2e2e
  402108:	692f6c61 	.word	0x692f6c61
  40210c:	756c636e 	.word	0x756c636e
  402110:	682f6564 	.word	0x682f6564
  402114:	775f6c61 	.word	0x775f6c61
  402118:	682e7464 	.word	0x682e7464
  40211c:	00000000 	.word	0x00000000
  402120:	682f2e2e 	.word	0x682f2e2e
  402124:	732f6c61 	.word	0x732f6c61
  402128:	682f6372 	.word	0x682f6372
  40212c:	615f6c61 	.word	0x615f6c61
  402130:	735f6364 	.word	0x735f6364
  402134:	2e636e79 	.word	0x2e636e79
  402138:	00000063 	.word	0x00000063
  40213c:	682f2e2e 	.word	0x682f2e2e
  402140:	732f6c61 	.word	0x732f6c61
  402144:	682f6372 	.word	0x682f6372
  402148:	695f6c61 	.word	0x695f6c61
  40214c:	6d5f6332 	.word	0x6d5f6332
  402150:	6e79735f 	.word	0x6e79735f
  402154:	00632e63 	.word	0x00632e63
  402158:	682f2e2e 	.word	0x682f2e2e
  40215c:	732f6c61 	.word	0x732f6c61
  402160:	682f6372 	.word	0x682f6372
  402164:	695f6c61 	.word	0x695f6c61
  402168:	00632e6f 	.word	0x00632e6f
  40216c:	682f2e2e 	.word	0x682f2e2e
  402170:	732f6c61 	.word	0x732f6c61
  402174:	682f6372 	.word	0x682f6372
  402178:	705f6c61 	.word	0x705f6c61
  40217c:	632e6d77 	.word	0x632e6d77
  402180:	00000000 	.word	0x00000000
  402184:	682f2e2e 	.word	0x682f2e2e
  402188:	732f6c61 	.word	0x732f6c61
  40218c:	682f6372 	.word	0x682f6372
  402190:	735f6c61 	.word	0x735f6c61
  402194:	6d5f6970 	.word	0x6d5f6970
  402198:	6e79735f 	.word	0x6e79735f
  40219c:	00632e63 	.word	0x00632e63
  4021a0:	682f2e2e 	.word	0x682f2e2e
  4021a4:	732f6c61 	.word	0x732f6c61
  4021a8:	682f6372 	.word	0x682f6372
  4021ac:	745f6c61 	.word	0x745f6c61
  4021b0:	72656d69 	.word	0x72656d69
  4021b4:	0000632e 	.word	0x0000632e
  4021b8:	682f2e2e 	.word	0x682f2e2e
  4021bc:	752f6c61 	.word	0x752f6c61
  4021c0:	736c6974 	.word	0x736c6974
  4021c4:	6372732f 	.word	0x6372732f
  4021c8:	6974752f 	.word	0x6974752f
  4021cc:	6c5f736c 	.word	0x6c5f736c
  4021d0:	2e747369 	.word	0x2e747369
  4021d4:	00000063 	.word	0x00000063

004021d8 <_afecs>:
  4021d8:	00000000 2f843100 03000000 ffffffff     .....1./........
  4021e8:	0000ffff 00000000 00000000 00000000     ................
  4021f8:	0000010c 00000000 00000000 00000000     ................
  402208:	00000000 00000200 00000200 00000200     ................
  402218:	00000200 00000200 00000200 00000200     ................
  402228:	00000200 00000200 00000200 00000200     ................
  402238:	00000200 682f2e2e 612f6c70 2f636566     ....../hpl/afec/
  402248:	5f6c7068 63656661 0000632e              hpl_afec.c..

00402254 <_ext_irq>:
  402254:	00000000 03c08000 03c08020 03c08020     ........ ... ...
  402264:	00000000 03c00000 00008020 00000001     ........ .......
  402274:	00000002 000000f2 000000f2 00000000     ................
  402284:	000000f0 00000002                       ........

0040228c <_pio_irq_n>:
  40228c:	00100b0a 682f2e2e 702f6c70 682f6f69     ....../hpl/pio/h
  40229c:	705f6c70 655f6f69 632e7478 00000000     pl_pio_ext.c....

004022ac <_pwms>:
  4022ac:	40020000 0000001f 00010001 00000001     ...@............
  4022bc:	00000001 000000ff 00000000 00000004     ................
	...
  4022d8:	00000004 00402334 00000000 2040008c     ....4#@.......@ 
  4022e8:	4005c000 0000003c 00010001 00000001     ...@<...........
  4022f8:	00000001 000000ff 00000000 00000004     ................
	...
  402314:	00000001 00402324 00000000 20400080     ....$#@.......@ 

00402324 <_ch_cfg1>:
  402324:	00000000 00000208 00000400 00000200     ................

00402334 <_ch_cfg0>:
  402334:	00000000 00000208 00000400 00000200     ................
  402344:	00000001 00000208 00000400 00000200     ................
  402354:	00000002 00000208 00000400 00000200     ................
  402364:	00000003 00000208 00000400 00000200     ................
  402374:	682f2e2e 702f6c70 682f6d77 705f6c70     ../hpl/pwm/hpl_p
  402384:	632e6d77 00000000                       wm.c....

0040238c <spi_regs>:
  40238c:	00000000 80000000 00000001 0496fa02     ................
  40239c:	0000ffff 682f2e2e 732f6c70 682f6970     ....../hpl/spi/h
  4023ac:	735f6c70 632e6970 00000000 682f2e2e     pl_spi.c....../h
  4023bc:	742f6c70 70682f63 63745f6c 0000632e     pl/tc/hpl_tc.c..

004023cc <_i2cm_sync_cfgs>:
  4023cc:	40018000 00000020 00000000 00000000     ...@ ...........
  4023dc:	0002baba 000249f0 682f2e2e 742f6c70     .....I..../hpl/t
  4023ec:	73686977 6c70682f 6977745f 632e7368     wihs/hpl_twihs.c
  4023fc:	00000000 682f2e2e 772f6c70 682f7464     ....../hpl/wdt/h
  40240c:	775f6c70 632e7464 00000000 bbccddee     pl_wdt.c........
  40241c:	000000aa                                ....

00402420 <_init>:
  402420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402422:	bf00      	nop
  402424:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402426:	bc08      	pop	{r3}
  402428:	469e      	mov	lr, r3
  40242a:	4770      	bx	lr

0040242c <__init_array_start>:
  40242c:	0040017d 	.word	0x0040017d

00402430 <_fini>:
  402430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402432:	bf00      	nop
  402434:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402436:	bc08      	pop	{r3}
  402438:	469e      	mov	lr, r3
  40243a:	4770      	bx	lr

0040243c <__fini_array_start>:
  40243c:	00400159 	.word	0x00400159
