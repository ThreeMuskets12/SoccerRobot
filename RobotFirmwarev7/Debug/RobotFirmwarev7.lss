
RobotFirmwarev7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002018  00400000  00400000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000064  20400000  00402018  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000090  20400064  0040207c  00020064  2**2
                  ALLOC
  3 .heap         00000204  204000f4  0040210c  00020064  2**0
                  ALLOC
  4 .stack        00000400  204002f8  00402310  00020064  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020064  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020092  2**0
                  CONTENTS, READONLY
  7 .debug_info   00017cfd  00000000  00000000  000200eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003768  00000000  00000000  00037de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00008b25  00000000  00000000  0003b550  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000ad0  00000000  00000000  00044075  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000009c8  00000000  00000000  00044b45  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00042593  00000000  00000000  0004550d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00016a96  00000000  00000000  00087aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0014d3ab  00000000  00000000  0009e536  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00002094  00000000  00000000  001eb8e4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	f8 06 40 20 ed 01 40 00 e9 01 40 00 e9 01 40 00     ..@ ..@...@...@.
  400010:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e9 01 40 00 e9 01 40 00 00 00 00 00 e9 01 40 00     ..@...@.......@.
  40003c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40004c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40005c:	e9 01 40 00 e9 01 40 00 00 00 00 00 79 0c 40 00     ..@...@.....y.@.
  40006c:	85 0c 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40007c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40008c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40009c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ac:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000bc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000cc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000dc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ec:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000fc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40010c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ......@...@...@.
  40012c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40013c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40014c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40015c:	e9 01 40 00 e9 01 40 00 e9 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400064 	.word	0x20400064
  400184:	00000000 	.word	0x00000000
  400188:	00402018 	.word	0x00402018

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	00402018 	.word	0x00402018
  4001c8:	20400068 	.word	0x20400068
  4001cc:	00402018 	.word	0x00402018
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b02      	ldr	r3, [pc, #8]	; (4001e0 <atmel_start_init+0xc>)
  4001d8:	4798      	blx	r3
	stdio_redirect_init();
  4001da:	4b02      	ldr	r3, [pc, #8]	; (4001e4 <atmel_start_init+0x10>)
  4001dc:	4798      	blx	r3
  4001de:	bd08      	pop	{r3, pc}
  4001e0:	0040043d 	.word	0x0040043d
  4001e4:	00401651 	.word	0x00401651

004001e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e8:	e7fe      	b.n	4001e8 <Dummy_Handler>
	...

004001ec <Reset_Handler>:
{
  4001ec:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001ee:	4b10      	ldr	r3, [pc, #64]	; (400230 <Reset_Handler+0x44>)
  4001f0:	4a10      	ldr	r2, [pc, #64]	; (400234 <Reset_Handler+0x48>)
  4001f2:	429a      	cmp	r2, r3
  4001f4:	d009      	beq.n	40020a <Reset_Handler+0x1e>
  4001f6:	4b0e      	ldr	r3, [pc, #56]	; (400230 <Reset_Handler+0x44>)
  4001f8:	4a0e      	ldr	r2, [pc, #56]	; (400234 <Reset_Handler+0x48>)
  4001fa:	e003      	b.n	400204 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001fc:	6811      	ldr	r1, [r2, #0]
  4001fe:	6019      	str	r1, [r3, #0]
  400200:	3304      	adds	r3, #4
  400202:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  400204:	490c      	ldr	r1, [pc, #48]	; (400238 <Reset_Handler+0x4c>)
  400206:	428b      	cmp	r3, r1
  400208:	d3f8      	bcc.n	4001fc <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  40020a:	4b0c      	ldr	r3, [pc, #48]	; (40023c <Reset_Handler+0x50>)
  40020c:	e002      	b.n	400214 <Reset_Handler+0x28>
                *pDest++ = 0;
  40020e:	2200      	movs	r2, #0
  400210:	601a      	str	r2, [r3, #0]
  400212:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  400214:	4a0a      	ldr	r2, [pc, #40]	; (400240 <Reset_Handler+0x54>)
  400216:	4293      	cmp	r3, r2
  400218:	d3f9      	bcc.n	40020e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40021a:	4a0a      	ldr	r2, [pc, #40]	; (400244 <Reset_Handler+0x58>)
  40021c:	4b0a      	ldr	r3, [pc, #40]	; (400248 <Reset_Handler+0x5c>)
  40021e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400222:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  400224:	4b09      	ldr	r3, [pc, #36]	; (40024c <Reset_Handler+0x60>)
  400226:	4798      	blx	r3
        main();
  400228:	4b09      	ldr	r3, [pc, #36]	; (400250 <Reset_Handler+0x64>)
  40022a:	4798      	blx	r3
  40022c:	e7fe      	b.n	40022c <Reset_Handler+0x40>
  40022e:	bf00      	nop
  400230:	20400000 	.word	0x20400000
  400234:	00402018 	.word	0x00402018
  400238:	20400064 	.word	0x20400064
  40023c:	20400064 	.word	0x20400064
  400240:	204000f4 	.word	0x204000f4
  400244:	e000ed00 	.word	0xe000ed00
  400248:	00400000 	.word	0x00400000
  40024c:	00401671 	.word	0x00401671
  400250:	004013c9 	.word	0x004013c9

00400254 <EXTERNAL_IRQ_0_init>:
	((Pio *)hw)->PIO_ODR = ~data;
}

static inline void hri_pio_clear_OSR_reg(const void *const hw, hri_pio_osr_reg_t mask)
{
	((Pio *)hw)->PIO_ODR = mask;
  400254:	4b03      	ldr	r3, [pc, #12]	; (400264 <EXTERNAL_IRQ_0_init+0x10>)
  400256:	2220      	movs	r2, #32
  400258:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = ~data;
}

static inline void hri_pio_clear_PUSR_reg(const void *const hw, hri_pio_pusr_reg_t mask)
{
	((Pio *)hw)->PIO_PUDR = mask;
  40025a:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = ~data;
}

static inline void hri_pio_clear_PPDSR_reg(const void *const hw, hri_pio_ppdsr_reg_t mask)
{
	((Pio *)hw)->PIO_PPDDR = mask;
  40025c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400260:	601a      	str	r2, [r3, #0]
  400262:	4770      	bx	lr
  400264:	400e0e00 	.word	0x400e0e00

00400268 <EXTERNAL_IRQ_1_init>:
	((Pio *)hw)->PIO_ODR = mask;
  400268:	4b03      	ldr	r3, [pc, #12]	; (400278 <EXTERNAL_IRQ_1_init+0x10>)
  40026a:	2202      	movs	r2, #2
  40026c:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40026e:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400270:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400274:	601a      	str	r2, [r3, #0]
  400276:	4770      	bx	lr
  400278:	400e1000 	.word	0x400e1000

0040027c <SPI_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40027c:	4b11      	ldr	r3, [pc, #68]	; (4002c4 <SPI_0_PORT_init+0x48>)
  40027e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400280:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  400284:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  40028c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40028e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  400292:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400294:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400296:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  40029a:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40029c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40029e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4002a2:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002a4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4002a8:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4002aa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002ac:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  4002b0:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4002b2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002b4:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  4002b8:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002ba:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  4002be:	605a      	str	r2, [r3, #4]
  4002c0:	4770      	bx	lr
  4002c2:	bf00      	nop
  4002c4:	400e1400 	.word	0x400e1400

004002c8 <SPI_0_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4002c8:	4b04      	ldr	r3, [pc, #16]	; (4002dc <SPI_0_CLOCK_init+0x14>)
  4002ca:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4002cc:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  4002d0:	d103      	bne.n	4002da <SPI_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002d2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4002d6:	4b01      	ldr	r3, [pc, #4]	; (4002dc <SPI_0_CLOCK_init+0x14>)
  4002d8:	611a      	str	r2, [r3, #16]
  4002da:	4770      	bx	lr
  4002dc:	400e0600 	.word	0x400e0600

004002e0 <SPI_0_init>:
{
	_pmc_enable_periph_clock(ID_SPI0);
}

void SPI_0_init(void)
{
  4002e0:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
  4002e2:	4b08      	ldr	r3, [pc, #32]	; (400304 <SPI_0_init+0x24>)
  4002e4:	4798      	blx	r3
	spi_m_sync_set_func_ptr(&SPI_0, _spi_get_spi_m_sync());
  4002e6:	4b08      	ldr	r3, [pc, #32]	; (400308 <SPI_0_init+0x28>)
  4002e8:	4798      	blx	r3
  4002ea:	4c08      	ldr	r4, [pc, #32]	; (40030c <SPI_0_init+0x2c>)
  4002ec:	4601      	mov	r1, r0
  4002ee:	4620      	mov	r0, r4
  4002f0:	4b07      	ldr	r3, [pc, #28]	; (400310 <SPI_0_init+0x30>)
  4002f2:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SPI0);
  4002f4:	4907      	ldr	r1, [pc, #28]	; (400314 <SPI_0_init+0x34>)
  4002f6:	4620      	mov	r0, r4
  4002f8:	4b07      	ldr	r3, [pc, #28]	; (400318 <SPI_0_init+0x38>)
  4002fa:	4798      	blx	r3
	SPI_0_PORT_init();
  4002fc:	4b07      	ldr	r3, [pc, #28]	; (40031c <SPI_0_init+0x3c>)
  4002fe:	4798      	blx	r3
  400300:	bd10      	pop	{r4, pc}
  400302:	bf00      	nop
  400304:	004002c9 	.word	0x004002c9
  400308:	00400f65 	.word	0x00400f65
  40030c:	204000b4 	.word	0x204000b4
  400310:	004006ed 	.word	0x004006ed
  400314:	40008000 	.word	0x40008000
  400318:	0040070d 	.word	0x0040070d
  40031c:	0040027d 	.word	0x0040027d

00400320 <I2C_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400320:	4b0a      	ldr	r3, [pc, #40]	; (40034c <I2C_0_PORT_init+0x2c>)
  400322:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400324:	f022 0210 	bic.w	r2, r2, #16
  400328:	671a      	str	r2, [r3, #112]	; 0x70
  40032a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40032c:	f022 0210 	bic.w	r2, r2, #16
  400330:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400332:	2210      	movs	r2, #16
  400334:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400336:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400338:	f022 0208 	bic.w	r2, r2, #8
  40033c:	671a      	str	r2, [r3, #112]	; 0x70
  40033e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400340:	f022 0208 	bic.w	r2, r2, #8
  400344:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400346:	2208      	movs	r2, #8
  400348:	605a      	str	r2, [r3, #4]
  40034a:	4770      	bx	lr
  40034c:	400e0e00 	.word	0x400e0e00

00400350 <I2C_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400350:	4b04      	ldr	r3, [pc, #16]	; (400364 <I2C_0_CLOCK_init+0x14>)
  400352:	699b      	ldr	r3, [r3, #24]
  400354:	f413 2f00 	tst.w	r3, #524288	; 0x80000
  400358:	d103      	bne.n	400362 <I2C_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40035a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40035e:	4b01      	ldr	r3, [pc, #4]	; (400364 <I2C_0_CLOCK_init+0x14>)
  400360:	611a      	str	r2, [r3, #16]
  400362:	4770      	bx	lr
  400364:	400e0600 	.word	0x400e0600

00400368 <I2C_0_init>:
{
	_pmc_enable_periph_clock(ID_TWIHS0);
}

void I2C_0_init(void)
{
  400368:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
  40036a:	4b04      	ldr	r3, [pc, #16]	; (40037c <I2C_0_init+0x14>)
  40036c:	4798      	blx	r3

	i2c_m_sync_init(&I2C_0, TWIHS0);
  40036e:	4904      	ldr	r1, [pc, #16]	; (400380 <I2C_0_init+0x18>)
  400370:	4804      	ldr	r0, [pc, #16]	; (400384 <I2C_0_init+0x1c>)
  400372:	4b05      	ldr	r3, [pc, #20]	; (400388 <I2C_0_init+0x20>)
  400374:	4798      	blx	r3

	I2C_0_PORT_init();
  400376:	4b05      	ldr	r3, [pc, #20]	; (40038c <I2C_0_init+0x24>)
  400378:	4798      	blx	r3
  40037a:	bd08      	pop	{r3, pc}
  40037c:	00400351 	.word	0x00400351
  400380:	40018000 	.word	0x40018000
  400384:	204000cc 	.word	0x204000cc
  400388:	0040064d 	.word	0x0040064d
  40038c:	00400321 	.word	0x00400321

00400390 <delay_driver_init>:
}

void delay_driver_init(void)
{
  400390:	b508      	push	{r3, lr}
	delay_init(SysTick);
  400392:	4802      	ldr	r0, [pc, #8]	; (40039c <delay_driver_init+0xc>)
  400394:	4b02      	ldr	r3, [pc, #8]	; (4003a0 <delay_driver_init+0x10>)
  400396:	4798      	blx	r3
  400398:	bd08      	pop	{r3, pc}
  40039a:	bf00      	nop
  40039c:	e000e010 	.word	0xe000e010
  4003a0:	00400521 	.word	0x00400521

004003a4 <TARGET_IO_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4003a4:	4b0f      	ldr	r3, [pc, #60]	; (4003e4 <TARGET_IO_PORT_init+0x40>)
  4003a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003a8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4003ac:	671a      	str	r2, [r3, #112]	; 0x70
  4003ae:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003b0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4003b4:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003b6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4003ba:	605a      	str	r2, [r3, #4]
}

static inline void hri_matrix_set_CCFG_SYSIO_reg(const void *const hw, hri_matrix_ccfg_sysio_reg_t mask)
{
	MATRIX_CRITICAL_SECTION_ENTER();
	((Matrix *)hw)->CCFG_SYSIO |= mask;
  4003bc:	4a0a      	ldr	r2, [pc, #40]	; (4003e8 <TARGET_IO_PORT_init+0x44>)
  4003be:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  4003c2:	f043 0310 	orr.w	r3, r3, #16
  4003c6:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4003ca:	4b08      	ldr	r3, [pc, #32]	; (4003ec <TARGET_IO_PORT_init+0x48>)
  4003cc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003ce:	f042 0210 	orr.w	r2, r2, #16
  4003d2:	671a      	str	r2, [r3, #112]	; 0x70
  4003d4:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003d6:	f042 0210 	orr.w	r2, r2, #16
  4003da:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003dc:	2210      	movs	r2, #16
  4003de:	605a      	str	r2, [r3, #4]
  4003e0:	4770      	bx	lr
  4003e2:	bf00      	nop
  4003e4:	400e0e00 	.word	0x400e0e00
  4003e8:	40088000 	.word	0x40088000
  4003ec:	400e1000 	.word	0x400e1000

004003f0 <TARGET_IO_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4003f0:	4b04      	ldr	r3, [pc, #16]	; (400404 <TARGET_IO_CLOCK_init+0x14>)
  4003f2:	699b      	ldr	r3, [r3, #24]
  4003f4:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  4003f8:	d103      	bne.n	400402 <TARGET_IO_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4003fa:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  4003fe:	4b01      	ldr	r3, [pc, #4]	; (400404 <TARGET_IO_CLOCK_init+0x14>)
  400400:	611a      	str	r2, [r3, #16]
  400402:	4770      	bx	lr
  400404:	400e0600 	.word	0x400e0600

00400408 <TARGET_IO_init>:
{
	_pmc_enable_periph_clock(ID_USART1);
}

void TARGET_IO_init(void)
{
  400408:	b508      	push	{r3, lr}
	TARGET_IO_CLOCK_init();
  40040a:	4b06      	ldr	r3, [pc, #24]	; (400424 <TARGET_IO_init+0x1c>)
  40040c:	4798      	blx	r3
	TARGET_IO_PORT_init();
  40040e:	4b06      	ldr	r3, [pc, #24]	; (400428 <TARGET_IO_init+0x20>)
  400410:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, USART1, _usart_get_usart_sync());
  400412:	4b06      	ldr	r3, [pc, #24]	; (40042c <TARGET_IO_init+0x24>)
  400414:	4798      	blx	r3
  400416:	4602      	mov	r2, r0
  400418:	4905      	ldr	r1, [pc, #20]	; (400430 <TARGET_IO_init+0x28>)
  40041a:	4806      	ldr	r0, [pc, #24]	; (400434 <TARGET_IO_init+0x2c>)
  40041c:	4b06      	ldr	r3, [pc, #24]	; (400438 <TARGET_IO_init+0x30>)
  40041e:	4798      	blx	r3
  400420:	bd08      	pop	{r3, pc}
  400422:	bf00      	nop
  400424:	004003f1 	.word	0x004003f1
  400428:	004003a5 	.word	0x004003a5
  40042c:	004013c5 	.word	0x004013c5
  400430:	40028000 	.word	0x40028000
  400434:	204000a8 	.word	0x204000a8
  400438:	00400939 	.word	0x00400939

0040043c <system_init>:
}

void system_init(void)
{
  40043c:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  40043e:	4b26      	ldr	r3, [pc, #152]	; (4004d8 <system_init+0x9c>)
  400440:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400442:	4b26      	ldr	r3, [pc, #152]	; (4004dc <system_init+0xa0>)
  400444:	699b      	ldr	r3, [r3, #24]
  400446:	f413 6f80 	tst.w	r3, #1024	; 0x400
  40044a:	d103      	bne.n	400454 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40044c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  400450:	4b22      	ldr	r3, [pc, #136]	; (4004dc <system_init+0xa0>)
  400452:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400454:	4b21      	ldr	r3, [pc, #132]	; (4004dc <system_init+0xa0>)
  400456:	699b      	ldr	r3, [r3, #24]
  400458:	f413 6f00 	tst.w	r3, #2048	; 0x800
  40045c:	d103      	bne.n	400466 <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40045e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400462:	4b1e      	ldr	r3, [pc, #120]	; (4004dc <system_init+0xa0>)
  400464:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400466:	4b1d      	ldr	r3, [pc, #116]	; (4004dc <system_init+0xa0>)
  400468:	699b      	ldr	r3, [r3, #24]
  40046a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  40046e:	d103      	bne.n	400478 <system_init+0x3c>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400470:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  400474:	4b19      	ldr	r3, [pc, #100]	; (4004dc <system_init+0xa0>)
  400476:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400478:	4b18      	ldr	r3, [pc, #96]	; (4004dc <system_init+0xa0>)
  40047a:	699b      	ldr	r3, [r3, #24]
  40047c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400480:	d103      	bne.n	40048a <system_init+0x4e>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400482:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  400486:	4b15      	ldr	r3, [pc, #84]	; (4004dc <system_init+0xa0>)
  400488:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  40048a:	4a15      	ldr	r2, [pc, #84]	; (4004e0 <system_init+0xa4>)
  40048c:	6853      	ldr	r3, [r2, #4]
  40048e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400492:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_SODR = mask;
  400494:	4b13      	ldr	r3, [pc, #76]	; (4004e4 <system_init+0xa8>)
  400496:	2201      	movs	r2, #1
  400498:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  40049a:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40049c:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40049e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  4004a2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4004a6:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  4004a8:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  4004aa:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  4004ac:	f503 7300 	add.w	r3, r3, #512	; 0x200
  4004b0:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4004b4:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  4004b6:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  4004b8:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(RF24_CE, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(RF24_CE, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_0_init();
  4004ba:	4b0b      	ldr	r3, [pc, #44]	; (4004e8 <system_init+0xac>)
  4004bc:	4798      	blx	r3
	EXTERNAL_IRQ_1_init();
  4004be:	4b0b      	ldr	r3, [pc, #44]	; (4004ec <system_init+0xb0>)
  4004c0:	4798      	blx	r3

	SPI_0_init();
  4004c2:	4b0b      	ldr	r3, [pc, #44]	; (4004f0 <system_init+0xb4>)
  4004c4:	4798      	blx	r3

	I2C_0_init();
  4004c6:	4b0b      	ldr	r3, [pc, #44]	; (4004f4 <system_init+0xb8>)
  4004c8:	4798      	blx	r3

	delay_driver_init();
  4004ca:	4b0b      	ldr	r3, [pc, #44]	; (4004f8 <system_init+0xbc>)
  4004cc:	4798      	blx	r3

	TARGET_IO_init();
  4004ce:	4b0b      	ldr	r3, [pc, #44]	; (4004fc <system_init+0xc0>)
  4004d0:	4798      	blx	r3

	ext_irq_init();
  4004d2:	4b0b      	ldr	r3, [pc, #44]	; (400500 <system_init+0xc4>)
  4004d4:	4798      	blx	r3
  4004d6:	bd08      	pop	{r3, pc}
  4004d8:	00400a09 	.word	0x00400a09
  4004dc:	400e0600 	.word	0x400e0600
  4004e0:	400e1850 	.word	0x400e1850
  4004e4:	400e0e00 	.word	0x400e0e00
  4004e8:	00400255 	.word	0x00400255
  4004ec:	00400269 	.word	0x00400269
  4004f0:	004002e1 	.word	0x004002e1
  4004f4:	00400369 	.word	0x00400369
  4004f8:	00400391 	.word	0x00400391
  4004fc:	00400409 	.word	0x00400409
  400500:	004005b9 	.word	0x004005b9

00400504 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  400504:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  400508:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40050a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  40050c:	f3bf 8f5f 	dmb	sy
  400510:	4770      	bx	lr

00400512 <atomic_leave_critical>:
  400512:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  400516:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  400518:	f383 8810 	msr	PRIMASK, r3
  40051c:	4770      	bx	lr
	...

00400520 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  400520:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  400522:	4b02      	ldr	r3, [pc, #8]	; (40052c <delay_init+0xc>)
  400524:	6018      	str	r0, [r3, #0]
  400526:	4b02      	ldr	r3, [pc, #8]	; (400530 <delay_init+0x10>)
  400528:	4798      	blx	r3
  40052a:	bd08      	pop	{r3, pc}
  40052c:	20400080 	.word	0x20400080
  400530:	00400f7d 	.word	0x00400f7d

00400534 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
  400534:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
  400536:	4b04      	ldr	r3, [pc, #16]	; (400548 <delay_us+0x14>)
  400538:	681c      	ldr	r4, [r3, #0]
  40053a:	4b04      	ldr	r3, [pc, #16]	; (40054c <delay_us+0x18>)
  40053c:	4798      	blx	r3
  40053e:	4601      	mov	r1, r0
  400540:	4620      	mov	r0, r4
  400542:	4b03      	ldr	r3, [pc, #12]	; (400550 <delay_us+0x1c>)
  400544:	4798      	blx	r3
  400546:	bd10      	pop	{r4, pc}
  400548:	20400080 	.word	0x20400080
  40054c:	004009ed 	.word	0x004009ed
  400550:	00400f89 	.word	0x00400f89

00400554 <delay_ms>:

/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
  400554:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
  400556:	4b04      	ldr	r3, [pc, #16]	; (400568 <delay_ms+0x14>)
  400558:	681c      	ldr	r4, [r3, #0]
  40055a:	4b04      	ldr	r3, [pc, #16]	; (40056c <delay_ms+0x18>)
  40055c:	4798      	blx	r3
  40055e:	4601      	mov	r1, r0
  400560:	4620      	mov	r0, r4
  400562:	4b03      	ldr	r3, [pc, #12]	; (400570 <delay_ms+0x1c>)
  400564:	4798      	blx	r3
  400566:	bd10      	pop	{r4, pc}
  400568:	20400080 	.word	0x20400080
  40056c:	004009f7 	.word	0x004009f7
  400570:	00400f89 	.word	0x00400f89

00400574 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  400574:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  400576:	2502      	movs	r5, #2
  400578:	2400      	movs	r4, #0

	while (upper >= lower) {
  40057a:	e007      	b.n	40058c <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  40057c:	4a0d      	ldr	r2, [pc, #52]	; (4005b4 <process_ext_irq+0x40>)
  40057e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  400582:	b1b3      	cbz	r3, 4005b2 <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  400584:	4798      	blx	r3
  400586:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  400588:	3a01      	subs	r2, #1
  40058a:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
  40058c:	42ac      	cmp	r4, r5
  40058e:	d810      	bhi.n	4005b2 <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  400590:	192b      	adds	r3, r5, r4
  400592:	105b      	asrs	r3, r3, #1
  400594:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
  400596:	2a01      	cmp	r2, #1
  400598:	d80b      	bhi.n	4005b2 <process_ext_irq+0x3e>
  40059a:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
  40059c:	4905      	ldr	r1, [pc, #20]	; (4005b4 <process_ext_irq+0x40>)
  40059e:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  4005a2:	6849      	ldr	r1, [r1, #4]
  4005a4:	4281      	cmp	r1, r0
  4005a6:	d0e9      	beq.n	40057c <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  4005a8:	4281      	cmp	r1, r0
  4005aa:	d2ed      	bcs.n	400588 <process_ext_irq+0x14>
			lower = middle + 1;
  4005ac:	3201      	adds	r2, #1
  4005ae:	b2d4      	uxtb	r4, r2
  4005b0:	e7ec      	b.n	40058c <process_ext_irq+0x18>
  4005b2:	bd38      	pop	{r3, r4, r5, pc}
  4005b4:	20400084 	.word	0x20400084

004005b8 <ext_irq_init>:
{
  4005b8:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4005ba:	2300      	movs	r3, #0
  4005bc:	e00a      	b.n	4005d4 <ext_irq_init+0x1c>
		ext_irqs[i].pin = 0xFFFFFFFF;
  4005be:	4a08      	ldr	r2, [pc, #32]	; (4005e0 <ext_irq_init+0x28>)
  4005c0:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  4005c4:	f04f 30ff 	mov.w	r0, #4294967295
  4005c8:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  4005ca:	2100      	movs	r1, #0
  4005cc:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4005d0:	3301      	adds	r3, #1
  4005d2:	b29b      	uxth	r3, r3
  4005d4:	2b01      	cmp	r3, #1
  4005d6:	d9f2      	bls.n	4005be <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
  4005d8:	4802      	ldr	r0, [pc, #8]	; (4005e4 <ext_irq_init+0x2c>)
  4005da:	4b03      	ldr	r3, [pc, #12]	; (4005e8 <ext_irq_init+0x30>)
  4005dc:	4798      	blx	r3
}
  4005de:	bd08      	pop	{r3, pc}
  4005e0:	20400084 	.word	0x20400084
  4005e4:	00400575 	.word	0x00400575
  4005e8:	00400c91 	.word	0x00400c91

004005ec <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
  4005ec:	b510      	push	{r4, lr}
  4005ee:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
  4005f0:	8903      	ldrh	r3, [r0, #8]
  4005f2:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  4005f6:	4614      	mov	r4, r2
  4005f8:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
  4005fa:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4005fe:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
  400602:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400604:	a901      	add	r1, sp, #4
  400606:	3814      	subs	r0, #20
  400608:	4b03      	ldr	r3, [pc, #12]	; (400618 <i2c_m_sync_write+0x2c>)
  40060a:	4798      	blx	r3

	if (ret) {
  40060c:	b910      	cbnz	r0, 400614 <i2c_m_sync_write+0x28>
		return ret;
	}

	return n;
}
  40060e:	4620      	mov	r0, r4
  400610:	b004      	add	sp, #16
  400612:	bd10      	pop	{r4, pc}
		return ret;
  400614:	4604      	mov	r4, r0
  400616:	e7fa      	b.n	40060e <i2c_m_sync_write+0x22>
  400618:	00401049 	.word	0x00401049

0040061c <i2c_m_sync_read>:
{
  40061c:	b510      	push	{r4, lr}
  40061e:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
  400620:	8903      	ldrh	r3, [r0, #8]
  400622:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  400626:	4614      	mov	r4, r2
  400628:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
  40062a:	f248 0301 	movw	r3, #32769	; 0x8001
  40062e:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
  400632:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400634:	a901      	add	r1, sp, #4
  400636:	3814      	subs	r0, #20
  400638:	4b03      	ldr	r3, [pc, #12]	; (400648 <i2c_m_sync_read+0x2c>)
  40063a:	4798      	blx	r3
	if (ret) {
  40063c:	b910      	cbnz	r0, 400644 <i2c_m_sync_read+0x28>
}
  40063e:	4620      	mov	r0, r4
  400640:	b004      	add	sp, #16
  400642:	bd10      	pop	{r4, pc}
		return ret;
  400644:	4604      	mov	r4, r0
  400646:	e7fa      	b.n	40063e <i2c_m_sync_read+0x22>
  400648:	00401049 	.word	0x00401049

0040064c <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
  40064c:	b538      	push	{r3, r4, r5, lr}
  40064e:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
  400650:	4604      	mov	r4, r0
  400652:	225e      	movs	r2, #94	; 0x5e
  400654:	4908      	ldr	r1, [pc, #32]	; (400678 <i2c_m_sync_init+0x2c>)
  400656:	3000      	adds	r0, #0
  400658:	bf18      	it	ne
  40065a:	2001      	movne	r0, #1
  40065c:	4b07      	ldr	r3, [pc, #28]	; (40067c <i2c_m_sync_init+0x30>)
  40065e:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
  400660:	4629      	mov	r1, r5
  400662:	4620      	mov	r0, r4
  400664:	4b06      	ldr	r3, [pc, #24]	; (400680 <i2c_m_sync_init+0x34>)
  400666:	4798      	blx	r3
	if (init_status) {
  400668:	4603      	mov	r3, r0
  40066a:	b918      	cbnz	r0, 400674 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
  40066c:	4a05      	ldr	r2, [pc, #20]	; (400684 <i2c_m_sync_init+0x38>)
  40066e:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
  400670:	4a05      	ldr	r2, [pc, #20]	; (400688 <i2c_m_sync_init+0x3c>)
  400672:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
  400674:	4618      	mov	r0, r3
  400676:	bd38      	pop	{r3, r4, r5, pc}
  400678:	00401e38 	.word	0x00401e38
  40067c:	004009ad 	.word	0x004009ad
  400680:	00401001 	.word	0x00401001
  400684:	0040061d 	.word	0x0040061d
  400688:	004005ed 	.word	0x004005ed

0040068c <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  40068c:	b570      	push	{r4, r5, r6, lr}
  40068e:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  400690:	4604      	mov	r4, r0
  400692:	460d      	mov	r5, r1
  400694:	2800      	cmp	r0, #0
  400696:	bf18      	it	ne
  400698:	2900      	cmpne	r1, #0
  40069a:	bf14      	ite	ne
  40069c:	2001      	movne	r0, #1
  40069e:	2000      	moveq	r0, #0
  4006a0:	2234      	movs	r2, #52	; 0x34
  4006a2:	4904      	ldr	r1, [pc, #16]	; (4006b4 <io_write+0x28>)
  4006a4:	4b04      	ldr	r3, [pc, #16]	; (4006b8 <io_write+0x2c>)
  4006a6:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  4006a8:	6823      	ldr	r3, [r4, #0]
  4006aa:	4632      	mov	r2, r6
  4006ac:	4629      	mov	r1, r5
  4006ae:	4620      	mov	r0, r4
  4006b0:	4798      	blx	r3
}
  4006b2:	bd70      	pop	{r4, r5, r6, pc}
  4006b4:	00401e54 	.word	0x00401e54
  4006b8:	004009ad 	.word	0x004009ad

004006bc <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4006bc:	b570      	push	{r4, r5, r6, lr}
  4006be:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4006c0:	4604      	mov	r4, r0
  4006c2:	460d      	mov	r5, r1
  4006c4:	2800      	cmp	r0, #0
  4006c6:	bf18      	it	ne
  4006c8:	2900      	cmpne	r1, #0
  4006ca:	bf14      	ite	ne
  4006cc:	2001      	movne	r0, #1
  4006ce:	2000      	moveq	r0, #0
  4006d0:	223d      	movs	r2, #61	; 0x3d
  4006d2:	4904      	ldr	r1, [pc, #16]	; (4006e4 <io_read+0x28>)
  4006d4:	4b04      	ldr	r3, [pc, #16]	; (4006e8 <io_read+0x2c>)
  4006d6:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  4006d8:	6863      	ldr	r3, [r4, #4]
  4006da:	4632      	mov	r2, r6
  4006dc:	4629      	mov	r1, r5
  4006de:	4620      	mov	r0, r4
  4006e0:	4798      	blx	r3
}
  4006e2:	bd70      	pop	{r4, r5, r6, pc}
  4006e4:	00401e54 	.word	0x00401e54
  4006e8:	004009ad 	.word	0x004009ad

004006ec <spi_m_sync_set_func_ptr>:

/**
 *  \brief Initialize the SPI HAL instance function pointer for HPL APIs.
 */
void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi, void *const func)
{
  4006ec:	b538      	push	{r3, r4, r5, lr}
  4006ee:	460d      	mov	r5, r1
	ASSERT(spi);
  4006f0:	4604      	mov	r4, r0
  4006f2:	2239      	movs	r2, #57	; 0x39
  4006f4:	4903      	ldr	r1, [pc, #12]	; (400704 <spi_m_sync_set_func_ptr+0x18>)
  4006f6:	3000      	adds	r0, #0
  4006f8:	bf18      	it	ne
  4006fa:	2001      	movne	r0, #1
  4006fc:	4b02      	ldr	r3, [pc, #8]	; (400708 <spi_m_sync_set_func_ptr+0x1c>)
  4006fe:	4798      	blx	r3
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
  400700:	6025      	str	r5, [r4, #0]
  400702:	bd38      	pop	{r3, r4, r5, pc}
  400704:	00401e68 	.word	0x00401e68
  400708:	004009ad 	.word	0x004009ad

0040070c <spi_m_sync_init>:
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
  40070c:	b538      	push	{r3, r4, r5, lr}
	int32_t rc = 0;
	ASSERT(spi && hw);
  40070e:	4604      	mov	r4, r0
  400710:	460d      	mov	r5, r1
  400712:	2800      	cmp	r0, #0
  400714:	bf18      	it	ne
  400716:	2900      	cmpne	r1, #0
  400718:	bf14      	ite	ne
  40071a:	2001      	movne	r0, #1
  40071c:	2000      	moveq	r0, #0
  40071e:	2240      	movs	r2, #64	; 0x40
  400720:	4909      	ldr	r1, [pc, #36]	; (400748 <spi_m_sync_init+0x3c>)
  400722:	4b0a      	ldr	r3, [pc, #40]	; (40074c <spi_m_sync_init+0x40>)
  400724:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
  400726:	4620      	mov	r0, r4
  400728:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
  40072c:	4629      	mov	r1, r5
  40072e:	4b08      	ldr	r3, [pc, #32]	; (400750 <spi_m_sync_init+0x44>)
  400730:	4798      	blx	r3

	if (rc < 0) {
  400732:	2800      	cmp	r0, #0
  400734:	db07      	blt.n	400746 <spi_m_sync_init+0x3a>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
  400736:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40073a:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
  40073c:	4b05      	ldr	r3, [pc, #20]	; (400754 <spi_m_sync_init+0x48>)
  40073e:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
  400740:	4b05      	ldr	r3, [pc, #20]	; (400758 <spi_m_sync_init+0x4c>)
  400742:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
  400744:	2000      	movs	r0, #0
}
  400746:	bd38      	pop	{r3, r4, r5, pc}
  400748:	00401e68 	.word	0x00401e68
  40074c:	004009ad 	.word	0x004009ad
  400750:	00400d89 	.word	0x00400d89
  400754:	00400801 	.word	0x00400801
  400758:	004007c5 	.word	0x004007c5

0040075c <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
  40075c:	b510      	push	{r4, lr}
	ASSERT(spi);
  40075e:	4604      	mov	r4, r0
  400760:	2257      	movs	r2, #87	; 0x57
  400762:	4905      	ldr	r1, [pc, #20]	; (400778 <spi_m_sync_enable+0x1c>)
  400764:	3000      	adds	r0, #0
  400766:	bf18      	it	ne
  400768:	2001      	movne	r0, #1
  40076a:	4b04      	ldr	r3, [pc, #16]	; (40077c <spi_m_sync_enable+0x20>)
  40076c:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
  40076e:	1d20      	adds	r0, r4, #4
  400770:	4b03      	ldr	r3, [pc, #12]	; (400780 <spi_m_sync_enable+0x24>)
  400772:	4798      	blx	r3
  400774:	bd10      	pop	{r4, pc}
  400776:	bf00      	nop
  400778:	00401e68 	.word	0x00401e68
  40077c:	004009ad 	.word	0x004009ad
  400780:	00400e31 	.word	0x00400e31

00400784 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
  400784:	b530      	push	{r4, r5, lr}
  400786:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
  400788:	4605      	mov	r5, r0
  40078a:	460c      	mov	r4, r1
  40078c:	2800      	cmp	r0, #0
  40078e:	bf18      	it	ne
  400790:	2900      	cmpne	r1, #0
  400792:	bf14      	ite	ne
  400794:	2001      	movne	r0, #1
  400796:	2000      	moveq	r0, #0
  400798:	22b3      	movs	r2, #179	; 0xb3
  40079a:	4907      	ldr	r1, [pc, #28]	; (4007b8 <spi_m_sync_transfer+0x34>)
  40079c:	4b07      	ldr	r3, [pc, #28]	; (4007bc <spi_m_sync_transfer+0x38>)
  40079e:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
  4007a0:	6823      	ldr	r3, [r4, #0]
  4007a2:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
  4007a4:	6863      	ldr	r3, [r4, #4]
  4007a6:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
  4007a8:	68a3      	ldr	r3, [r4, #8]
  4007aa:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
  4007ac:	a901      	add	r1, sp, #4
  4007ae:	1d28      	adds	r0, r5, #4
  4007b0:	4b03      	ldr	r3, [pc, #12]	; (4007c0 <spi_m_sync_transfer+0x3c>)
  4007b2:	4798      	blx	r3
}
  4007b4:	b005      	add	sp, #20
  4007b6:	bd30      	pop	{r4, r5, pc}
  4007b8:	00401e68 	.word	0x00401e68
  4007bc:	004009ad 	.word	0x004009ad
  4007c0:	00400e65 	.word	0x00400e65

004007c4 <_spi_m_sync_io_write>:
{
  4007c4:	b570      	push	{r4, r5, r6, lr}
  4007c6:	b084      	sub	sp, #16
  4007c8:	460e      	mov	r6, r1
  4007ca:	4615      	mov	r5, r2
	ASSERT(io);
  4007cc:	4604      	mov	r4, r0
  4007ce:	22a3      	movs	r2, #163	; 0xa3
  4007d0:	4908      	ldr	r1, [pc, #32]	; (4007f4 <_spi_m_sync_io_write+0x30>)
  4007d2:	3000      	adds	r0, #0
  4007d4:	bf18      	it	ne
  4007d6:	2001      	movne	r0, #1
  4007d8:	4b07      	ldr	r3, [pc, #28]	; (4007f8 <_spi_m_sync_io_write+0x34>)
  4007da:	4798      	blx	r3
	xfer.rxbuf = 0;
  4007dc:	2300      	movs	r3, #0
  4007de:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
  4007e0:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
  4007e2:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  4007e4:	a901      	add	r1, sp, #4
  4007e6:	f1a4 000c 	sub.w	r0, r4, #12
  4007ea:	4b04      	ldr	r3, [pc, #16]	; (4007fc <_spi_m_sync_io_write+0x38>)
  4007ec:	4798      	blx	r3
}
  4007ee:	b004      	add	sp, #16
  4007f0:	bd70      	pop	{r4, r5, r6, pc}
  4007f2:	bf00      	nop
  4007f4:	00401e68 	.word	0x00401e68
  4007f8:	004009ad 	.word	0x004009ad
  4007fc:	00400785 	.word	0x00400785

00400800 <_spi_m_sync_io_read>:
{
  400800:	b570      	push	{r4, r5, r6, lr}
  400802:	b084      	sub	sp, #16
  400804:	460e      	mov	r6, r1
  400806:	4615      	mov	r5, r2
	ASSERT(io);
  400808:	4604      	mov	r4, r0
  40080a:	2287      	movs	r2, #135	; 0x87
  40080c:	4908      	ldr	r1, [pc, #32]	; (400830 <_spi_m_sync_io_read+0x30>)
  40080e:	3000      	adds	r0, #0
  400810:	bf18      	it	ne
  400812:	2001      	movne	r0, #1
  400814:	4b07      	ldr	r3, [pc, #28]	; (400834 <_spi_m_sync_io_read+0x34>)
  400816:	4798      	blx	r3
	xfer.rxbuf = buf;
  400818:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
  40081a:	2300      	movs	r3, #0
  40081c:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
  40081e:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400820:	a901      	add	r1, sp, #4
  400822:	f1a4 000c 	sub.w	r0, r4, #12
  400826:	4b04      	ldr	r3, [pc, #16]	; (400838 <_spi_m_sync_io_read+0x38>)
  400828:	4798      	blx	r3
}
  40082a:	b004      	add	sp, #16
  40082c:	bd70      	pop	{r4, r5, r6, pc}
  40082e:	bf00      	nop
  400830:	00401e68 	.word	0x00401e68
  400834:	004009ad 	.word	0x004009ad
  400838:	00400785 	.word	0x00400785

0040083c <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
  40083c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(spi && io);
  40083e:	4604      	mov	r4, r0
  400840:	460d      	mov	r5, r1
  400842:	2800      	cmp	r0, #0
  400844:	bf18      	it	ne
  400846:	2900      	cmpne	r1, #0
  400848:	bf14      	ite	ne
  40084a:	2001      	movne	r0, #1
  40084c:	2000      	moveq	r0, #0
  40084e:	22bd      	movs	r2, #189	; 0xbd
  400850:	4903      	ldr	r1, [pc, #12]	; (400860 <spi_m_sync_get_io_descriptor+0x24>)
  400852:	4b04      	ldr	r3, [pc, #16]	; (400864 <spi_m_sync_get_io_descriptor+0x28>)
  400854:	4798      	blx	r3
	*io = &spi->io;
  400856:	340c      	adds	r4, #12
  400858:	602c      	str	r4, [r5, #0]
	return 0;
}
  40085a:	2000      	movs	r0, #0
  40085c:	bd38      	pop	{r3, r4, r5, pc}
  40085e:	bf00      	nop
  400860:	00401e68 	.word	0x00401e68
  400864:	004009ad 	.word	0x004009ad

00400868 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  400868:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40086a:	4616      	mov	r6, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  40086c:	4605      	mov	r5, r0
  40086e:	460f      	mov	r7, r1
  400870:	2800      	cmp	r0, #0
  400872:	bf18      	it	ne
  400874:	2900      	cmpne	r1, #0
  400876:	d002      	beq.n	40087e <usart_sync_write+0x16>
  400878:	bb0a      	cbnz	r2, 4008be <usart_sync_write+0x56>
  40087a:	2000      	movs	r0, #0
  40087c:	e000      	b.n	400880 <usart_sync_write+0x18>
  40087e:	2000      	movs	r0, #0
  400880:	22f1      	movs	r2, #241	; 0xf1
  400882:	4910      	ldr	r1, [pc, #64]	; (4008c4 <usart_sync_write+0x5c>)
  400884:	4b10      	ldr	r3, [pc, #64]	; (4008c8 <usart_sync_write+0x60>)
  400886:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
  400888:	f105 0408 	add.w	r4, r5, #8
  40088c:	4620      	mov	r0, r4
  40088e:	4b0f      	ldr	r3, [pc, #60]	; (4008cc <usart_sync_write+0x64>)
  400890:	4798      	blx	r3
  400892:	2800      	cmp	r0, #0
  400894:	d0f8      	beq.n	400888 <usart_sync_write+0x20>
  400896:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
  400898:	5d79      	ldrb	r1, [r7, r5]
  40089a:	4620      	mov	r0, r4
  40089c:	4b0c      	ldr	r3, [pc, #48]	; (4008d0 <usart_sync_write+0x68>)
  40089e:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
  4008a0:	4620      	mov	r0, r4
  4008a2:	4b0a      	ldr	r3, [pc, #40]	; (4008cc <usart_sync_write+0x64>)
  4008a4:	4798      	blx	r3
  4008a6:	2800      	cmp	r0, #0
  4008a8:	d0fa      	beq.n	4008a0 <usart_sync_write+0x38>
			;
	} while (++offset < length);
  4008aa:	3501      	adds	r5, #1
  4008ac:	42b5      	cmp	r5, r6
  4008ae:	d3f3      	bcc.n	400898 <usart_sync_write+0x30>
	while (!_usart_sync_is_transmit_done(&descr->device))
  4008b0:	4620      	mov	r0, r4
  4008b2:	4b08      	ldr	r3, [pc, #32]	; (4008d4 <usart_sync_write+0x6c>)
  4008b4:	4798      	blx	r3
  4008b6:	2800      	cmp	r0, #0
  4008b8:	d0fa      	beq.n	4008b0 <usart_sync_write+0x48>
		;
	return (int32_t)offset;
}
  4008ba:	4628      	mov	r0, r5
  4008bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
  4008be:	2001      	movs	r0, #1
  4008c0:	e7de      	b.n	400880 <usart_sync_write+0x18>
  4008c2:	bf00      	nop
  4008c4:	00401e84 	.word	0x00401e84
  4008c8:	004009ad 	.word	0x004009ad
  4008cc:	0040134d 	.word	0x0040134d
  4008d0:	00401305 	.word	0x00401305
  4008d4:	00401375 	.word	0x00401375

004008d8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4008d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4008dc:	4617      	mov	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  4008de:	4605      	mov	r5, r0
  4008e0:	4688      	mov	r8, r1
  4008e2:	2800      	cmp	r0, #0
  4008e4:	bf18      	it	ne
  4008e6:	2900      	cmpne	r1, #0
  4008e8:	d002      	beq.n	4008f0 <usart_sync_read+0x18>
  4008ea:	b9d2      	cbnz	r2, 400922 <usart_sync_read+0x4a>
  4008ec:	2000      	movs	r0, #0
  4008ee:	e000      	b.n	4008f2 <usart_sync_read+0x1a>
  4008f0:	2000      	movs	r0, #0
  4008f2:	f44f 7286 	mov.w	r2, #268	; 0x10c
  4008f6:	490c      	ldr	r1, [pc, #48]	; (400928 <usart_sync_read+0x50>)
  4008f8:	4b0c      	ldr	r3, [pc, #48]	; (40092c <usart_sync_read+0x54>)
  4008fa:	4798      	blx	r3
	uint32_t                      offset = 0;
  4008fc:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
  4008fe:	f105 0408 	add.w	r4, r5, #8
  400902:	4620      	mov	r0, r4
  400904:	4b0a      	ldr	r3, [pc, #40]	; (400930 <usart_sync_read+0x58>)
  400906:	4798      	blx	r3
  400908:	2800      	cmp	r0, #0
  40090a:	d0f8      	beq.n	4008fe <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
  40090c:	4620      	mov	r0, r4
  40090e:	4b09      	ldr	r3, [pc, #36]	; (400934 <usart_sync_read+0x5c>)
  400910:	4798      	blx	r3
  400912:	f808 0006 	strb.w	r0, [r8, r6]
	} while (++offset < length);
  400916:	3601      	adds	r6, #1
  400918:	42be      	cmp	r6, r7
  40091a:	d3f0      	bcc.n	4008fe <usart_sync_read+0x26>

	return (int32_t)offset;
}
  40091c:	4630      	mov	r0, r6
  40091e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(io_descr && buf && length);
  400922:	2001      	movs	r0, #1
  400924:	e7e5      	b.n	4008f2 <usart_sync_read+0x1a>
  400926:	bf00      	nop
  400928:	00401e84 	.word	0x00401e84
  40092c:	004009ad 	.word	0x004009ad
  400930:	0040139d 	.word	0x0040139d
  400934:	00401329 	.word	0x00401329

00400938 <usart_sync_init>:
{
  400938:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  40093a:	4604      	mov	r4, r0
  40093c:	460d      	mov	r5, r1
  40093e:	2800      	cmp	r0, #0
  400940:	bf18      	it	ne
  400942:	2900      	cmpne	r1, #0
  400944:	bf14      	ite	ne
  400946:	2001      	movne	r0, #1
  400948:	2000      	moveq	r0, #0
  40094a:	2234      	movs	r2, #52	; 0x34
  40094c:	4907      	ldr	r1, [pc, #28]	; (40096c <usart_sync_init+0x34>)
  40094e:	4b08      	ldr	r3, [pc, #32]	; (400970 <usart_sync_init+0x38>)
  400950:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
  400952:	4629      	mov	r1, r5
  400954:	f104 0008 	add.w	r0, r4, #8
  400958:	4b06      	ldr	r3, [pc, #24]	; (400974 <usart_sync_init+0x3c>)
  40095a:	4798      	blx	r3
	if (init_status) {
  40095c:	4603      	mov	r3, r0
  40095e:	b918      	cbnz	r0, 400968 <usart_sync_init+0x30>
	descr->io.read  = usart_sync_read;
  400960:	4a05      	ldr	r2, [pc, #20]	; (400978 <usart_sync_init+0x40>)
  400962:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
  400964:	4a05      	ldr	r2, [pc, #20]	; (40097c <usart_sync_init+0x44>)
  400966:	6022      	str	r2, [r4, #0]
}
  400968:	4618      	mov	r0, r3
  40096a:	bd38      	pop	{r3, r4, r5, pc}
  40096c:	00401e84 	.word	0x00401e84
  400970:	004009ad 	.word	0x004009ad
  400974:	00401299 	.word	0x00401299
  400978:	004008d9 	.word	0x004008d9
  40097c:	00400869 	.word	0x00400869

00400980 <usart_sync_enable>:
{
  400980:	b510      	push	{r4, lr}
	ASSERT(descr);
  400982:	4604      	mov	r4, r0
  400984:	2253      	movs	r2, #83	; 0x53
  400986:	4906      	ldr	r1, [pc, #24]	; (4009a0 <usart_sync_enable+0x20>)
  400988:	3000      	adds	r0, #0
  40098a:	bf18      	it	ne
  40098c:	2001      	movne	r0, #1
  40098e:	4b05      	ldr	r3, [pc, #20]	; (4009a4 <usart_sync_enable+0x24>)
  400990:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
  400992:	f104 0008 	add.w	r0, r4, #8
  400996:	4b04      	ldr	r3, [pc, #16]	; (4009a8 <usart_sync_enable+0x28>)
  400998:	4798      	blx	r3
}
  40099a:	2000      	movs	r0, #0
  40099c:	bd10      	pop	{r4, pc}
  40099e:	bf00      	nop
  4009a0:	00401e84 	.word	0x00401e84
  4009a4:	004009ad 	.word	0x004009ad
  4009a8:	004012d1 	.word	0x004012d1

004009ac <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  4009ac:	b900      	cbnz	r0, 4009b0 <assert+0x4>
		__asm("BKPT #0");
  4009ae:	be00      	bkpt	0x0000
  4009b0:	4770      	bx	lr
	...

004009b4 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
  4009b4:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
  4009b6:	4a06      	ldr	r2, [pc, #24]	; (4009d0 <_sbrk+0x1c>)
  4009b8:	6812      	ldr	r2, [r2, #0]
  4009ba:	b122      	cbz	r2, 4009c6 <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
  4009bc:	4a04      	ldr	r2, [pc, #16]	; (4009d0 <_sbrk+0x1c>)
  4009be:	6810      	ldr	r0, [r2, #0]

	heap += incr;
  4009c0:	4403      	add	r3, r0
  4009c2:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
  4009c4:	4770      	bx	lr
		heap = (unsigned char *)&_end;
  4009c6:	4903      	ldr	r1, [pc, #12]	; (4009d4 <_sbrk+0x20>)
  4009c8:	4a01      	ldr	r2, [pc, #4]	; (4009d0 <_sbrk+0x1c>)
  4009ca:	6011      	str	r1, [r2, #0]
  4009cc:	e7f6      	b.n	4009bc <_sbrk+0x8>
  4009ce:	bf00      	nop
  4009d0:	20400094 	.word	0x20400094
  4009d4:	204006f8 	.word	0x204006f8

004009d8 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
  4009d8:	f04f 30ff 	mov.w	r0, #4294967295
  4009dc:	4770      	bx	lr

004009de <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
  4009de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  4009e2:	604b      	str	r3, [r1, #4]

	return 0;
}
  4009e4:	2000      	movs	r0, #0
  4009e6:	4770      	bx	lr

004009e8 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
  4009e8:	2000      	movs	r0, #0
  4009ea:	4770      	bx	lr

004009ec <_get_cycles_for_us>:
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
	return _get_cycles_for_us_internal(us, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  4009ec:	f44f 7396 	mov.w	r3, #300	; 0x12c
  4009f0:	fb03 f000 	mul.w	r0, r3, r0
  4009f4:	4770      	bx	lr

004009f6 <_get_cycles_for_ms>:
 */
static inline uint32_t _get_cycles_for_ms_internal(const uint16_t ms, const uint32_t freq, const uint8_t power)
{
	switch (power) {
	case 9:
		return (ms * (freq / 1000000)) * 1000;
  4009f6:	f44f 7396 	mov.w	r3, #300	; 0x12c
  4009fa:	fb03 f000 	mul.w	r0, r3, r0
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  4009fe:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  400a02:	fb03 f000 	mul.w	r0, r3, r0
  400a06:	4770      	bx	lr

00400a08 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  400a08:	b500      	push	{lr}
  400a0a:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  400a0c:	a801      	add	r0, sp, #4
  400a0e:	4b0e      	ldr	r3, [pc, #56]	; (400a48 <_init_chip+0x40>)
  400a10:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  400a12:	4a0e      	ldr	r2, [pc, #56]	; (400a4c <_init_chip+0x44>)
  400a14:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  400a18:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400a1c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  400a20:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400a24:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  400a28:	a801      	add	r0, sp, #4
  400a2a:	4b09      	ldr	r3, [pc, #36]	; (400a50 <_init_chip+0x48>)
  400a2c:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  400a2e:	4a09      	ldr	r2, [pc, #36]	; (400a54 <_init_chip+0x4c>)
  400a30:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  400a32:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  400a36:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  400a3a:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  400a3c:	4b06      	ldr	r3, [pc, #24]	; (400a58 <_init_chip+0x50>)
  400a3e:	4798      	blx	r3
}
  400a40:	b003      	add	sp, #12
  400a42:	f85d fb04 	ldr.w	pc, [sp], #4
  400a46:	bf00      	nop
  400a48:	00400505 	.word	0x00400505
  400a4c:	e000ed00 	.word	0xe000ed00
  400a50:	00400513 	.word	0x00400513
  400a54:	400e0c00 	.word	0x400e0c00
  400a58:	00400d55 	.word	0x00400d55

00400a5c <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  400a5c:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  400a5e:	2500      	movs	r5, #0
  400a60:	428d      	cmp	r5, r1
  400a62:	d210      	bcs.n	400a86 <_ffs+0x2a>
  400a64:	2201      	movs	r2, #1
  400a66:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400a68:	2b1f      	cmp	r3, #31
  400a6a:	d80a      	bhi.n	400a82 <_ffs+0x26>
			if (v[i] & bit) {
  400a6c:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  400a70:	4222      	tst	r2, r4
  400a72:	d102      	bne.n	400a7a <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400a74:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400a76:	3301      	adds	r3, #1
  400a78:	e7f6      	b.n	400a68 <_ffs+0xc>
				return i * 32 + j;
  400a7a:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  400a7e:	bc30      	pop	{r4, r5}
  400a80:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  400a82:	3501      	adds	r5, #1
  400a84:	e7ec      	b.n	400a60 <_ffs+0x4>
	return -1;
  400a86:	f04f 30ff 	mov.w	r0, #4294967295
  400a8a:	e7f8      	b.n	400a7e <_ffs+0x22>

00400a8c <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  400a8c:	b510      	push	{r4, lr}
  400a8e:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  400a90:	2300      	movs	r3, #0
  400a92:	9301      	str	r3, [sp, #4]
  400a94:	9302      	str	r3, [sp, #8]
  400a96:	9303      	str	r3, [sp, #12]
  400a98:	9304      	str	r3, [sp, #16]
  400a9a:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  400a9c:	4b21      	ldr	r3, [pc, #132]	; (400b24 <_ext_irq_handler+0x98>)
  400a9e:	6818      	ldr	r0, [r3, #0]
  400aa0:	22f8      	movs	r2, #248	; 0xf8
  400aa2:	4921      	ldr	r1, [pc, #132]	; (400b28 <_ext_irq_handler+0x9c>)
  400aa4:	3000      	adds	r0, #0
  400aa6:	bf18      	it	ne
  400aa8:	2001      	movne	r0, #1
  400aaa:	4b20      	ldr	r3, [pc, #128]	; (400b2c <_ext_irq_handler+0xa0>)
  400aac:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  400aae:	4b20      	ldr	r3, [pc, #128]	; (400b30 <_ext_irq_handler+0xa4>)
  400ab0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400ab2:	6c9b      	ldr	r3, [r3, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400ab4:	4013      	ands	r3, r2
  400ab6:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400ab8:	491e      	ldr	r1, [pc, #120]	; (400b34 <_ext_irq_handler+0xa8>)
  400aba:	6cca      	ldr	r2, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400abc:	6c89      	ldr	r1, [r1, #72]	; 0x48
	flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	flags[1] = hri_pio_read_ISR_reg(PIOB);
	flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400abe:	400a      	ands	r2, r1
  400ac0:	9202      	str	r2, [sp, #8]
	flag_total |= flags[1];
  400ac2:	4313      	orrs	r3, r2
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400ac4:	e025      	b.n	400b12 <_ext_irq_handler+0x86>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  400ac6:	4b17      	ldr	r3, [pc, #92]	; (400b24 <_ext_irq_handler+0x98>)
  400ac8:	681b      	ldr	r3, [r3, #0]
  400aca:	4620      	mov	r0, r4
  400acc:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  400ace:	1163      	asrs	r3, r4, #5
  400ad0:	f004 041f 	and.w	r4, r4, #31
  400ad4:	2201      	movs	r2, #1
  400ad6:	fa02 f404 	lsl.w	r4, r2, r4
  400ada:	aa06      	add	r2, sp, #24
  400adc:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400ae0:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400ae4:	ea22 0204 	bic.w	r2, r2, r4
  400ae8:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  400aec:	2105      	movs	r1, #5
  400aee:	a801      	add	r0, sp, #4
  400af0:	4b11      	ldr	r3, [pc, #68]	; (400b38 <_ext_irq_handler+0xac>)
  400af2:	4798      	blx	r3
  400af4:	4604      	mov	r4, r0
		while (-1 != pos) {
  400af6:	f1b4 3fff 	cmp.w	r4, #4294967295
  400afa:	d1e4      	bne.n	400ac6 <_ext_irq_handler+0x3a>
	return ((Pio *)hw)->PIO_ISR;
  400afc:	4a0c      	ldr	r2, [pc, #48]	; (400b30 <_ext_irq_handler+0xa4>)
  400afe:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400b00:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400b02:	400b      	ands	r3, r1
  400b04:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400b06:	490b      	ldr	r1, [pc, #44]	; (400b34 <_ext_irq_handler+0xa8>)
  400b08:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400b0a:	6c8a      	ldr	r2, [r1, #72]	; 0x48
		flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
		flags[1] = hri_pio_read_ISR_reg(PIOB);
		flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400b0c:	4002      	ands	r2, r0
  400b0e:	9202      	str	r2, [sp, #8]
		flag_total |= flags[1];
  400b10:	4313      	orrs	r3, r2
	while (flag_total) {
  400b12:	b12b      	cbz	r3, 400b20 <_ext_irq_handler+0x94>
		pos = _ffs(flags, 5);
  400b14:	2105      	movs	r1, #5
  400b16:	a801      	add	r0, sp, #4
  400b18:	4b07      	ldr	r3, [pc, #28]	; (400b38 <_ext_irq_handler+0xac>)
  400b1a:	4798      	blx	r3
  400b1c:	4604      	mov	r4, r0
		while (-1 != pos) {
  400b1e:	e7ea      	b.n	400af6 <_ext_irq_handler+0x6a>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  400b20:	b006      	add	sp, #24
  400b22:	bd10      	pop	{r4, pc}
  400b24:	20400098 	.word	0x20400098
  400b28:	00401ee0 	.word	0x00401ee0
  400b2c:	004009ad 	.word	0x004009ad
  400b30:	400e0e00 	.word	0x400e0e00
  400b34:	400e1000 	.word	0x400e1000
  400b38:	00400a5d 	.word	0x00400a5d

00400b3c <_pio_get_hardware_index>:
{
  400b3c:	b510      	push	{r4, lr}
	ASSERT(hw);
  400b3e:	4604      	mov	r4, r0
  400b40:	22d2      	movs	r2, #210	; 0xd2
  400b42:	4905      	ldr	r1, [pc, #20]	; (400b58 <_pio_get_hardware_index+0x1c>)
  400b44:	3000      	adds	r0, #0
  400b46:	bf18      	it	ne
  400b48:	2001      	movne	r0, #1
  400b4a:	4b04      	ldr	r3, [pc, #16]	; (400b5c <_pio_get_hardware_index+0x20>)
  400b4c:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  400b4e:	4804      	ldr	r0, [pc, #16]	; (400b60 <_pio_get_hardware_index+0x24>)
  400b50:	4420      	add	r0, r4
}
  400b52:	f3c0 2047 	ubfx	r0, r0, #9, #8
  400b56:	bd10      	pop	{r4, pc}
  400b58:	00401ee0 	.word	0x00401ee0
  400b5c:	004009ad 	.word	0x004009ad
  400b60:	bff1f200 	.word	0xbff1f200

00400b64 <_pio_get_index>:
{
  400b64:	b510      	push	{r4, lr}
	ASSERT(hw);
  400b66:	4604      	mov	r4, r0
  400b68:	22e0      	movs	r2, #224	; 0xe0
  400b6a:	490d      	ldr	r1, [pc, #52]	; (400ba0 <_pio_get_index+0x3c>)
  400b6c:	3000      	adds	r0, #0
  400b6e:	bf18      	it	ne
  400b70:	2001      	movne	r0, #1
  400b72:	4b0c      	ldr	r3, [pc, #48]	; (400ba4 <_pio_get_index+0x40>)
  400b74:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  400b76:	4620      	mov	r0, r4
  400b78:	4b0b      	ldr	r3, [pc, #44]	; (400ba8 <_pio_get_index+0x44>)
  400b7a:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400b7c:	2300      	movs	r3, #0
  400b7e:	2b01      	cmp	r3, #1
  400b80:	d80b      	bhi.n	400b9a <_pio_get_index+0x36>
		if (_ext_irq[i].number == offset) {
  400b82:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  400b86:	008a      	lsls	r2, r1, #2
  400b88:	4908      	ldr	r1, [pc, #32]	; (400bac <_pio_get_index+0x48>)
  400b8a:	5c8a      	ldrb	r2, [r1, r2]
  400b8c:	4290      	cmp	r0, r2
  400b8e:	d002      	beq.n	400b96 <_pio_get_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400b90:	3301      	adds	r3, #1
  400b92:	b2db      	uxtb	r3, r3
  400b94:	e7f3      	b.n	400b7e <_pio_get_index+0x1a>
			return i;
  400b96:	b258      	sxtb	r0, r3
  400b98:	bd10      	pop	{r4, pc}
	return ERR_INVALID_DATA;
  400b9a:	f04f 30ff 	mov.w	r0, #4294967295
}
  400b9e:	bd10      	pop	{r4, pc}
  400ba0:	00401ee0 	.word	0x00401ee0
  400ba4:	004009ad 	.word	0x004009ad
  400ba8:	00400b3d 	.word	0x00400b3d
  400bac:	00401ea0 	.word	0x00401ea0

00400bb0 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400bb0:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400bb2:	4604      	mov	r4, r0
  400bb4:	f240 1259 	movw	r2, #345	; 0x159
  400bb8:	4929      	ldr	r1, [pc, #164]	; (400c60 <_pio_init+0xb0>)
  400bba:	3000      	adds	r0, #0
  400bbc:	bf18      	it	ne
  400bbe:	2001      	movne	r0, #1
  400bc0:	4b28      	ldr	r3, [pc, #160]	; (400c64 <_pio_init+0xb4>)
  400bc2:	4798      	blx	r3

	i = _pio_get_index(hw);
  400bc4:	4620      	mov	r0, r4
  400bc6:	4b28      	ldr	r3, [pc, #160]	; (400c68 <_pio_init+0xb8>)
  400bc8:	4798      	blx	r3
	if (i < 0) {
  400bca:	2800      	cmp	r0, #0
  400bcc:	db43      	blt.n	400c56 <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  400bce:	4d27      	ldr	r5, [pc, #156]	; (400c6c <_pio_init+0xbc>)
  400bd0:	00c2      	lsls	r2, r0, #3
  400bd2:	1a11      	subs	r1, r2, r0
  400bd4:	008b      	lsls	r3, r1, #2
  400bd6:	442b      	add	r3, r5
  400bd8:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  400bda:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  400bde:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400be0:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400be4:	6919      	ldr	r1, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  400be6:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
  400bea:	699b      	ldr	r3, [r3, #24]
	((Pio *)hw)->PIO_FELLSR = mask;
  400bec:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400bf0:	1a10      	subs	r0, r2, r0
  400bf2:	0083      	lsls	r3, r0, #2
  400bf4:	442b      	add	r3, r5
  400bf6:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  400bf8:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  400bfc:	4620      	mov	r0, r4
  400bfe:	4b1c      	ldr	r3, [pc, #112]	; (400c70 <_pio_init+0xc0>)
  400c00:	4798      	blx	r3
  400c02:	4428      	add	r0, r5
  400c04:	f990 3038 	ldrsb.w	r3, [r0, #56]	; 0x38
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400c08:	2b00      	cmp	r3, #0
  400c0a:	db0c      	blt.n	400c26 <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c0c:	095a      	lsrs	r2, r3, #5
  400c0e:	f003 001f 	and.w	r0, r3, #31
  400c12:	2101      	movs	r1, #1
  400c14:	4081      	lsls	r1, r0
  400c16:	3220      	adds	r2, #32
  400c18:	4816      	ldr	r0, [pc, #88]	; (400c74 <_pio_init+0xc4>)
  400c1a:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  400c1e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400c22:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400c26:	2b00      	cmp	r3, #0
  400c28:	db08      	blt.n	400c3c <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c2a:	095a      	lsrs	r2, r3, #5
  400c2c:	f003 001f 	and.w	r0, r3, #31
  400c30:	2101      	movs	r1, #1
  400c32:	4081      	lsls	r1, r0
  400c34:	3260      	adds	r2, #96	; 0x60
  400c36:	480f      	ldr	r0, [pc, #60]	; (400c74 <_pio_init+0xc4>)
  400c38:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  400c3c:	2b00      	cmp	r3, #0
  400c3e:	db0d      	blt.n	400c5c <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c40:	0959      	lsrs	r1, r3, #5
  400c42:	f003 031f 	and.w	r3, r3, #31
  400c46:	2201      	movs	r2, #1
  400c48:	fa02 f303 	lsl.w	r3, r2, r3
  400c4c:	4a09      	ldr	r2, [pc, #36]	; (400c74 <_pio_init+0xc4>)
  400c4e:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  400c52:	2000      	movs	r0, #0
  400c54:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  400c56:	f06f 0010 	mvn.w	r0, #16
  400c5a:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  400c5c:	2000      	movs	r0, #0
}
  400c5e:	bd38      	pop	{r3, r4, r5, pc}
  400c60:	00401ee0 	.word	0x00401ee0
  400c64:	004009ad 	.word	0x004009ad
  400c68:	00400b65 	.word	0x00400b65
  400c6c:	00401ea0 	.word	0x00401ea0
  400c70:	00400b3d 	.word	0x00400b3d
  400c74:	e000e100 	.word	0xe000e100

00400c78 <PIOA_Handler>:
{
  400c78:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400c7a:	4b01      	ldr	r3, [pc, #4]	; (400c80 <PIOA_Handler+0x8>)
  400c7c:	4798      	blx	r3
  400c7e:	bd08      	pop	{r3, pc}
  400c80:	00400a8d 	.word	0x00400a8d

00400c84 <PIOB_Handler>:
{
  400c84:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400c86:	4b01      	ldr	r3, [pc, #4]	; (400c8c <PIOB_Handler+0x8>)
  400c88:	4798      	blx	r3
  400c8a:	bd08      	pop	{r3, pc}
  400c8c:	00400a8d 	.word	0x00400a8d

00400c90 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400c90:	b538      	push	{r3, r4, r5, lr}
  400c92:	4605      	mov	r5, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  400c94:	4804      	ldr	r0, [pc, #16]	; (400ca8 <_ext_irq_init+0x18>)
  400c96:	4c05      	ldr	r4, [pc, #20]	; (400cac <_ext_irq_init+0x1c>)
  400c98:	47a0      	blx	r4
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	_pio_init(PIOB);
  400c9a:	4805      	ldr	r0, [pc, #20]	; (400cb0 <_ext_irq_init+0x20>)
  400c9c:	47a0      	blx	r4

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  400c9e:	4b05      	ldr	r3, [pc, #20]	; (400cb4 <_ext_irq_init+0x24>)
  400ca0:	601d      	str	r5, [r3, #0]

	return ERR_NONE;
}
  400ca2:	2000      	movs	r0, #0
  400ca4:	bd38      	pop	{r3, r4, r5, pc}
  400ca6:	bf00      	nop
  400ca8:	400e0e00 	.word	0x400e0e00
  400cac:	00400bb1 	.word	0x00400bb1
  400cb0:	400e1000 	.word	0x400e1000
  400cb4:	20400098 	.word	0x20400098

00400cb8 <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400cb8:	490e      	ldr	r1, [pc, #56]	; (400cf4 <_pmc_init_sources+0x3c>)
  400cba:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400cbc:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400cc0:	4b0d      	ldr	r3, [pc, #52]	; (400cf8 <_pmc_init_sources+0x40>)
  400cc2:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400cc4:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400cc6:	4b0b      	ldr	r3, [pc, #44]	; (400cf4 <_pmc_init_sources+0x3c>)
  400cc8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400cca:	f013 0f01 	tst.w	r3, #1
  400cce:	d0fa      	beq.n	400cc6 <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400cd0:	4b08      	ldr	r3, [pc, #32]	; (400cf4 <_pmc_init_sources+0x3c>)
  400cd2:	6a19      	ldr	r1, [r3, #32]
  400cd4:	4a09      	ldr	r2, [pc, #36]	; (400cfc <_pmc_init_sources+0x44>)
  400cd6:	430a      	orrs	r2, r1
  400cd8:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400cda:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400cdc:	4a08      	ldr	r2, [pc, #32]	; (400d00 <_pmc_init_sources+0x48>)
  400cde:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400ce0:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  400ce2:	4a08      	ldr	r2, [pc, #32]	; (400d04 <_pmc_init_sources+0x4c>)
  400ce4:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400ce6:	4b03      	ldr	r3, [pc, #12]	; (400cf4 <_pmc_init_sources+0x3c>)
  400ce8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400cea:	f013 0f02 	tst.w	r3, #2
  400cee:	d0fa      	beq.n	400ce6 <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  400cf0:	4770      	bx	lr
  400cf2:	bf00      	nop
  400cf4:	400e0600 	.word	0x400e0600
  400cf8:	00373e01 	.word	0x00373e01
  400cfc:	01370000 	.word	0x01370000
  400d00:	f800ffff 	.word	0xf800ffff
  400d04:	20183f01 	.word	0x20183f01

00400d08 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d08:	4a11      	ldr	r2, [pc, #68]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d0a:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400d0c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d10:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d12:	4b0f      	ldr	r3, [pc, #60]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d16:	f013 0f08 	tst.w	r3, #8
  400d1a:	d0fa      	beq.n	400d12 <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d1c:	4a0c      	ldr	r2, [pc, #48]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d1e:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  400d20:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  400d24:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d28:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d2a:	4b09      	ldr	r3, [pc, #36]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d2c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d2e:	f013 0f08 	tst.w	r3, #8
  400d32:	d0fa      	beq.n	400d2a <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d34:	4a06      	ldr	r2, [pc, #24]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d36:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400d38:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400d3c:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d40:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d42:	4b03      	ldr	r3, [pc, #12]	; (400d50 <_pmc_init_master_clock+0x48>)
  400d44:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d46:	f013 0f08 	tst.w	r3, #8
  400d4a:	d0fa      	beq.n	400d42 <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  400d4c:	4770      	bx	lr
  400d4e:	bf00      	nop
  400d50:	400e0600 	.word	0x400e0600

00400d54 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  400d54:	b508      	push	{r3, lr}
	_pmc_init_sources();
  400d56:	4b02      	ldr	r3, [pc, #8]	; (400d60 <_pmc_init+0xc>)
  400d58:	4798      	blx	r3
	_pmc_init_master_clock();
  400d5a:	4b02      	ldr	r3, [pc, #8]	; (400d64 <_pmc_init+0x10>)
  400d5c:	4798      	blx	r3
  400d5e:	bd08      	pop	{r3, pc}
  400d60:	00400cb9 	.word	0x00400cb9
  400d64:	00400d09 	.word	0x00400d09

00400d68 <_spi_sync_enable>:
}

static inline void hri_spi_write_CR_reg(const void *const hw, hri_spi_cr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_CR = data;
  400d68:	2301      	movs	r3, #1
  400d6a:	6003      	str	r3, [r0, #0]
static int32_t _spi_sync_enable(void *const hw)
{
	hri_spi_write_CR_reg(hw, SPI_CR_SPIEN);

	return ERR_NONE;
}
  400d6c:	2000      	movs	r0, #0
  400d6e:	4770      	bx	lr

00400d70 <_spi_get_hardware_index>:
 * \brief Retrieve ordinal number of the given SPI hardware instance
 */
static uint8_t _spi_get_hardware_index(const void *const hw)
{

	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  400d70:	4b04      	ldr	r3, [pc, #16]	; (400d84 <_spi_get_hardware_index+0x14>)
  400d72:	4403      	add	r3, r0
  400d74:	f3c3 4307 	ubfx	r3, r3, #16, #8

	if (index == 5) {
  400d78:	2b05      	cmp	r3, #5
  400d7a:	d001      	beq.n	400d80 <_spi_get_hardware_index+0x10>
		return 1;
	} else {
		return 0;
  400d7c:	2000      	movs	r0, #0
	}
}
  400d7e:	4770      	bx	lr
		return 1;
  400d80:	2001      	movs	r0, #1
  400d82:	4770      	bx	lr
  400d84:	bfff8000 	.word	0xbfff8000

00400d88 <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  400d88:	b570      	push	{r4, r5, r6, lr}
  400d8a:	4606      	mov	r6, r0
  400d8c:	460c      	mov	r4, r1
	uint8_t n = _spi_get_hardware_index((const void *)hw_addr);
  400d8e:	4608      	mov	r0, r1
  400d90:	4b20      	ldr	r3, [pc, #128]	; (400e14 <_spi_m_sync_init+0x8c>)
  400d92:	4798      	blx	r3
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  400d94:	2300      	movs	r3, #0
  400d96:	b33b      	cbz	r3, 400de8 <_spi_m_sync_init+0x60>
	return NULL;
  400d98:	2500      	movs	r5, #0
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  400d9a:	f44f 729a 	mov.w	r2, #308	; 0x134
  400d9e:	491e      	ldr	r1, [pc, #120]	; (400e18 <_spi_m_sync_init+0x90>)
  400da0:	2e00      	cmp	r6, #0
  400da2:	bf18      	it	ne
  400da4:	2c00      	cmpne	r4, #0
  400da6:	bf14      	ite	ne
  400da8:	2001      	movne	r0, #1
  400daa:	2000      	moveq	r0, #0
  400dac:	4b1b      	ldr	r3, [pc, #108]	; (400e1c <_spi_m_sync_init+0x94>)
  400dae:	4798      	blx	r3

	if (regs == NULL) {
  400db0:	b355      	cbz	r5, 400e08 <_spi_m_sync_init+0x80>
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  400db2:	6923      	ldr	r3, [r4, #16]
		return ERR_INVALID_ARG;
	}

	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  400db4:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400db8:	d129      	bne.n	400e0e <_spi_m_sync_init+0x86>
	((Spi *)hw)->SPI_CR = data;
  400dba:	2380      	movs	r3, #128	; 0x80
  400dbc:	6023      	str	r3, [r4, #0]
		return ERR_DENIED;
	}
	hri_spi_write_CR_reg(hw, SPI_CR_SWRST);
	dev->prvt = hw;
  400dbe:	6034      	str	r4, [r6, #0]
	hri_spi_write_CR_reg(hw, (regs->cr & ~(SPI_CR_SPIEN | SPI_CR_SPIDIS | SPI_CR_SWRST | SPI_CR_LASTXFER)));
  400dc0:	686a      	ldr	r2, [r5, #4]
  400dc2:	4b17      	ldr	r3, [pc, #92]	; (400e20 <_spi_m_sync_init+0x98>)
  400dc4:	4013      	ands	r3, r2
  400dc6:	6023      	str	r3, [r4, #0]
	hri_spi_write_MR_reg(hw, ((regs->mr | SPI_MR_PCS(0x0E) | SPI_MR_MODFDIS) & ~SPI_MR_LLB));
  400dc8:	68ab      	ldr	r3, [r5, #8]
  400dca:	4a16      	ldr	r2, [pc, #88]	; (400e24 <_spi_m_sync_init+0x9c>)
  400dcc:	401a      	ands	r2, r3
  400dce:	4b16      	ldr	r3, [pc, #88]	; (400e28 <_spi_m_sync_init+0xa0>)
  400dd0:	4313      	orrs	r3, r2
	((Spi *)hw)->SPI_MR = data;
  400dd2:	6063      	str	r3, [r4, #4]
	hri_spi_write_CSR_reg(hw, 0, regs->csr);
  400dd4:	68eb      	ldr	r3, [r5, #12]
	((Spi *)hw)->SPI_CSR[index] = data;
  400dd6:	6323      	str	r3, [r4, #48]	; 0x30

	dev->dummy_byte = regs->dummy_byte;
  400dd8:	8a2b      	ldrh	r3, [r5, #16]
  400dda:	80f3      	strh	r3, [r6, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  400ddc:	68eb      	ldr	r3, [r5, #12]
  400dde:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  400de2:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
  400de4:	2000      	movs	r0, #0
  400de6:	bd70      	pop	{r4, r5, r6, pc}
		if (spi_regs[i].number == n) {
  400de8:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  400dec:	008a      	lsls	r2, r1, #2
  400dee:	490f      	ldr	r1, [pc, #60]	; (400e2c <_spi_m_sync_init+0xa4>)
  400df0:	5c8a      	ldrb	r2, [r1, r2]
  400df2:	4290      	cmp	r0, r2
  400df4:	d002      	beq.n	400dfc <_spi_m_sync_init+0x74>
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  400df6:	3301      	adds	r3, #1
  400df8:	b2db      	uxtb	r3, r3
  400dfa:	e7cc      	b.n	400d96 <_spi_m_sync_init+0xe>
			return &spi_regs[i];
  400dfc:	eb03 0583 	add.w	r5, r3, r3, lsl #2
  400e00:	00ab      	lsls	r3, r5, #2
  400e02:	460d      	mov	r5, r1
  400e04:	441d      	add	r5, r3
  400e06:	e7c8      	b.n	400d9a <_spi_m_sync_init+0x12>
		return ERR_INVALID_ARG;
  400e08:	f06f 000c 	mvn.w	r0, #12
  400e0c:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
  400e0e:	f06f 0010 	mvn.w	r0, #16
}
  400e12:	bd70      	pop	{r4, r5, r6, pc}
  400e14:	00400d71 	.word	0x00400d71
  400e18:	00401f10 	.word	0x00401f10
  400e1c:	004009ad 	.word	0x004009ad
  400e20:	feffff7c 	.word	0xfeffff7c
  400e24:	fff1ff6f 	.word	0xfff1ff6f
  400e28:	000e0010 	.word	0x000e0010
  400e2c:	00401efc 	.word	0x00401efc

00400e30 <_spi_m_sync_enable>:

	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
  400e30:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  400e32:	4604      	mov	r4, r0
  400e34:	b168      	cbz	r0, 400e52 <_spi_m_sync_enable+0x22>
  400e36:	6803      	ldr	r3, [r0, #0]
  400e38:	b14b      	cbz	r3, 400e4e <_spi_m_sync_enable+0x1e>
  400e3a:	2001      	movs	r0, #1
  400e3c:	f44f 72b9 	mov.w	r2, #370	; 0x172
  400e40:	4905      	ldr	r1, [pc, #20]	; (400e58 <_spi_m_sync_enable+0x28>)
  400e42:	4b06      	ldr	r3, [pc, #24]	; (400e5c <_spi_m_sync_enable+0x2c>)
  400e44:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
  400e46:	6820      	ldr	r0, [r4, #0]
  400e48:	4b05      	ldr	r3, [pc, #20]	; (400e60 <_spi_m_sync_enable+0x30>)
  400e4a:	4798      	blx	r3
}
  400e4c:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
  400e4e:	2000      	movs	r0, #0
  400e50:	e7f4      	b.n	400e3c <_spi_m_sync_enable+0xc>
  400e52:	2000      	movs	r0, #0
  400e54:	e7f2      	b.n	400e3c <_spi_m_sync_enable+0xc>
  400e56:	bf00      	nop
  400e58:	00401f10 	.word	0x00401f10
  400e5c:	004009ad 	.word	0x004009ad
  400e60:	00400d69 	.word	0x00400d69

00400e64 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
  400e64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400e68:	b086      	sub	sp, #24
  400e6a:	4607      	mov	r7, r0
  400e6c:	460d      	mov	r5, r1
	void *                 hw   = dev->prvt;
  400e6e:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
  400e70:	680b      	ldr	r3, [r1, #0]
  400e72:	9301      	str	r3, [sp, #4]
  400e74:	684b      	ldr	r3, [r1, #4]
  400e76:	9302      	str	r3, [sp, #8]
  400e78:	2300      	movs	r3, #0
  400e7a:	9303      	str	r3, [sp, #12]
  400e7c:	9304      	str	r3, [sp, #16]
  400e7e:	7903      	ldrb	r3, [r0, #4]
  400e80:	f88d 3014 	strb.w	r3, [sp, #20]

	ASSERT(dev && hw);
  400e84:	1c26      	adds	r6, r4, #0
  400e86:	bf18      	it	ne
  400e88:	2601      	movne	r6, #1
  400e8a:	f240 2231 	movw	r2, #561	; 0x231
  400e8e:	4933      	ldr	r1, [pc, #204]	; (400f5c <_spi_m_sync_trans+0xf8>)
  400e90:	2800      	cmp	r0, #0
  400e92:	bf0c      	ite	eq
  400e94:	2000      	moveq	r0, #0
  400e96:	f006 0001 	andne.w	r0, r6, #1
  400e9a:	4b31      	ldr	r3, [pc, #196]	; (400f60 <_spi_m_sync_trans+0xfc>)
  400e9c:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  400e9e:	6923      	ldr	r3, [r4, #16]

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_spi_get_SR_SPIENS_bit(hw)) {
  400ea0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400ea4:	d122      	bne.n	400eec <_spi_m_sync_trans+0x88>
		return ERR_NOT_INITIALIZED;
  400ea6:	f06f 0013 	mvn.w	r0, #19
  400eaa:	e053      	b.n	400f54 <_spi_m_sync_trans+0xf0>
		return false;
  400eac:	2300      	movs	r3, #0
  400eae:	e035      	b.n	400f1c <_spi_m_sync_trans+0xb8>
			data |= (*ctrl->txbuf) << 8;
  400eb0:	7850      	ldrb	r0, [r2, #1]
  400eb2:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			ctrl->txbuf++;
  400eb6:	3202      	adds	r2, #2
  400eb8:	9201      	str	r2, [sp, #4]
	ctrl->txcnt++;
  400eba:	3301      	adds	r3, #1
  400ebc:	9303      	str	r3, [sp, #12]
}

static inline void hri_spi_write_TDR_reg(const void *const hw, hri_spi_tdr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_TDR = data;
  400ebe:	60e1      	str	r1, [r4, #12]
	return ((Spi *)hw)->SPI_SR;
  400ec0:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ASSERT(hw);
  400ec4:	f240 2222 	movw	r2, #546	; 0x222
  400ec8:	4924      	ldr	r1, [pc, #144]	; (400f5c <_spi_m_sync_trans+0xf8>)
  400eca:	4630      	mov	r0, r6
  400ecc:	4b24      	ldr	r3, [pc, #144]	; (400f60 <_spi_m_sync_trans+0xfc>)
  400ece:	4798      	blx	r3
	if (SPI_SR_OVRES & iflag) {
  400ed0:	f018 0f08 	tst.w	r8, #8
  400ed4:	d038      	beq.n	400f48 <_spi_m_sync_trans+0xe4>
		return ERR_OVERFLOW;
  400ed6:	f06f 0012 	mvn.w	r0, #18
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
			}
		}
		rc = _spi_err_check(hri_spi_read_SR_reg(hw), hw);
		if (rc < 0) {
  400eda:	2800      	cmp	r0, #0
  400edc:	db36      	blt.n	400f4c <_spi_m_sync_trans+0xe8>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
  400ede:	9803      	ldr	r0, [sp, #12]
  400ee0:	68ab      	ldr	r3, [r5, #8]
  400ee2:	4298      	cmp	r0, r3
  400ee4:	d302      	bcc.n	400eec <_spi_m_sync_trans+0x88>
  400ee6:	9a04      	ldr	r2, [sp, #16]
  400ee8:	4293      	cmp	r3, r2
  400eea:	d92f      	bls.n	400f4c <_spi_m_sync_trans+0xe8>
  400eec:	6923      	ldr	r3, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_RDRF)) {
  400eee:	f013 0f01 	tst.w	r3, #1
  400ef2:	d0db      	beq.n	400eac <_spi_m_sync_trans+0x48>
	return (((Spi *)hw)->SPI_RDR & SPI_RDR_RD_Msk) >> SPI_RDR_RD_Pos;
  400ef4:	68a3      	ldr	r3, [r4, #8]
  400ef6:	b29b      	uxth	r3, r3
	if (ctrl->rxbuf) {
  400ef8:	9a02      	ldr	r2, [sp, #8]
  400efa:	b15a      	cbz	r2, 400f14 <_spi_m_sync_trans+0xb0>
		*ctrl->rxbuf++ = (uint8_t)data;
  400efc:	1c51      	adds	r1, r2, #1
  400efe:	9102      	str	r1, [sp, #8]
  400f00:	7013      	strb	r3, [r2, #0]
		if (ctrl->char_size > 1) {
  400f02:	f89d 2014 	ldrb.w	r2, [sp, #20]
  400f06:	2a01      	cmp	r2, #1
  400f08:	d904      	bls.n	400f14 <_spi_m_sync_trans+0xb0>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
  400f0a:	460a      	mov	r2, r1
  400f0c:	3101      	adds	r1, #1
  400f0e:	9102      	str	r1, [sp, #8]
  400f10:	0a1b      	lsrs	r3, r3, #8
  400f12:	7013      	strb	r3, [r2, #0]
	ctrl->rxcnt++;
  400f14:	9b04      	ldr	r3, [sp, #16]
  400f16:	3301      	adds	r3, #1
  400f18:	9304      	str	r3, [sp, #16]
	return true;
  400f1a:	2301      	movs	r3, #1
		if (!_spi_rx_check_and_receive(hw, &ctrl)) {
  400f1c:	2b00      	cmp	r3, #0
  400f1e:	d1cf      	bne.n	400ec0 <_spi_m_sync_trans+0x5c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
  400f20:	9b03      	ldr	r3, [sp, #12]
  400f22:	9a04      	ldr	r2, [sp, #16]
  400f24:	429a      	cmp	r2, r3
  400f26:	d3cb      	bcc.n	400ec0 <_spi_m_sync_trans+0x5c>
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
  400f28:	88f9      	ldrh	r1, [r7, #6]
	return ((Spi *)hw)->SPI_SR;
  400f2a:	6922      	ldr	r2, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_TDRE)) {
  400f2c:	f012 0f02 	tst.w	r2, #2
  400f30:	d0c6      	beq.n	400ec0 <_spi_m_sync_trans+0x5c>
	if (ctrl->txbuf) {
  400f32:	9a01      	ldr	r2, [sp, #4]
  400f34:	2a00      	cmp	r2, #0
  400f36:	d0c0      	beq.n	400eba <_spi_m_sync_trans+0x56>
		data = *ctrl->txbuf++;
  400f38:	1c51      	adds	r1, r2, #1
  400f3a:	9101      	str	r1, [sp, #4]
  400f3c:	7811      	ldrb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
  400f3e:	f89d 0014 	ldrb.w	r0, [sp, #20]
  400f42:	2801      	cmp	r0, #1
  400f44:	d8b4      	bhi.n	400eb0 <_spi_m_sync_trans+0x4c>
  400f46:	e7b8      	b.n	400eba <_spi_m_sync_trans+0x56>
	return ERR_NONE;
  400f48:	2000      	movs	r0, #0
  400f4a:	e7c6      	b.n	400eda <_spi_m_sync_trans+0x76>
	tmp = ((Spi *)hw)->SPI_SR;
  400f4c:	6923      	ldr	r3, [r4, #16]
	while (!(hri_spi_get_SR_reg(hw, SPI_SR_TXEMPTY))) {
  400f4e:	f413 7f00 	tst.w	r3, #512	; 0x200
  400f52:	d0fb      	beq.n	400f4c <_spi_m_sync_trans+0xe8>

	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
  400f54:	b006      	add	sp, #24
  400f56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400f5a:	bf00      	nop
  400f5c:	00401f10 	.word	0x00401f10
  400f60:	004009ad 	.word	0x004009ad

00400f64 <_spi_get_spi_m_sync>:
 * \brief Retrieve usart sync helper functions
 */
void *_spi_get_spi_m_sync(void)
{
	return (void *)NULL;
}
  400f64:	2000      	movs	r0, #0
  400f66:	4770      	bx	lr

00400f68 <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  400f68:	4b03      	ldr	r3, [pc, #12]	; (400f78 <_system_time_init+0x10>)
  400f6a:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  400f6e:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  400f70:	2205      	movs	r2, #5
  400f72:	601a      	str	r2, [r3, #0]
  400f74:	4770      	bx	lr
  400f76:	bf00      	nop
  400f78:	e000e010 	.word	0xe000e010

00400f7c <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  400f7c:	b508      	push	{r3, lr}
	_system_time_init(hw);
  400f7e:	4b01      	ldr	r3, [pc, #4]	; (400f84 <_delay_init+0x8>)
  400f80:	4798      	blx	r3
  400f82:	bd08      	pop	{r3, pc}
  400f84:	00400f69 	.word	0x00400f69

00400f88 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
  400f88:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
  400f8a:	e00d      	b.n	400fa8 <_delay_cycles+0x20>
		SysTick->LOAD = 0xFFFFFF;
  400f8c:	4b0d      	ldr	r3, [pc, #52]	; (400fc4 <_delay_cycles+0x3c>)
  400f8e:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
  400f92:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
  400f94:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  400f96:	4b0b      	ldr	r3, [pc, #44]	; (400fc4 <_delay_cycles+0x3c>)
  400f98:	681b      	ldr	r3, [r3, #0]
  400f9a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400f9e:	d0fa      	beq.n	400f96 <_delay_cycles+0xe>
			;
		buf -= 0xFFFFFF;
  400fa0:	f101 417f 	add.w	r1, r1, #4278190080	; 0xff000000
  400fa4:	3101      	adds	r1, #1
	while (n--) {
  400fa6:	4610      	mov	r0, r2
  400fa8:	1e43      	subs	r3, r0, #1
  400faa:	b2da      	uxtb	r2, r3
  400fac:	2800      	cmp	r0, #0
  400fae:	d1ed      	bne.n	400f8c <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
  400fb0:	4b04      	ldr	r3, [pc, #16]	; (400fc4 <_delay_cycles+0x3c>)
  400fb2:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
  400fb4:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  400fb6:	4b03      	ldr	r3, [pc, #12]	; (400fc4 <_delay_cycles+0x3c>)
  400fb8:	681b      	ldr	r3, [r3, #0]
  400fba:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400fbe:	d0fa      	beq.n	400fb6 <_delay_cycles+0x2e>
		;
}
  400fc0:	4770      	bx	lr
  400fc2:	bf00      	nop
  400fc4:	e000e010 	.word	0xe000e010

00400fc8 <_get_i2cm_sync_cfg>:
 */
static const struct _i2cm_sync_cfg *_get_i2cm_sync_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  400fc8:	2300      	movs	r3, #0
  400fca:	b13b      	cbz	r3, 400fdc <_get_i2cm_sync_cfg+0x14>
		if (_i2cm_sync_cfgs[i].hw == hw) {
			return &(_i2cm_sync_cfgs[i]);
		}
	}
	return NULL;
  400fcc:	2000      	movs	r0, #0
  400fce:	4770      	bx	lr
			return &(_i2cm_sync_cfgs[i]);
  400fd0:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  400fd4:	00e3      	lsls	r3, r4, #3
  400fd6:	4608      	mov	r0, r1
  400fd8:	4418      	add	r0, r3
  400fda:	e00c      	b.n	400ff6 <_get_i2cm_sync_cfg+0x2e>
{
  400fdc:	b410      	push	{r4}
		if (_i2cm_sync_cfgs[i].hw == hw) {
  400fde:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  400fe2:	00ca      	lsls	r2, r1, #3
  400fe4:	4905      	ldr	r1, [pc, #20]	; (400ffc <_get_i2cm_sync_cfg+0x34>)
  400fe6:	588a      	ldr	r2, [r1, r2]
  400fe8:	4282      	cmp	r2, r0
  400fea:	d0f1      	beq.n	400fd0 <_get_i2cm_sync_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  400fec:	3301      	adds	r3, #1
  400fee:	b2db      	uxtb	r3, r3
  400ff0:	2b00      	cmp	r3, #0
  400ff2:	d0f4      	beq.n	400fde <_get_i2cm_sync_cfg+0x16>
	return NULL;
  400ff4:	2000      	movs	r0, #0
}
  400ff6:	f85d 4b04 	ldr.w	r4, [sp], #4
  400ffa:	4770      	bx	lr
  400ffc:	00401f28 	.word	0x00401f28

00401000 <_i2c_m_sync_init>:

int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const dev, void *const hw)
{
  401000:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && hw);
  401002:	4604      	mov	r4, r0
  401004:	460d      	mov	r5, r1
  401006:	2800      	cmp	r0, #0
  401008:	bf18      	it	ne
  40100a:	2900      	cmpne	r1, #0
  40100c:	bf14      	ite	ne
  40100e:	2001      	movne	r0, #1
  401010:	2000      	moveq	r0, #0
  401012:	2278      	movs	r2, #120	; 0x78
  401014:	4909      	ldr	r1, [pc, #36]	; (40103c <_i2c_m_sync_init+0x3c>)
  401016:	4b0a      	ldr	r3, [pc, #40]	; (401040 <_i2c_m_sync_init+0x40>)
  401018:	4798      	blx	r3

	const struct _i2cm_sync_cfg *cfg;

	dev->hw = hw;
  40101a:	6125      	str	r5, [r4, #16]
	cfg     = _get_i2cm_sync_cfg(dev->hw);
  40101c:	4628      	mov	r0, r5
  40101e:	4b09      	ldr	r3, [pc, #36]	; (401044 <_i2c_m_sync_init+0x44>)
  401020:	4798      	blx	r3

	// hri_twihs_write_CR_reg(hw, TWIHS_CR_SWRST);
	// hri_twihs_read_RHR_reg(hw);
	hri_twihs_write_CR_reg(dev->hw, cfg->ctrl);
  401022:	6843      	ldr	r3, [r0, #4]
}

static inline void hri_twihs_write_CR_reg(const void *const hw, hri_twihs_cr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_CR = data;
  401024:	602b      	str	r3, [r5, #0]
	hri_twihs_write_SMBTR_reg(dev->hw, cfg->smbtr);
  401026:	6923      	ldr	r3, [r4, #16]
  401028:	6882      	ldr	r2, [r0, #8]
	((Twihs *)hw)->TWIHS_SMBTR = data;
  40102a:	639a      	str	r2, [r3, #56]	; 0x38
	hri_twihs_write_FILTR_reg(dev->hw, cfg->filtr);
  40102c:	6923      	ldr	r3, [r4, #16]
  40102e:	68c2      	ldr	r2, [r0, #12]
	((Twihs *)hw)->TWIHS_FILTR = data;
  401030:	645a      	str	r2, [r3, #68]	; 0x44
	hri_twihs_write_CWGR_reg(dev->hw, cfg->cwgr);
  401032:	6923      	ldr	r3, [r4, #16]
  401034:	6902      	ldr	r2, [r0, #16]
	((Twihs *)hw)->TWIHS_CWGR = data;
  401036:	611a      	str	r2, [r3, #16]

	return ERR_NONE;
}
  401038:	2000      	movs	r0, #0
  40103a:	bd38      	pop	{r3, r4, r5, pc}
  40103c:	00401f40 	.word	0x00401f40
  401040:	004009ad 	.word	0x004009ad
  401044:	00400fc9 	.word	0x00400fc9

00401048 <_i2c_m_sync_transfer>:

	return ERR_NONE;
}

int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
  401048:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && msg);
  40104a:	4604      	mov	r4, r0
  40104c:	460d      	mov	r5, r1
  40104e:	2800      	cmp	r0, #0
  401050:	bf18      	it	ne
  401052:	2900      	cmpne	r1, #0
  401054:	bf14      	ite	ne
  401056:	2001      	movne	r0, #1
  401058:	2000      	moveq	r0, #0
  40105a:	22ba      	movs	r2, #186	; 0xba
  40105c:	4952      	ldr	r1, [pc, #328]	; (4011a8 <_i2c_m_sync_transfer+0x160>)
  40105e:	4b53      	ldr	r3, [pc, #332]	; (4011ac <_i2c_m_sync_transfer+0x164>)
  401060:	4798      	blx	r3

	if (dev->service.msg.flags & I2C_M_BUSY) {
  401062:	8863      	ldrh	r3, [r4, #2]
  401064:	f413 7f80 	tst.w	r3, #256	; 0x100
  401068:	f040 809a 	bne.w	4011a0 <_i2c_m_sync_transfer+0x158>
		return I2C_ERR_BUSY;
	}

	if (msg->flags & I2C_M_RD) {
  40106c:	886b      	ldrh	r3, [r5, #2]
  40106e:	f013 0f01 	tst.w	r3, #1
  401072:	d118      	bne.n	4010a6 <_i2c_m_sync_transfer+0x5e>
{
	uint32_t i;
	uint32_t sr;
	int      ret = ERR_NONE;

	msg->flags |= I2C_M_BUSY;
  401074:	886b      	ldrh	r3, [r5, #2]
  401076:	b29b      	uxth	r3, r3
  401078:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  40107c:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  40107e:	882b      	ldrh	r3, [r5, #0]
  401080:	f413 6f80 	tst.w	r3, #1024	; 0x400
  401084:	d05f      	beq.n	401146 <_i2c_m_sync_transfer+0xfe>
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1));
  401086:	6922      	ldr	r2, [r4, #16]
  401088:	0a1b      	lsrs	r3, r3, #8
  40108a:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  40108e:	041b      	lsls	r3, r3, #16
  401090:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401094:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Twihs *)hw)->TWIHS_MMR = data;
  401098:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  40109a:	6923      	ldr	r3, [r4, #16]
  40109c:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  40109e:	60da      	str	r2, [r3, #12]
	for (i = 0; i < msg->len; i++) {
		/* Wait for data is transferred from TWIHS_THR or if NACK is detected */
		do {
			sr = hri_twihs_read_SR_reg(dev->hw);
			if (sr & TWIHS_SR_NACK) {
				ret = I2C_NACK;
  4010a0:	2000      	movs	r0, #0
  4010a2:	4601      	mov	r1, r0
  4010a4:	e05c      	b.n	401160 <_i2c_m_sync_transfer+0x118>

static inline int32_t _i2c_m_sync_read(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
	uint32_t i;

	msg->flags |= I2C_M_BUSY;
  4010a6:	886b      	ldrh	r3, [r5, #2]
  4010a8:	b29b      	uxth	r3, r3
  4010aa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4010ae:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  4010b0:	882b      	ldrh	r3, [r5, #0]
  4010b2:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4010b6:	d022      	beq.n	4010fe <_i2c_m_sync_transfer+0xb6>
		hri_twihs_write_MMR_reg(dev->hw,
  4010b8:	6922      	ldr	r2, [r4, #16]
		                        TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1) | TWIHS_MMR_MREAD);
  4010ba:	0a1b      	lsrs	r3, r3, #8
  4010bc:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  4010c0:	041b      	lsls	r3, r3, #16
  4010c2:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  4010c6:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
	((Twihs *)hw)->TWIHS_MMR = data;
  4010ca:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  4010cc:	6923      	ldr	r3, [r4, #16]
  4010ce:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  4010d0:	60da      	str	r2, [r3, #12]
	} else {
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
	}
	/* In single data byte master read, the START and STOP must both be set */
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  4010d2:	6923      	ldr	r3, [r4, #16]
  4010d4:	686a      	ldr	r2, [r5, #4]
  4010d6:	2a01      	cmp	r2, #1
  4010d8:	d019      	beq.n	40110e <_i2c_m_sync_transfer+0xc6>
  4010da:	2201      	movs	r2, #1
	((Twihs *)hw)->TWIHS_CR = data;
  4010dc:	601a      	str	r2, [r3, #0]

	for (i = 0; i < msg->len; i++) {
  4010de:	2100      	movs	r1, #0
  4010e0:	686b      	ldr	r3, [r5, #4]
  4010e2:	4299      	cmp	r1, r3
  4010e4:	d222      	bcs.n	40112c <_i2c_m_sync_transfer+0xe4>
		/* Wait for a byte has been received in TWIHS_RHR since last read */
		while (!hri_twihs_get_SR_RXRDY_bit(dev->hw)) {
  4010e6:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_RXRDY) > 0;
  4010e8:	6a1a      	ldr	r2, [r3, #32]
  4010ea:	f012 0f02 	tst.w	r2, #2
  4010ee:	d110      	bne.n	401112 <_i2c_m_sync_transfer+0xca>
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_NACK) > 0;
  4010f0:	6a1b      	ldr	r3, [r3, #32]
			/* Check whether slave acknowledge received after the address byte */
			if (hri_twihs_get_SR_NACK_bit(dev->hw))
  4010f2:	f413 7f80 	tst.w	r3, #256	; 0x100
  4010f6:	d0f6      	beq.n	4010e6 <_i2c_m_sync_transfer+0x9e>
				return I2C_NACK;
  4010f8:	f06f 0001 	mvn.w	r0, #1
		return _i2c_m_sync_read(dev, msg);
  4010fc:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
  4010fe:	6922      	ldr	r2, [r4, #16]
  401100:	041b      	lsls	r3, r3, #16
  401102:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401106:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Twihs *)hw)->TWIHS_MMR = data;
  40110a:	6053      	str	r3, [r2, #4]
  40110c:	e7e1      	b.n	4010d2 <_i2c_m_sync_transfer+0x8a>
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  40110e:	2203      	movs	r2, #3
  401110:	e7e4      	b.n	4010dc <_i2c_m_sync_transfer+0x94>
		};

		msg->buffer[i] = hri_twihs_read_RHR_reg(dev->hw);
  401112:	68aa      	ldr	r2, [r5, #8]
	return ((Twihs *)hw)->TWIHS_RHR;
  401114:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401116:	5453      	strb	r3, [r2, r1]
		/* In multiple data bytes master read, the STOP must be set after the
		 * last data received but one */
		if (i == (msg->len - 2)) {
  401118:	686b      	ldr	r3, [r5, #4]
  40111a:	3b02      	subs	r3, #2
  40111c:	4299      	cmp	r1, r3
  40111e:	d001      	beq.n	401124 <_i2c_m_sync_transfer+0xdc>
	for (i = 0; i < msg->len; i++) {
  401120:	3101      	adds	r1, #1
  401122:	e7dd      	b.n	4010e0 <_i2c_m_sync_transfer+0x98>
			hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401124:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401126:	2202      	movs	r2, #2
  401128:	601a      	str	r2, [r3, #0]
  40112a:	e7f9      	b.n	401120 <_i2c_m_sync_transfer+0xd8>
		}
	}

	while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  40112c:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  40112e:	6a1b      	ldr	r3, [r3, #32]
  401130:	f013 0f01 	tst.w	r3, #1
  401134:	d0fa      	beq.n	40112c <_i2c_m_sync_transfer+0xe4>
	};
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401136:	8863      	ldrh	r3, [r4, #2]
  401138:	b29b      	uxth	r3, r3
  40113a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  40113e:	b29b      	uxth	r3, r3
  401140:	8063      	strh	r3, [r4, #2]

	return ERR_NONE;
  401142:	2000      	movs	r0, #0
  401144:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr));
  401146:	6922      	ldr	r2, [r4, #16]
  401148:	041b      	lsls	r3, r3, #16
  40114a:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
	((Twihs *)hw)->TWIHS_MMR = data;
  40114e:	6053      	str	r3, [r2, #4]
  401150:	e7a6      	b.n	4010a0 <_i2c_m_sync_transfer+0x58>
				ret = I2C_NACK;
  401152:	f06f 0001 	mvn.w	r0, #1
		if (ret != ERR_NONE)
  401156:	b978      	cbnz	r0, 401178 <_i2c_m_sync_transfer+0x130>
		hri_twihs_write_THR_reg(dev->hw, msg->buffer[i]);
  401158:	68ab      	ldr	r3, [r5, #8]
  40115a:	5c5b      	ldrb	r3, [r3, r1]
}

static inline void hri_twihs_write_THR_reg(const void *const hw, hri_twihs_thr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_THR = data;
  40115c:	6353      	str	r3, [r2, #52]	; 0x34
	for (i = 0; i < msg->len; i++) {
  40115e:	3101      	adds	r1, #1
  401160:	686b      	ldr	r3, [r5, #4]
  401162:	4299      	cmp	r1, r3
  401164:	d208      	bcs.n	401178 <_i2c_m_sync_transfer+0x130>
			sr = hri_twihs_read_SR_reg(dev->hw);
  401166:	6922      	ldr	r2, [r4, #16]
	return ((Twihs *)hw)->TWIHS_SR;
  401168:	6a13      	ldr	r3, [r2, #32]
			if (sr & TWIHS_SR_NACK) {
  40116a:	f413 7f80 	tst.w	r3, #256	; 0x100
  40116e:	d1f0      	bne.n	401152 <_i2c_m_sync_transfer+0x10a>
		} while (!(sr & TWIHS_SR_TXRDY));
  401170:	f013 0f04 	tst.w	r3, #4
  401174:	d0f7      	beq.n	401166 <_i2c_m_sync_transfer+0x11e>
  401176:	e7ee      	b.n	401156 <_i2c_m_sync_transfer+0x10e>
	if (msg->flags & I2C_M_STOP) {
  401178:	886b      	ldrh	r3, [r5, #2]
  40117a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  40117e:	d106      	bne.n	40118e <_i2c_m_sync_transfer+0x146>
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401180:	8863      	ldrh	r3, [r4, #2]
  401182:	b29b      	uxth	r3, r3
  401184:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401188:	b29b      	uxth	r3, r3
  40118a:	8063      	strh	r3, [r4, #2]
		return _i2c_m_sync_write(dev, msg);
  40118c:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  40118e:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401190:	2202      	movs	r2, #2
  401192:	601a      	str	r2, [r3, #0]
		while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401194:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  401196:	6a1b      	ldr	r3, [r3, #32]
  401198:	f013 0f01 	tst.w	r3, #1
  40119c:	d0fa      	beq.n	401194 <_i2c_m_sync_transfer+0x14c>
  40119e:	e7ef      	b.n	401180 <_i2c_m_sync_transfer+0x138>
		return I2C_ERR_BUSY;
  4011a0:	f06f 0005 	mvn.w	r0, #5
}
  4011a4:	bd38      	pop	{r3, r4, r5, pc}
  4011a6:	bf00      	nop
  4011a8:	00401f40 	.word	0x00401f40
  4011ac:	004009ad 	.word	0x004009ad

004011b0 <_usart_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given usart hardware instance
 */
static uint8_t _usart_get_hardware_index(const void *const hw)
{
  4011b0:	b510      	push	{r4, lr}
	ASSERT(hw);
  4011b2:	4604      	mov	r4, r0
  4011b4:	f240 222b 	movw	r2, #555	; 0x22b
  4011b8:	4905      	ldr	r1, [pc, #20]	; (4011d0 <_usart_get_hardware_index+0x20>)
  4011ba:	3000      	adds	r0, #0
  4011bc:	bf18      	it	ne
  4011be:	2001      	movne	r0, #1
  4011c0:	4b04      	ldr	r3, [pc, #16]	; (4011d4 <_usart_get_hardware_index+0x24>)
  4011c2:	4798      	blx	r3

#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)USART0) / sizeof(Usart);
#endif

	return ((uint32_t)hw - (uint32_t)USART0) >> 14;
  4011c4:	4804      	ldr	r0, [pc, #16]	; (4011d8 <_usart_get_hardware_index+0x28>)
  4011c6:	4420      	add	r0, r4
}
  4011c8:	f3c0 3087 	ubfx	r0, r0, #14, #8
  4011cc:	bd10      	pop	{r4, pc}
  4011ce:	bf00      	nop
  4011d0:	00401f68 	.word	0x00401f68
  4011d4:	004009ad 	.word	0x004009ad
  4011d8:	bffdc000 	.word	0xbffdc000

004011dc <_get_usart_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given usart hardware instance
 */
static uint8_t _get_usart_index(const void *const hw)
{
  4011dc:	b510      	push	{r4, lr}
	ASSERT(hw);
  4011de:	4604      	mov	r4, r0
  4011e0:	f240 2287 	movw	r2, #647	; 0x287
  4011e4:	490e      	ldr	r1, [pc, #56]	; (401220 <_get_usart_index+0x44>)
  4011e6:	3000      	adds	r0, #0
  4011e8:	bf18      	it	ne
  4011ea:	2001      	movne	r0, #1
  4011ec:	4b0d      	ldr	r3, [pc, #52]	; (401224 <_get_usart_index+0x48>)
  4011ee:	4798      	blx	r3
	uint8_t usart_offset = _usart_get_hardware_index(hw);
  4011f0:	4620      	mov	r0, r4
  4011f2:	4b0d      	ldr	r3, [pc, #52]	; (401228 <_get_usart_index+0x4c>)
  4011f4:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  4011f6:	2300      	movs	r3, #0
  4011f8:	b143      	cbz	r3, 40120c <_get_usart_index+0x30>
		if (_usarts[i].number == usart_offset) {
			return i;
		}
	}

	ASSERT(false);
  4011fa:	f240 2291 	movw	r2, #657	; 0x291
  4011fe:	4908      	ldr	r1, [pc, #32]	; (401220 <_get_usart_index+0x44>)
  401200:	2000      	movs	r0, #0
  401202:	4b08      	ldr	r3, [pc, #32]	; (401224 <_get_usart_index+0x48>)
  401204:	4798      	blx	r3
	return 0;
  401206:	2300      	movs	r3, #0
}
  401208:	4618      	mov	r0, r3
  40120a:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == usart_offset) {
  40120c:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  401210:	008a      	lsls	r2, r1, #2
  401212:	4906      	ldr	r1, [pc, #24]	; (40122c <_get_usart_index+0x50>)
  401214:	5c8a      	ldrb	r2, [r1, r2]
  401216:	4290      	cmp	r0, r2
  401218:	d0f6      	beq.n	401208 <_get_usart_index+0x2c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  40121a:	3301      	adds	r3, #1
  40121c:	b2db      	uxtb	r3, r3
  40121e:	e7eb      	b.n	4011f8 <_get_usart_index+0x1c>
  401220:	00401f68 	.word	0x00401f68
  401224:	004009ad 	.word	0x004009ad
  401228:	004011b1 	.word	0x004011b1
  40122c:	00401f5c 	.word	0x00401f5c

00401230 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
  401230:	b510      	push	{r4, lr}
	ASSERT(hw);
  401232:	4604      	mov	r4, r0
  401234:	f240 229e 	movw	r2, #670	; 0x29e
  401238:	4911      	ldr	r1, [pc, #68]	; (401280 <_usart_init+0x50>)
  40123a:	3000      	adds	r0, #0
  40123c:	bf18      	it	ne
  40123e:	2001      	movne	r0, #1
  401240:	4b10      	ldr	r3, [pc, #64]	; (401284 <_usart_init+0x54>)
  401242:	4798      	blx	r3
	uint8_t i = _get_usart_index(hw);
  401244:	4620      	mov	r0, r4
  401246:	4b10      	ldr	r3, [pc, #64]	; (401288 <_usart_init+0x58>)
  401248:	4798      	blx	r3
}

static inline void hri_usart_write_US_WPMR_reg(const void *const hw, hri_usart_us_wpmr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_WPMR = data;
  40124a:	4b10      	ldr	r3, [pc, #64]	; (40128c <_usart_init+0x5c>)
  40124c:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	((Usart *)hw)->US_MR = data;
  401250:	2300      	movs	r3, #0
  401252:	6063      	str	r3, [r4, #4]
	((Usart *)hw)->US_RTOR = data;
  401254:	6263      	str	r3, [r4, #36]	; 0x24
	((Usart *)hw)->US_TTGR = data;
  401256:	62a3      	str	r3, [r4, #40]	; 0x28
}

static inline void hri_usart_write_US_CR_reg(const void *const hw, hri_usart_us_cr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_CR = data;
  401258:	22ac      	movs	r2, #172	; 0xac
  40125a:	6022      	str	r2, [r4, #0]
  40125c:	f44f 7280 	mov.w	r2, #256	; 0x100
  401260:	6022      	str	r2, [r4, #0]
  401262:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  401266:	6022      	str	r2, [r4, #0]
	/* Reset status bits. */
	hri_usart_write_US_CR_reg(hw, US_CR_RSTSTA);
	/* Turn off RTS and DTR if exist. */
	hri_usart_write_US_CR_reg(hw, US_CR_USART_RTSDIS);

	hri_usart_write_US_MR_reg(hw, _usarts[i].us_mr);
  401268:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  40126c:	0081      	lsls	r1, r0, #2
  40126e:	4a08      	ldr	r2, [pc, #32]	; (401290 <_usart_init+0x60>)
  401270:	440a      	add	r2, r1
  401272:	6852      	ldr	r2, [r2, #4]
	((Usart *)hw)->US_MR = data;
  401274:	6062      	str	r2, [r4, #4]
	((Usart *)hw)->US_BRGR = data;
  401276:	4a07      	ldr	r2, [pc, #28]	; (401294 <_usart_init+0x64>)
  401278:	6222      	str	r2, [r4, #32]
	hri_usart_write_US_BRGR_reg(hw, _usarts[i].us_brgr);

	return ERR_NONE;
}
  40127a:	4618      	mov	r0, r3
  40127c:	bd10      	pop	{r4, pc}
  40127e:	bf00      	nop
  401280:	00401f68 	.word	0x00401f68
  401284:	004009ad 	.word	0x004009ad
  401288:	004011dd 	.word	0x004011dd
  40128c:	55534100 	.word	0x55534100
  401290:	00401f5c 	.word	0x00401f5c
  401294:	000100f4 	.word	0x000100f4

00401298 <_usart_sync_init>:
{
  401298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40129a:	460c      	mov	r4, r1
	ASSERT(device);
  40129c:	4e09      	ldr	r6, [pc, #36]	; (4012c4 <_usart_sync_init+0x2c>)
  40129e:	4607      	mov	r7, r0
  4012a0:	22bd      	movs	r2, #189	; 0xbd
  4012a2:	4631      	mov	r1, r6
  4012a4:	3000      	adds	r0, #0
  4012a6:	bf18      	it	ne
  4012a8:	2001      	movne	r0, #1
  4012aa:	4d07      	ldr	r5, [pc, #28]	; (4012c8 <_usart_sync_init+0x30>)
  4012ac:	47a8      	blx	r5
	ASSERT(hw);
  4012ae:	22be      	movs	r2, #190	; 0xbe
  4012b0:	4631      	mov	r1, r6
  4012b2:	1c20      	adds	r0, r4, #0
  4012b4:	bf18      	it	ne
  4012b6:	2001      	movne	r0, #1
  4012b8:	47a8      	blx	r5
	device->hw = hw;
  4012ba:	603c      	str	r4, [r7, #0]
	return _usart_init(hw);
  4012bc:	4620      	mov	r0, r4
  4012be:	4b03      	ldr	r3, [pc, #12]	; (4012cc <_usart_sync_init+0x34>)
  4012c0:	4798      	blx	r3
}
  4012c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4012c4:	00401f68 	.word	0x00401f68
  4012c8:	004009ad 	.word	0x004009ad
  4012cc:	00401231 	.word	0x00401231

004012d0 <_usart_sync_enable>:
{
  4012d0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
  4012d2:	4e0a      	ldr	r6, [pc, #40]	; (4012fc <_usart_sync_enable+0x2c>)
  4012d4:	4604      	mov	r4, r0
  4012d6:	f240 1205 	movw	r2, #261	; 0x105
  4012da:	4631      	mov	r1, r6
  4012dc:	3000      	adds	r0, #0
  4012de:	bf18      	it	ne
  4012e0:	2001      	movne	r0, #1
  4012e2:	4d07      	ldr	r5, [pc, #28]	; (401300 <_usart_sync_enable+0x30>)
  4012e4:	47a8      	blx	r5
	_usart_enable(device->hw);
  4012e6:	6824      	ldr	r4, [r4, #0]
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline void _usart_enable(void *const hw)
{
	ASSERT(hw);
  4012e8:	f240 22c7 	movw	r2, #711	; 0x2c7
  4012ec:	4631      	mov	r1, r6
  4012ee:	1c20      	adds	r0, r4, #0
  4012f0:	bf18      	it	ne
  4012f2:	2001      	movne	r0, #1
  4012f4:	47a8      	blx	r5
	((Usart *)hw)->US_CR = data;
  4012f6:	2350      	movs	r3, #80	; 0x50
  4012f8:	6023      	str	r3, [r4, #0]
  4012fa:	bd70      	pop	{r4, r5, r6, pc}
  4012fc:	00401f68 	.word	0x00401f68
  401300:	004009ad 	.word	0x004009ad

00401304 <_usart_sync_write_byte>:
{
  401304:	b538      	push	{r3, r4, r5, lr}
  401306:	460c      	mov	r4, r1
	ASSERT(device);
  401308:	4605      	mov	r5, r0
  40130a:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
  40130e:	4904      	ldr	r1, [pc, #16]	; (401320 <_usart_sync_write_byte+0x1c>)
  401310:	3000      	adds	r0, #0
  401312:	bf18      	it	ne
  401314:	2001      	movne	r0, #1
  401316:	4b03      	ldr	r3, [pc, #12]	; (401324 <_usart_sync_write_byte+0x20>)
  401318:	4798      	blx	r3
	hri_usart_write_US_THR_reg(device->hw, (hri_usart_us_thr_reg_t)data);
  40131a:	682b      	ldr	r3, [r5, #0]
}

static inline void hri_usart_write_US_THR_reg(const void *const hw, hri_usart_us_thr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_THR = data;
  40131c:	61dc      	str	r4, [r3, #28]
  40131e:	bd38      	pop	{r3, r4, r5, pc}
  401320:	00401f68 	.word	0x00401f68
  401324:	004009ad 	.word	0x004009ad

00401328 <_usart_sync_read_byte>:
{
  401328:	b510      	push	{r4, lr}
	ASSERT(device);
  40132a:	4604      	mov	r4, r0
  40132c:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
  401330:	4904      	ldr	r1, [pc, #16]	; (401344 <_usart_sync_read_byte+0x1c>)
  401332:	3000      	adds	r0, #0
  401334:	bf18      	it	ne
  401336:	2001      	movne	r0, #1
  401338:	4b03      	ldr	r3, [pc, #12]	; (401348 <_usart_sync_read_byte+0x20>)
  40133a:	4798      	blx	r3
	return (uint8_t)(hri_usart_read_US_RHR_reg(device->hw) & 0xff);
  40133c:	6823      	ldr	r3, [r4, #0]
	return ((Usart *)hw)->US_RHR;
  40133e:	6998      	ldr	r0, [r3, #24]
}
  401340:	b2c0      	uxtb	r0, r0
  401342:	bd10      	pop	{r4, pc}
  401344:	00401f68 	.word	0x00401f68
  401348:	004009ad 	.word	0x004009ad

0040134c <_usart_sync_is_ready_to_send>:
{
  40134c:	b510      	push	{r4, lr}
	ASSERT(device);
  40134e:	4604      	mov	r4, r0
  401350:	f240 12c3 	movw	r2, #451	; 0x1c3
  401354:	4905      	ldr	r1, [pc, #20]	; (40136c <_usart_sync_is_ready_to_send+0x20>)
  401356:	3000      	adds	r0, #0
  401358:	bf18      	it	ne
  40135a:	2001      	movne	r0, #1
  40135c:	4b04      	ldr	r3, [pc, #16]	; (401370 <_usart_sync_is_ready_to_send+0x24>)
  40135e:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXRDY_bit(device->hw);
  401360:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXRDY) > 0;
  401362:	6958      	ldr	r0, [r3, #20]
}
  401364:	f3c0 0040 	ubfx	r0, r0, #1, #1
  401368:	bd10      	pop	{r4, pc}
  40136a:	bf00      	nop
  40136c:	00401f68 	.word	0x00401f68
  401370:	004009ad 	.word	0x004009ad

00401374 <_usart_sync_is_transmit_done>:
{
  401374:	b510      	push	{r4, lr}
	ASSERT(device);
  401376:	4604      	mov	r4, r0
  401378:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
  40137c:	4905      	ldr	r1, [pc, #20]	; (401394 <_usart_sync_is_transmit_done+0x20>)
  40137e:	3000      	adds	r0, #0
  401380:	bf18      	it	ne
  401382:	2001      	movne	r0, #1
  401384:	4b04      	ldr	r3, [pc, #16]	; (401398 <_usart_sync_is_transmit_done+0x24>)
  401386:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXEMPTY_bit(device->hw);
  401388:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXEMPTY) > 0;
  40138a:	6958      	ldr	r0, [r3, #20]
}
  40138c:	f3c0 2040 	ubfx	r0, r0, #9, #1
  401390:	bd10      	pop	{r4, pc}
  401392:	bf00      	nop
  401394:	00401f68 	.word	0x00401f68
  401398:	004009ad 	.word	0x004009ad

0040139c <_usart_sync_is_byte_received>:
{
  40139c:	b510      	push	{r4, lr}
	ASSERT(device);
  40139e:	4604      	mov	r4, r0
  4013a0:	f44f 72ef 	mov.w	r2, #478	; 0x1de
  4013a4:	4905      	ldr	r1, [pc, #20]	; (4013bc <_usart_sync_is_byte_received+0x20>)
  4013a6:	3000      	adds	r0, #0
  4013a8:	bf18      	it	ne
  4013aa:	2001      	movne	r0, #1
  4013ac:	4b04      	ldr	r3, [pc, #16]	; (4013c0 <_usart_sync_is_byte_received+0x24>)
  4013ae:	4798      	blx	r3
	return hri_usart_get_US_CSR_RXRDY_bit(device->hw);
  4013b0:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_RXRDY) > 0;
  4013b2:	6958      	ldr	r0, [r3, #20]
  4013b4:	f000 0001 	and.w	r0, r0, #1
}
  4013b8:	bd10      	pop	{r4, pc}
  4013ba:	bf00      	nop
  4013bc:	00401f68 	.word	0x00401f68
  4013c0:	004009ad 	.word	0x004009ad

004013c4 <_usart_get_usart_sync>:
}
  4013c4:	2000      	movs	r0, #0
  4013c6:	4770      	bx	lr

004013c8 <main>:
#include <stdlib.h>
#include "bno085_driver.h"
#include "nRF24_driver.h"

int main(void)
{
  4013c8:	b500      	push	{lr}
  4013ca:	b08d      	sub	sp, #52	; 0x34
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  4013cc:	4b0e      	ldr	r3, [pc, #56]	; (401408 <main+0x40>)
  4013ce:	4798      	blx	r3
	
	/*Initialize the IMU, making sure to pass in the address of the start of the float array that will hold the quaternion coefficients*/
	
	//init_IMU(&imu_vector_buffer[0]);
	
	nRF24_power_up();
  4013d0:	4b0e      	ldr	r3, [pc, #56]	; (40140c <main+0x44>)
  4013d2:	4798      	blx	r3
	delay_us(200); //Should be 200 us, setting higher for testing
  4013d4:	20c8      	movs	r0, #200	; 0xc8
  4013d6:	4b0e      	ldr	r3, [pc, #56]	; (401410 <main+0x48>)
  4013d8:	4798      	blx	r3
		should only fetch when needed, regardless of whether we have missed some or not), while being slow enough that we aren't asking the
		IMU for new quaternion coefficients before it is ready with the next set of them. (also really only relevant for the demo code, in
		reality it doesn't matter if we ask for coefficients before the IMU is ready with new ones, as the function will just return the last
		valid coefficients it collected in the event that the IMU isn't ready with new ones) */
		
		delay_ms(1);
  4013da:	2001      	movs	r0, #1
  4013dc:	4b0d      	ldr	r3, [pc, #52]	; (401414 <main+0x4c>)
  4013de:	4798      	blx	r3
		uint8_t byte_packet[32];
		memset(&byte_packet[0], 0, sizeof(uint8_t)*32);
  4013e0:	2220      	movs	r2, #32
  4013e2:	2100      	movs	r1, #0
  4013e4:	a804      	add	r0, sp, #16
  4013e6:	4b0c      	ldr	r3, [pc, #48]	; (401418 <main+0x50>)
  4013e8:	4798      	blx	r3
		char string[13] = "Hello World!";
  4013ea:	4b0c      	ldr	r3, [pc, #48]	; (40141c <main+0x54>)
  4013ec:	466c      	mov	r4, sp
  4013ee:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  4013f0:	c407      	stmia	r4!, {r0, r1, r2}
  4013f2:	7023      	strb	r3, [r4, #0]
		memcpy(&byte_packet[0], &string[0], sizeof(uint8_t)*13);
  4013f4:	ac04      	add	r4, sp, #16
  4013f6:	e89d 000f 	ldmia.w	sp, {r0, r1, r2, r3}
  4013fa:	c407      	stmia	r4!, {r0, r1, r2}
  4013fc:	7023      	strb	r3, [r4, #0]
		nRF24_transmit(&byte_packet);
  4013fe:	a804      	add	r0, sp, #16
  401400:	4b07      	ldr	r3, [pc, #28]	; (401420 <main+0x58>)
  401402:	4798      	blx	r3
  401404:	e7e9      	b.n	4013da <main+0x12>
  401406:	bf00      	nop
  401408:	004001d5 	.word	0x004001d5
  40140c:	00401579 	.word	0x00401579
  401410:	00400535 	.word	0x00400535
  401414:	00400555 	.word	0x00400555
  401418:	004016c9 	.word	0x004016c9
  40141c:	00401f84 	.word	0x00401f84
  401420:	00401525 	.word	0x00401525

00401424 <nRF24_write_to_register>:

#include "nRF24_driver.h"

struct io_descriptor *spi_0_io;

void nRF24_write_to_register(uint8_t registerd, uint8_t data){ //SPI Command "W_REGISTER"
  401424:	b530      	push	{r4, r5, lr}
  401426:	b083      	sub	sp, #12
	uint8_t buffer[2];
	memset(&buffer[0], 0, sizeof(uint8_t)*2);
	buffer[0] = buffer[0] | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer[0] = (buffer[0]) | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401428:	f040 0020 	orr.w	r0, r0, #32
  40142c:	f88d 0004 	strb.w	r0, [sp, #4]
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	buffer[1] = data;
  401430:	f88d 1005 	strb.w	r1, [sp, #5]
	((Pio *)hw)->PIO_CODR = mask;
  401434:	4c06      	ldr	r4, [pc, #24]	; (401450 <nRF24_write_to_register+0x2c>)
  401436:	f44f 7500 	mov.w	r5, #512	; 0x200
  40143a:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, buffer, 2); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  40143c:	2202      	movs	r2, #2
  40143e:	a901      	add	r1, sp, #4
  401440:	4b04      	ldr	r3, [pc, #16]	; (401454 <nRF24_write_to_register+0x30>)
  401442:	6818      	ldr	r0, [r3, #0]
  401444:	4b04      	ldr	r3, [pc, #16]	; (401458 <nRF24_write_to_register+0x34>)
  401446:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401448:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40144a:	b003      	add	sp, #12
  40144c:	bd30      	pop	{r4, r5, pc}
  40144e:	bf00      	nop
  401450:	400e1200 	.word	0x400e1200
  401454:	204000ec 	.word	0x204000ec
  401458:	0040068d 	.word	0x0040068d

0040145c <nRF24_write_to_register_multi_byte>:

void nRF24_write_to_register_multi_byte(uint8_t registerd, uint8_t *data, int length){ //SPI Command "W_REGISTER"
  40145c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  401460:	b083      	sub	sp, #12
  401462:	4688      	mov	r8, r1
  401464:	4691      	mov	r9, r2
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer = buffer | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401466:	f040 0020 	orr.w	r0, r0, #32
  40146a:	a902      	add	r1, sp, #8
  40146c:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401470:	4c08      	ldr	r4, [pc, #32]	; (401494 <nRF24_write_to_register_multi_byte+0x38>)
  401472:	f44f 7500 	mov.w	r5, #512	; 0x200
  401476:	6365      	str	r5, [r4, #52]	; 0x34
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1);
  401478:	4f07      	ldr	r7, [pc, #28]	; (401498 <nRF24_write_to_register_multi_byte+0x3c>)
  40147a:	2201      	movs	r2, #1
  40147c:	6838      	ldr	r0, [r7, #0]
  40147e:	4e07      	ldr	r6, [pc, #28]	; (40149c <nRF24_write_to_register_multi_byte+0x40>)
  401480:	47b0      	blx	r6
	io_write(spi_0_io, data, length); 
  401482:	fa1f f289 	uxth.w	r2, r9
  401486:	4641      	mov	r1, r8
  401488:	6838      	ldr	r0, [r7, #0]
  40148a:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  40148c:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40148e:	b003      	add	sp, #12
  401490:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401494:	400e1200 	.word	0x400e1200
  401498:	204000ec 	.word	0x204000ec
  40149c:	0040068d 	.word	0x0040068d

004014a0 <nRF24_SPI_init>:
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &command, 1);
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}

void nRF24_SPI_init(){ //You are in standby-1 at the end of this call
  4014a0:	b510      	push	{r4, lr}
  4014a2:	b082      	sub	sp, #8
	spi_m_sync_get_io_descriptor(&SPI_0, &spi_0_io);
  4014a4:	4c18      	ldr	r4, [pc, #96]	; (401508 <nRF24_SPI_init+0x68>)
  4014a6:	4919      	ldr	r1, [pc, #100]	; (40150c <nRF24_SPI_init+0x6c>)
  4014a8:	4620      	mov	r0, r4
  4014aa:	4b19      	ldr	r3, [pc, #100]	; (401510 <nRF24_SPI_init+0x70>)
  4014ac:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
  4014ae:	4620      	mov	r0, r4
  4014b0:	4b18      	ldr	r3, [pc, #96]	; (401514 <nRF24_SPI_init+0x74>)
  4014b2:	4798      	blx	r3
	((Pio *)hw)->PIO_CODR = mask;
  4014b4:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4014b8:	4b17      	ldr	r3, [pc, #92]	; (401518 <nRF24_SPI_init+0x78>)
  4014ba:	635a      	str	r2, [r3, #52]	; 0x34
	gpio_set_pin_level(RF24_CE, false); //Keeps us set to be ready to enter standby-1
	nRF24_write_to_register(CONFIG,0); //0000 0000 keep us in power down, disable checksums
  4014bc:	2100      	movs	r1, #0
  4014be:	4608      	mov	r0, r1
  4014c0:	4c16      	ldr	r4, [pc, #88]	; (40151c <nRF24_SPI_init+0x7c>)
  4014c2:	47a0      	blx	r4
	nRF24_write_to_register(EN_AA,0); //0000 0000 no auto ACK
  4014c4:	2100      	movs	r1, #0
  4014c6:	2001      	movs	r0, #1
  4014c8:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR,0); //0000 0000 disable all RX pipes
  4014ca:	2100      	movs	r1, #0
  4014cc:	2002      	movs	r0, #2
  4014ce:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_AW,3); //0000 0011 5 byte tx rx address fields
  4014d0:	2103      	movs	r1, #3
  4014d2:	4608      	mov	r0, r1
  4014d4:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_RETR,0); //0000 0000 no auto retransmission
  4014d6:	2100      	movs	r1, #0
  4014d8:	2004      	movs	r0, #4
  4014da:	47a0      	blx	r4
	nRF24_write_to_register(RF_CH,120); //0011 1111 first bit must be 0, 011 1111 = 63 freq = 2400 + 63 = 2463 = 2.463 GHz
  4014dc:	2178      	movs	r1, #120	; 0x78
  4014de:	2005      	movs	r0, #5
  4014e0:	47a0      	blx	r4
	nRF24_write_to_register(RF_SETUP,2); //0000 0010 1 Mbps and -12 db
  4014e2:	2102      	movs	r1, #2
  4014e4:	2006      	movs	r0, #6
  4014e6:	47a0      	blx	r4
	uint8_t tx_address[5];
	memset(&tx_address[0], 231, sizeof(uint8_t)*5);
  4014e8:	f04f 33e7 	mov.w	r3, #3890735079	; 0xe7e7e7e7
  4014ec:	9300      	str	r3, [sp, #0]
  4014ee:	f88d 3004 	strb.w	r3, [sp, #4]
	nRF24_write_to_register_multi_byte(TX_ADDR, &tx_address[0], 5); //Set TX addr as e7e7e7e7e7
  4014f2:	2205      	movs	r2, #5
  4014f4:	4669      	mov	r1, sp
  4014f6:	2010      	movs	r0, #16
  4014f8:	4b09      	ldr	r3, [pc, #36]	; (401520 <nRF24_SPI_init+0x80>)
  4014fa:	4798      	blx	r3
	nRF24_write_to_register(CONFIG,2); //0000 0020 enter standby-1, disable checksums
  4014fc:	2102      	movs	r1, #2
  4014fe:	2000      	movs	r0, #0
  401500:	47a0      	blx	r4
}
  401502:	b002      	add	sp, #8
  401504:	bd10      	pop	{r4, pc}
  401506:	bf00      	nop
  401508:	204000b4 	.word	0x204000b4
  40150c:	204000ec 	.word	0x204000ec
  401510:	0040083d 	.word	0x0040083d
  401514:	0040075d 	.word	0x0040075d
  401518:	400e1400 	.word	0x400e1400
  40151c:	00401425 	.word	0x00401425
  401520:	0040145d 	.word	0x0040145d

00401524 <nRF24_transmit>:

void nRF24_transmit(uint8_t *data){ //You should be in standby-1 at the beginning of this call
  401524:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401528:	b082      	sub	sp, #8
  40152a:	4680      	mov	r8, r0
  40152c:	4c0e      	ldr	r4, [pc, #56]	; (401568 <nRF24_transmit+0x44>)
  40152e:	f44f 7500 	mov.w	r5, #512	; 0x200
  401532:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	uint8_t x = W_TX_PAYLOAD;
  401534:	a902      	add	r1, sp, #8
  401536:	23a0      	movs	r3, #160	; 0xa0
  401538:	f801 3d01 	strb.w	r3, [r1, #-1]!
	io_write(spi_0_io, &x, 1);
  40153c:	4f0b      	ldr	r7, [pc, #44]	; (40156c <nRF24_transmit+0x48>)
  40153e:	2201      	movs	r2, #1
  401540:	6838      	ldr	r0, [r7, #0]
  401542:	4e0b      	ldr	r6, [pc, #44]	; (401570 <nRF24_transmit+0x4c>)
  401544:	47b0      	blx	r6
	io_write(spi_0_io, data, 32);
  401546:	2220      	movs	r2, #32
  401548:	4641      	mov	r1, r8
  40154a:	6838      	ldr	r0, [r7, #0]
  40154c:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  40154e:	6325      	str	r5, [r4, #48]	; 0x30
  401550:	f504 7400 	add.w	r4, r4, #512	; 0x200
  401554:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
  401558:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	//Now there should be a payload in the TX_FIFO
	gpio_set_pin_level(RF24_CE, true);
	delay_us(11); //This will put us into TX mode and empty the FIFO queue into the air
  40155a:	200b      	movs	r0, #11
  40155c:	4b05      	ldr	r3, [pc, #20]	; (401574 <nRF24_transmit+0x50>)
  40155e:	4798      	blx	r3
	((Pio *)hw)->PIO_CODR = mask;
  401560:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CE, false); //Return to standby-1 mode!
}
  401562:	b002      	add	sp, #8
  401564:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401568:	400e1200 	.word	0x400e1200
  40156c:	204000ec 	.word	0x204000ec
  401570:	0040068d 	.word	0x0040068d
  401574:	00400535 	.word	0x00400535

00401578 <nRF24_power_up>:

void nRF24_power_up(){
  401578:	b508      	push	{r3, lr}
	nRF24_SPI_init();
  40157a:	4b03      	ldr	r3, [pc, #12]	; (401588 <nRF24_power_up+0x10>)
  40157c:	4798      	blx	r3
  40157e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  401582:	4b02      	ldr	r3, [pc, #8]	; (40158c <nRF24_power_up+0x14>)
  401584:	635a      	str	r2, [r3, #52]	; 0x34
  401586:	bd08      	pop	{r3, pc}
  401588:	004014a1 	.word	0x004014a1
  40158c:	400e1400 	.word	0x400e1400

00401590 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
  401590:	b958      	cbnz	r0, 4015aa <_read+0x1a>
{
  401592:	b508      	push	{r3, lr}
  401594:	460b      	mov	r3, r1
  401596:	4611      	mov	r1, r2
  401598:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
  40159a:	4b05      	ldr	r3, [pc, #20]	; (4015b0 <_read+0x20>)
  40159c:	4798      	blx	r3
	if (n < 0) {
  40159e:	2800      	cmp	r0, #0
  4015a0:	db00      	blt.n	4015a4 <_read+0x14>
		return -1;
	}

	return n;
}
  4015a2:	bd08      	pop	{r3, pc}
		return -1;
  4015a4:	f04f 30ff 	mov.w	r0, #4294967295
  4015a8:	bd08      	pop	{r3, pc}
		return -1;
  4015aa:	f04f 30ff 	mov.w	r0, #4294967295
  4015ae:	4770      	bx	lr
  4015b0:	00401609 	.word	0x00401609

004015b4 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
  4015b4:	3801      	subs	r0, #1
  4015b6:	2802      	cmp	r0, #2
  4015b8:	d80b      	bhi.n	4015d2 <_write+0x1e>
{
  4015ba:	b508      	push	{r3, lr}
  4015bc:	460b      	mov	r3, r1
  4015be:	4611      	mov	r1, r2
  4015c0:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
  4015c2:	4b05      	ldr	r3, [pc, #20]	; (4015d8 <_write+0x24>)
  4015c4:	4798      	blx	r3
	if (n < 0) {
  4015c6:	2800      	cmp	r0, #0
  4015c8:	db00      	blt.n	4015cc <_write+0x18>
		return -1;
	}

	return n;
}
  4015ca:	bd08      	pop	{r3, pc}
		return -1;
  4015cc:	f04f 30ff 	mov.w	r0, #4294967295
  4015d0:	bd08      	pop	{r3, pc}
		return -1;
  4015d2:	f04f 30ff 	mov.w	r0, #4294967295
  4015d6:	4770      	bx	lr
  4015d8:	0040162d 	.word	0x0040162d

004015dc <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
  4015dc:	b570      	push	{r4, r5, r6, lr}
  4015de:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
  4015e0:	4d06      	ldr	r5, [pc, #24]	; (4015fc <stdio_io_init+0x20>)
  4015e2:	682b      	ldr	r3, [r5, #0]
  4015e4:	2100      	movs	r1, #0
  4015e6:	6898      	ldr	r0, [r3, #8]
  4015e8:	4c05      	ldr	r4, [pc, #20]	; (401600 <stdio_io_init+0x24>)
  4015ea:	47a0      	blx	r4
	setbuf(stdin, NULL);
  4015ec:	682b      	ldr	r3, [r5, #0]
  4015ee:	2100      	movs	r1, #0
  4015f0:	6858      	ldr	r0, [r3, #4]
  4015f2:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
  4015f4:	4b03      	ldr	r3, [pc, #12]	; (401604 <stdio_io_init+0x28>)
  4015f6:	601e      	str	r6, [r3, #0]
  4015f8:	bd70      	pop	{r4, r5, r6, pc}
  4015fa:	bf00      	nop
  4015fc:	20400000 	.word	0x20400000
  401600:	00401851 	.word	0x00401851
  401604:	2040009c 	.word	0x2040009c

00401608 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
  401608:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  40160a:	4b06      	ldr	r3, [pc, #24]	; (401624 <stdio_io_read+0x1c>)
  40160c:	681b      	ldr	r3, [r3, #0]
  40160e:	b133      	cbz	r3, 40161e <stdio_io_read+0x16>
  401610:	460a      	mov	r2, r1
  401612:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
  401614:	b292      	uxth	r2, r2
  401616:	4618      	mov	r0, r3
  401618:	4b03      	ldr	r3, [pc, #12]	; (401628 <stdio_io_read+0x20>)
  40161a:	4798      	blx	r3
  40161c:	bd08      	pop	{r3, pc}
		return 0;
  40161e:	2000      	movs	r0, #0
}
  401620:	bd08      	pop	{r3, pc}
  401622:	bf00      	nop
  401624:	2040009c 	.word	0x2040009c
  401628:	004006bd 	.word	0x004006bd

0040162c <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
  40162c:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  40162e:	4b06      	ldr	r3, [pc, #24]	; (401648 <stdio_io_write+0x1c>)
  401630:	681b      	ldr	r3, [r3, #0]
  401632:	b133      	cbz	r3, 401642 <stdio_io_write+0x16>
  401634:	460a      	mov	r2, r1
  401636:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
  401638:	b292      	uxth	r2, r2
  40163a:	4618      	mov	r0, r3
  40163c:	4b03      	ldr	r3, [pc, #12]	; (40164c <stdio_io_write+0x20>)
  40163e:	4798      	blx	r3
  401640:	bd08      	pop	{r3, pc}
		return 0;
  401642:	2000      	movs	r0, #0
}
  401644:	bd08      	pop	{r3, pc}
  401646:	bf00      	nop
  401648:	2040009c 	.word	0x2040009c
  40164c:	0040068d 	.word	0x0040068d

00401650 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
  401650:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
  401652:	4c04      	ldr	r4, [pc, #16]	; (401664 <stdio_redirect_init+0x14>)
  401654:	4620      	mov	r0, r4
  401656:	4b04      	ldr	r3, [pc, #16]	; (401668 <stdio_redirect_init+0x18>)
  401658:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
  40165a:	4620      	mov	r0, r4
  40165c:	4b03      	ldr	r3, [pc, #12]	; (40166c <stdio_redirect_init+0x1c>)
  40165e:	4798      	blx	r3
  401660:	bd10      	pop	{r4, pc}
  401662:	bf00      	nop
  401664:	204000a8 	.word	0x204000a8
  401668:	00400981 	.word	0x00400981
  40166c:	004015dd 	.word	0x004015dd

00401670 <__libc_init_array>:
  401670:	b570      	push	{r4, r5, r6, lr}
  401672:	4e0d      	ldr	r6, [pc, #52]	; (4016a8 <__libc_init_array+0x38>)
  401674:	4c0d      	ldr	r4, [pc, #52]	; (4016ac <__libc_init_array+0x3c>)
  401676:	1ba4      	subs	r4, r4, r6
  401678:	10a4      	asrs	r4, r4, #2
  40167a:	2500      	movs	r5, #0
  40167c:	42a5      	cmp	r5, r4
  40167e:	d109      	bne.n	401694 <__libc_init_array+0x24>
  401680:	4e0b      	ldr	r6, [pc, #44]	; (4016b0 <__libc_init_array+0x40>)
  401682:	4c0c      	ldr	r4, [pc, #48]	; (4016b4 <__libc_init_array+0x44>)
  401684:	f000 fcb8 	bl	401ff8 <_init>
  401688:	1ba4      	subs	r4, r4, r6
  40168a:	10a4      	asrs	r4, r4, #2
  40168c:	2500      	movs	r5, #0
  40168e:	42a5      	cmp	r5, r4
  401690:	d105      	bne.n	40169e <__libc_init_array+0x2e>
  401692:	bd70      	pop	{r4, r5, r6, pc}
  401694:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401698:	4798      	blx	r3
  40169a:	3501      	adds	r5, #1
  40169c:	e7ee      	b.n	40167c <__libc_init_array+0xc>
  40169e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  4016a2:	4798      	blx	r3
  4016a4:	3501      	adds	r5, #1
  4016a6:	e7f2      	b.n	40168e <__libc_init_array+0x1e>
  4016a8:	00402004 	.word	0x00402004
  4016ac:	00402004 	.word	0x00402004
  4016b0:	00402004 	.word	0x00402004
  4016b4:	00402008 	.word	0x00402008

004016b8 <malloc>:
  4016b8:	4b02      	ldr	r3, [pc, #8]	; (4016c4 <malloc+0xc>)
  4016ba:	4601      	mov	r1, r0
  4016bc:	6818      	ldr	r0, [r3, #0]
  4016be:	f000 b859 	b.w	401774 <_malloc_r>
  4016c2:	bf00      	nop
  4016c4:	20400000 	.word	0x20400000

004016c8 <memset>:
  4016c8:	4402      	add	r2, r0
  4016ca:	4603      	mov	r3, r0
  4016cc:	4293      	cmp	r3, r2
  4016ce:	d100      	bne.n	4016d2 <memset+0xa>
  4016d0:	4770      	bx	lr
  4016d2:	f803 1b01 	strb.w	r1, [r3], #1
  4016d6:	e7f9      	b.n	4016cc <memset+0x4>

004016d8 <_free_r>:
  4016d8:	b538      	push	{r3, r4, r5, lr}
  4016da:	4605      	mov	r5, r0
  4016dc:	2900      	cmp	r1, #0
  4016de:	d045      	beq.n	40176c <_free_r+0x94>
  4016e0:	f851 3c04 	ldr.w	r3, [r1, #-4]
  4016e4:	1f0c      	subs	r4, r1, #4
  4016e6:	2b00      	cmp	r3, #0
  4016e8:	bfb8      	it	lt
  4016ea:	18e4      	addlt	r4, r4, r3
  4016ec:	f000 fb06 	bl	401cfc <__malloc_lock>
  4016f0:	4a1f      	ldr	r2, [pc, #124]	; (401770 <_free_r+0x98>)
  4016f2:	6813      	ldr	r3, [r2, #0]
  4016f4:	4610      	mov	r0, r2
  4016f6:	b933      	cbnz	r3, 401706 <_free_r+0x2e>
  4016f8:	6063      	str	r3, [r4, #4]
  4016fa:	6014      	str	r4, [r2, #0]
  4016fc:	4628      	mov	r0, r5
  4016fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  401702:	f000 bafc 	b.w	401cfe <__malloc_unlock>
  401706:	42a3      	cmp	r3, r4
  401708:	d90c      	bls.n	401724 <_free_r+0x4c>
  40170a:	6821      	ldr	r1, [r4, #0]
  40170c:	1862      	adds	r2, r4, r1
  40170e:	4293      	cmp	r3, r2
  401710:	bf04      	itt	eq
  401712:	681a      	ldreq	r2, [r3, #0]
  401714:	685b      	ldreq	r3, [r3, #4]
  401716:	6063      	str	r3, [r4, #4]
  401718:	bf04      	itt	eq
  40171a:	1852      	addeq	r2, r2, r1
  40171c:	6022      	streq	r2, [r4, #0]
  40171e:	6004      	str	r4, [r0, #0]
  401720:	e7ec      	b.n	4016fc <_free_r+0x24>
  401722:	4613      	mov	r3, r2
  401724:	685a      	ldr	r2, [r3, #4]
  401726:	b10a      	cbz	r2, 40172c <_free_r+0x54>
  401728:	42a2      	cmp	r2, r4
  40172a:	d9fa      	bls.n	401722 <_free_r+0x4a>
  40172c:	6819      	ldr	r1, [r3, #0]
  40172e:	1858      	adds	r0, r3, r1
  401730:	42a0      	cmp	r0, r4
  401732:	d10b      	bne.n	40174c <_free_r+0x74>
  401734:	6820      	ldr	r0, [r4, #0]
  401736:	4401      	add	r1, r0
  401738:	1858      	adds	r0, r3, r1
  40173a:	4282      	cmp	r2, r0
  40173c:	6019      	str	r1, [r3, #0]
  40173e:	d1dd      	bne.n	4016fc <_free_r+0x24>
  401740:	6810      	ldr	r0, [r2, #0]
  401742:	6852      	ldr	r2, [r2, #4]
  401744:	605a      	str	r2, [r3, #4]
  401746:	4401      	add	r1, r0
  401748:	6019      	str	r1, [r3, #0]
  40174a:	e7d7      	b.n	4016fc <_free_r+0x24>
  40174c:	d902      	bls.n	401754 <_free_r+0x7c>
  40174e:	230c      	movs	r3, #12
  401750:	602b      	str	r3, [r5, #0]
  401752:	e7d3      	b.n	4016fc <_free_r+0x24>
  401754:	6820      	ldr	r0, [r4, #0]
  401756:	1821      	adds	r1, r4, r0
  401758:	428a      	cmp	r2, r1
  40175a:	bf04      	itt	eq
  40175c:	6811      	ldreq	r1, [r2, #0]
  40175e:	6852      	ldreq	r2, [r2, #4]
  401760:	6062      	str	r2, [r4, #4]
  401762:	bf04      	itt	eq
  401764:	1809      	addeq	r1, r1, r0
  401766:	6021      	streq	r1, [r4, #0]
  401768:	605c      	str	r4, [r3, #4]
  40176a:	e7c7      	b.n	4016fc <_free_r+0x24>
  40176c:	bd38      	pop	{r3, r4, r5, pc}
  40176e:	bf00      	nop
  401770:	204000a0 	.word	0x204000a0

00401774 <_malloc_r>:
  401774:	b570      	push	{r4, r5, r6, lr}
  401776:	1ccd      	adds	r5, r1, #3
  401778:	f025 0503 	bic.w	r5, r5, #3
  40177c:	3508      	adds	r5, #8
  40177e:	2d0c      	cmp	r5, #12
  401780:	bf38      	it	cc
  401782:	250c      	movcc	r5, #12
  401784:	2d00      	cmp	r5, #0
  401786:	4606      	mov	r6, r0
  401788:	db01      	blt.n	40178e <_malloc_r+0x1a>
  40178a:	42a9      	cmp	r1, r5
  40178c:	d903      	bls.n	401796 <_malloc_r+0x22>
  40178e:	230c      	movs	r3, #12
  401790:	6033      	str	r3, [r6, #0]
  401792:	2000      	movs	r0, #0
  401794:	bd70      	pop	{r4, r5, r6, pc}
  401796:	f000 fab1 	bl	401cfc <__malloc_lock>
  40179a:	4a23      	ldr	r2, [pc, #140]	; (401828 <_malloc_r+0xb4>)
  40179c:	6814      	ldr	r4, [r2, #0]
  40179e:	4621      	mov	r1, r4
  4017a0:	b991      	cbnz	r1, 4017c8 <_malloc_r+0x54>
  4017a2:	4c22      	ldr	r4, [pc, #136]	; (40182c <_malloc_r+0xb8>)
  4017a4:	6823      	ldr	r3, [r4, #0]
  4017a6:	b91b      	cbnz	r3, 4017b0 <_malloc_r+0x3c>
  4017a8:	4630      	mov	r0, r6
  4017aa:	f000 f841 	bl	401830 <_sbrk_r>
  4017ae:	6020      	str	r0, [r4, #0]
  4017b0:	4629      	mov	r1, r5
  4017b2:	4630      	mov	r0, r6
  4017b4:	f000 f83c 	bl	401830 <_sbrk_r>
  4017b8:	1c43      	adds	r3, r0, #1
  4017ba:	d126      	bne.n	40180a <_malloc_r+0x96>
  4017bc:	230c      	movs	r3, #12
  4017be:	6033      	str	r3, [r6, #0]
  4017c0:	4630      	mov	r0, r6
  4017c2:	f000 fa9c 	bl	401cfe <__malloc_unlock>
  4017c6:	e7e4      	b.n	401792 <_malloc_r+0x1e>
  4017c8:	680b      	ldr	r3, [r1, #0]
  4017ca:	1b5b      	subs	r3, r3, r5
  4017cc:	d41a      	bmi.n	401804 <_malloc_r+0x90>
  4017ce:	2b0b      	cmp	r3, #11
  4017d0:	d90f      	bls.n	4017f2 <_malloc_r+0x7e>
  4017d2:	600b      	str	r3, [r1, #0]
  4017d4:	50cd      	str	r5, [r1, r3]
  4017d6:	18cc      	adds	r4, r1, r3
  4017d8:	4630      	mov	r0, r6
  4017da:	f000 fa90 	bl	401cfe <__malloc_unlock>
  4017de:	f104 000b 	add.w	r0, r4, #11
  4017e2:	1d23      	adds	r3, r4, #4
  4017e4:	f020 0007 	bic.w	r0, r0, #7
  4017e8:	1ac3      	subs	r3, r0, r3
  4017ea:	d01b      	beq.n	401824 <_malloc_r+0xb0>
  4017ec:	425a      	negs	r2, r3
  4017ee:	50e2      	str	r2, [r4, r3]
  4017f0:	bd70      	pop	{r4, r5, r6, pc}
  4017f2:	428c      	cmp	r4, r1
  4017f4:	bf0d      	iteet	eq
  4017f6:	6863      	ldreq	r3, [r4, #4]
  4017f8:	684b      	ldrne	r3, [r1, #4]
  4017fa:	6063      	strne	r3, [r4, #4]
  4017fc:	6013      	streq	r3, [r2, #0]
  4017fe:	bf18      	it	ne
  401800:	460c      	movne	r4, r1
  401802:	e7e9      	b.n	4017d8 <_malloc_r+0x64>
  401804:	460c      	mov	r4, r1
  401806:	6849      	ldr	r1, [r1, #4]
  401808:	e7ca      	b.n	4017a0 <_malloc_r+0x2c>
  40180a:	1cc4      	adds	r4, r0, #3
  40180c:	f024 0403 	bic.w	r4, r4, #3
  401810:	42a0      	cmp	r0, r4
  401812:	d005      	beq.n	401820 <_malloc_r+0xac>
  401814:	1a21      	subs	r1, r4, r0
  401816:	4630      	mov	r0, r6
  401818:	f000 f80a 	bl	401830 <_sbrk_r>
  40181c:	3001      	adds	r0, #1
  40181e:	d0cd      	beq.n	4017bc <_malloc_r+0x48>
  401820:	6025      	str	r5, [r4, #0]
  401822:	e7d9      	b.n	4017d8 <_malloc_r+0x64>
  401824:	bd70      	pop	{r4, r5, r6, pc}
  401826:	bf00      	nop
  401828:	204000a0 	.word	0x204000a0
  40182c:	204000a4 	.word	0x204000a4

00401830 <_sbrk_r>:
  401830:	b538      	push	{r3, r4, r5, lr}
  401832:	4c06      	ldr	r4, [pc, #24]	; (40184c <_sbrk_r+0x1c>)
  401834:	2300      	movs	r3, #0
  401836:	4605      	mov	r5, r0
  401838:	4608      	mov	r0, r1
  40183a:	6023      	str	r3, [r4, #0]
  40183c:	f7ff f8ba 	bl	4009b4 <_sbrk>
  401840:	1c43      	adds	r3, r0, #1
  401842:	d102      	bne.n	40184a <_sbrk_r+0x1a>
  401844:	6823      	ldr	r3, [r4, #0]
  401846:	b103      	cbz	r3, 40184a <_sbrk_r+0x1a>
  401848:	602b      	str	r3, [r5, #0]
  40184a:	bd38      	pop	{r3, r4, r5, pc}
  40184c:	204000f0 	.word	0x204000f0

00401850 <setbuf>:
  401850:	2900      	cmp	r1, #0
  401852:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401856:	bf0c      	ite	eq
  401858:	2202      	moveq	r2, #2
  40185a:	2200      	movne	r2, #0
  40185c:	f000 b800 	b.w	401860 <setvbuf>

00401860 <setvbuf>:
  401860:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  401864:	461d      	mov	r5, r3
  401866:	4b51      	ldr	r3, [pc, #324]	; (4019ac <setvbuf+0x14c>)
  401868:	681e      	ldr	r6, [r3, #0]
  40186a:	4604      	mov	r4, r0
  40186c:	460f      	mov	r7, r1
  40186e:	4690      	mov	r8, r2
  401870:	b126      	cbz	r6, 40187c <setvbuf+0x1c>
  401872:	69b3      	ldr	r3, [r6, #24]
  401874:	b913      	cbnz	r3, 40187c <setvbuf+0x1c>
  401876:	4630      	mov	r0, r6
  401878:	f000 f992 	bl	401ba0 <__sinit>
  40187c:	4b4c      	ldr	r3, [pc, #304]	; (4019b0 <setvbuf+0x150>)
  40187e:	429c      	cmp	r4, r3
  401880:	d152      	bne.n	401928 <setvbuf+0xc8>
  401882:	6874      	ldr	r4, [r6, #4]
  401884:	f1b8 0f02 	cmp.w	r8, #2
  401888:	d006      	beq.n	401898 <setvbuf+0x38>
  40188a:	f1b8 0f01 	cmp.w	r8, #1
  40188e:	f200 8089 	bhi.w	4019a4 <setvbuf+0x144>
  401892:	2d00      	cmp	r5, #0
  401894:	f2c0 8086 	blt.w	4019a4 <setvbuf+0x144>
  401898:	4621      	mov	r1, r4
  40189a:	4630      	mov	r0, r6
  40189c:	f000 f916 	bl	401acc <_fflush_r>
  4018a0:	6b61      	ldr	r1, [r4, #52]	; 0x34
  4018a2:	b141      	cbz	r1, 4018b6 <setvbuf+0x56>
  4018a4:	f104 0344 	add.w	r3, r4, #68	; 0x44
  4018a8:	4299      	cmp	r1, r3
  4018aa:	d002      	beq.n	4018b2 <setvbuf+0x52>
  4018ac:	4630      	mov	r0, r6
  4018ae:	f7ff ff13 	bl	4016d8 <_free_r>
  4018b2:	2300      	movs	r3, #0
  4018b4:	6363      	str	r3, [r4, #52]	; 0x34
  4018b6:	2300      	movs	r3, #0
  4018b8:	61a3      	str	r3, [r4, #24]
  4018ba:	6063      	str	r3, [r4, #4]
  4018bc:	89a3      	ldrh	r3, [r4, #12]
  4018be:	061b      	lsls	r3, r3, #24
  4018c0:	d503      	bpl.n	4018ca <setvbuf+0x6a>
  4018c2:	6921      	ldr	r1, [r4, #16]
  4018c4:	4630      	mov	r0, r6
  4018c6:	f7ff ff07 	bl	4016d8 <_free_r>
  4018ca:	89a3      	ldrh	r3, [r4, #12]
  4018cc:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  4018d0:	f023 0303 	bic.w	r3, r3, #3
  4018d4:	f1b8 0f02 	cmp.w	r8, #2
  4018d8:	81a3      	strh	r3, [r4, #12]
  4018da:	d05d      	beq.n	401998 <setvbuf+0x138>
  4018dc:	ab01      	add	r3, sp, #4
  4018de:	466a      	mov	r2, sp
  4018e0:	4621      	mov	r1, r4
  4018e2:	4630      	mov	r0, r6
  4018e4:	f000 f9e6 	bl	401cb4 <__swhatbuf_r>
  4018e8:	89a3      	ldrh	r3, [r4, #12]
  4018ea:	4318      	orrs	r0, r3
  4018ec:	81a0      	strh	r0, [r4, #12]
  4018ee:	bb2d      	cbnz	r5, 40193c <setvbuf+0xdc>
  4018f0:	9d00      	ldr	r5, [sp, #0]
  4018f2:	4628      	mov	r0, r5
  4018f4:	f7ff fee0 	bl	4016b8 <malloc>
  4018f8:	4607      	mov	r7, r0
  4018fa:	2800      	cmp	r0, #0
  4018fc:	d14e      	bne.n	40199c <setvbuf+0x13c>
  4018fe:	f8dd 9000 	ldr.w	r9, [sp]
  401902:	45a9      	cmp	r9, r5
  401904:	d13c      	bne.n	401980 <setvbuf+0x120>
  401906:	f04f 30ff 	mov.w	r0, #4294967295
  40190a:	89a3      	ldrh	r3, [r4, #12]
  40190c:	f043 0302 	orr.w	r3, r3, #2
  401910:	81a3      	strh	r3, [r4, #12]
  401912:	2300      	movs	r3, #0
  401914:	60a3      	str	r3, [r4, #8]
  401916:	f104 0347 	add.w	r3, r4, #71	; 0x47
  40191a:	6023      	str	r3, [r4, #0]
  40191c:	6123      	str	r3, [r4, #16]
  40191e:	2301      	movs	r3, #1
  401920:	6163      	str	r3, [r4, #20]
  401922:	b003      	add	sp, #12
  401924:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401928:	4b22      	ldr	r3, [pc, #136]	; (4019b4 <setvbuf+0x154>)
  40192a:	429c      	cmp	r4, r3
  40192c:	d101      	bne.n	401932 <setvbuf+0xd2>
  40192e:	68b4      	ldr	r4, [r6, #8]
  401930:	e7a8      	b.n	401884 <setvbuf+0x24>
  401932:	4b21      	ldr	r3, [pc, #132]	; (4019b8 <setvbuf+0x158>)
  401934:	429c      	cmp	r4, r3
  401936:	bf08      	it	eq
  401938:	68f4      	ldreq	r4, [r6, #12]
  40193a:	e7a3      	b.n	401884 <setvbuf+0x24>
  40193c:	2f00      	cmp	r7, #0
  40193e:	d0d8      	beq.n	4018f2 <setvbuf+0x92>
  401940:	69b3      	ldr	r3, [r6, #24]
  401942:	b913      	cbnz	r3, 40194a <setvbuf+0xea>
  401944:	4630      	mov	r0, r6
  401946:	f000 f92b 	bl	401ba0 <__sinit>
  40194a:	f1b8 0f01 	cmp.w	r8, #1
  40194e:	bf08      	it	eq
  401950:	89a3      	ldrheq	r3, [r4, #12]
  401952:	6027      	str	r7, [r4, #0]
  401954:	bf04      	itt	eq
  401956:	f043 0301 	orreq.w	r3, r3, #1
  40195a:	81a3      	strheq	r3, [r4, #12]
  40195c:	89a3      	ldrh	r3, [r4, #12]
  40195e:	6127      	str	r7, [r4, #16]
  401960:	f013 0008 	ands.w	r0, r3, #8
  401964:	6165      	str	r5, [r4, #20]
  401966:	d01b      	beq.n	4019a0 <setvbuf+0x140>
  401968:	f013 0001 	ands.w	r0, r3, #1
  40196c:	bf18      	it	ne
  40196e:	426d      	negne	r5, r5
  401970:	f04f 0300 	mov.w	r3, #0
  401974:	bf1d      	ittte	ne
  401976:	60a3      	strne	r3, [r4, #8]
  401978:	61a5      	strne	r5, [r4, #24]
  40197a:	4618      	movne	r0, r3
  40197c:	60a5      	streq	r5, [r4, #8]
  40197e:	e7d0      	b.n	401922 <setvbuf+0xc2>
  401980:	4648      	mov	r0, r9
  401982:	f7ff fe99 	bl	4016b8 <malloc>
  401986:	4607      	mov	r7, r0
  401988:	2800      	cmp	r0, #0
  40198a:	d0bc      	beq.n	401906 <setvbuf+0xa6>
  40198c:	89a3      	ldrh	r3, [r4, #12]
  40198e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  401992:	81a3      	strh	r3, [r4, #12]
  401994:	464d      	mov	r5, r9
  401996:	e7d3      	b.n	401940 <setvbuf+0xe0>
  401998:	2000      	movs	r0, #0
  40199a:	e7b6      	b.n	40190a <setvbuf+0xaa>
  40199c:	46a9      	mov	r9, r5
  40199e:	e7f5      	b.n	40198c <setvbuf+0x12c>
  4019a0:	60a0      	str	r0, [r4, #8]
  4019a2:	e7be      	b.n	401922 <setvbuf+0xc2>
  4019a4:	f04f 30ff 	mov.w	r0, #4294967295
  4019a8:	e7bb      	b.n	401922 <setvbuf+0xc2>
  4019aa:	bf00      	nop
  4019ac:	20400000 	.word	0x20400000
  4019b0:	00401fb8 	.word	0x00401fb8
  4019b4:	00401fd8 	.word	0x00401fd8
  4019b8:	00401f98 	.word	0x00401f98

004019bc <__sflush_r>:
  4019bc:	898a      	ldrh	r2, [r1, #12]
  4019be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4019c2:	4605      	mov	r5, r0
  4019c4:	0710      	lsls	r0, r2, #28
  4019c6:	460c      	mov	r4, r1
  4019c8:	d45a      	bmi.n	401a80 <__sflush_r+0xc4>
  4019ca:	684b      	ldr	r3, [r1, #4]
  4019cc:	2b00      	cmp	r3, #0
  4019ce:	dc05      	bgt.n	4019dc <__sflush_r+0x20>
  4019d0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  4019d2:	2b00      	cmp	r3, #0
  4019d4:	dc02      	bgt.n	4019dc <__sflush_r+0x20>
  4019d6:	2000      	movs	r0, #0
  4019d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4019dc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  4019de:	2e00      	cmp	r6, #0
  4019e0:	d0f9      	beq.n	4019d6 <__sflush_r+0x1a>
  4019e2:	2300      	movs	r3, #0
  4019e4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  4019e8:	682f      	ldr	r7, [r5, #0]
  4019ea:	602b      	str	r3, [r5, #0]
  4019ec:	d033      	beq.n	401a56 <__sflush_r+0x9a>
  4019ee:	6d60      	ldr	r0, [r4, #84]	; 0x54
  4019f0:	89a3      	ldrh	r3, [r4, #12]
  4019f2:	075a      	lsls	r2, r3, #29
  4019f4:	d505      	bpl.n	401a02 <__sflush_r+0x46>
  4019f6:	6863      	ldr	r3, [r4, #4]
  4019f8:	1ac0      	subs	r0, r0, r3
  4019fa:	6b63      	ldr	r3, [r4, #52]	; 0x34
  4019fc:	b10b      	cbz	r3, 401a02 <__sflush_r+0x46>
  4019fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
  401a00:	1ac0      	subs	r0, r0, r3
  401a02:	2300      	movs	r3, #0
  401a04:	4602      	mov	r2, r0
  401a06:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  401a08:	6a21      	ldr	r1, [r4, #32]
  401a0a:	4628      	mov	r0, r5
  401a0c:	47b0      	blx	r6
  401a0e:	1c43      	adds	r3, r0, #1
  401a10:	89a3      	ldrh	r3, [r4, #12]
  401a12:	d106      	bne.n	401a22 <__sflush_r+0x66>
  401a14:	6829      	ldr	r1, [r5, #0]
  401a16:	291d      	cmp	r1, #29
  401a18:	d84b      	bhi.n	401ab2 <__sflush_r+0xf6>
  401a1a:	4a2b      	ldr	r2, [pc, #172]	; (401ac8 <__sflush_r+0x10c>)
  401a1c:	40ca      	lsrs	r2, r1
  401a1e:	07d6      	lsls	r6, r2, #31
  401a20:	d547      	bpl.n	401ab2 <__sflush_r+0xf6>
  401a22:	2200      	movs	r2, #0
  401a24:	6062      	str	r2, [r4, #4]
  401a26:	04d9      	lsls	r1, r3, #19
  401a28:	6922      	ldr	r2, [r4, #16]
  401a2a:	6022      	str	r2, [r4, #0]
  401a2c:	d504      	bpl.n	401a38 <__sflush_r+0x7c>
  401a2e:	1c42      	adds	r2, r0, #1
  401a30:	d101      	bne.n	401a36 <__sflush_r+0x7a>
  401a32:	682b      	ldr	r3, [r5, #0]
  401a34:	b903      	cbnz	r3, 401a38 <__sflush_r+0x7c>
  401a36:	6560      	str	r0, [r4, #84]	; 0x54
  401a38:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401a3a:	602f      	str	r7, [r5, #0]
  401a3c:	2900      	cmp	r1, #0
  401a3e:	d0ca      	beq.n	4019d6 <__sflush_r+0x1a>
  401a40:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401a44:	4299      	cmp	r1, r3
  401a46:	d002      	beq.n	401a4e <__sflush_r+0x92>
  401a48:	4628      	mov	r0, r5
  401a4a:	f7ff fe45 	bl	4016d8 <_free_r>
  401a4e:	2000      	movs	r0, #0
  401a50:	6360      	str	r0, [r4, #52]	; 0x34
  401a52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401a56:	6a21      	ldr	r1, [r4, #32]
  401a58:	2301      	movs	r3, #1
  401a5a:	4628      	mov	r0, r5
  401a5c:	47b0      	blx	r6
  401a5e:	1c41      	adds	r1, r0, #1
  401a60:	d1c6      	bne.n	4019f0 <__sflush_r+0x34>
  401a62:	682b      	ldr	r3, [r5, #0]
  401a64:	2b00      	cmp	r3, #0
  401a66:	d0c3      	beq.n	4019f0 <__sflush_r+0x34>
  401a68:	2b1d      	cmp	r3, #29
  401a6a:	d001      	beq.n	401a70 <__sflush_r+0xb4>
  401a6c:	2b16      	cmp	r3, #22
  401a6e:	d101      	bne.n	401a74 <__sflush_r+0xb8>
  401a70:	602f      	str	r7, [r5, #0]
  401a72:	e7b0      	b.n	4019d6 <__sflush_r+0x1a>
  401a74:	89a3      	ldrh	r3, [r4, #12]
  401a76:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401a7a:	81a3      	strh	r3, [r4, #12]
  401a7c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401a80:	690f      	ldr	r7, [r1, #16]
  401a82:	2f00      	cmp	r7, #0
  401a84:	d0a7      	beq.n	4019d6 <__sflush_r+0x1a>
  401a86:	0793      	lsls	r3, r2, #30
  401a88:	680e      	ldr	r6, [r1, #0]
  401a8a:	bf08      	it	eq
  401a8c:	694b      	ldreq	r3, [r1, #20]
  401a8e:	600f      	str	r7, [r1, #0]
  401a90:	bf18      	it	ne
  401a92:	2300      	movne	r3, #0
  401a94:	eba6 0807 	sub.w	r8, r6, r7
  401a98:	608b      	str	r3, [r1, #8]
  401a9a:	f1b8 0f00 	cmp.w	r8, #0
  401a9e:	dd9a      	ble.n	4019d6 <__sflush_r+0x1a>
  401aa0:	4643      	mov	r3, r8
  401aa2:	463a      	mov	r2, r7
  401aa4:	6a21      	ldr	r1, [r4, #32]
  401aa6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  401aa8:	4628      	mov	r0, r5
  401aaa:	47b0      	blx	r6
  401aac:	2800      	cmp	r0, #0
  401aae:	dc07      	bgt.n	401ac0 <__sflush_r+0x104>
  401ab0:	89a3      	ldrh	r3, [r4, #12]
  401ab2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401ab6:	81a3      	strh	r3, [r4, #12]
  401ab8:	f04f 30ff 	mov.w	r0, #4294967295
  401abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401ac0:	4407      	add	r7, r0
  401ac2:	eba8 0800 	sub.w	r8, r8, r0
  401ac6:	e7e8      	b.n	401a9a <__sflush_r+0xde>
  401ac8:	20400001 	.word	0x20400001

00401acc <_fflush_r>:
  401acc:	b538      	push	{r3, r4, r5, lr}
  401ace:	690b      	ldr	r3, [r1, #16]
  401ad0:	4605      	mov	r5, r0
  401ad2:	460c      	mov	r4, r1
  401ad4:	b1db      	cbz	r3, 401b0e <_fflush_r+0x42>
  401ad6:	b118      	cbz	r0, 401ae0 <_fflush_r+0x14>
  401ad8:	6983      	ldr	r3, [r0, #24]
  401ada:	b90b      	cbnz	r3, 401ae0 <_fflush_r+0x14>
  401adc:	f000 f860 	bl	401ba0 <__sinit>
  401ae0:	4b0c      	ldr	r3, [pc, #48]	; (401b14 <_fflush_r+0x48>)
  401ae2:	429c      	cmp	r4, r3
  401ae4:	d109      	bne.n	401afa <_fflush_r+0x2e>
  401ae6:	686c      	ldr	r4, [r5, #4]
  401ae8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401aec:	b17b      	cbz	r3, 401b0e <_fflush_r+0x42>
  401aee:	4621      	mov	r1, r4
  401af0:	4628      	mov	r0, r5
  401af2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  401af6:	f7ff bf61 	b.w	4019bc <__sflush_r>
  401afa:	4b07      	ldr	r3, [pc, #28]	; (401b18 <_fflush_r+0x4c>)
  401afc:	429c      	cmp	r4, r3
  401afe:	d101      	bne.n	401b04 <_fflush_r+0x38>
  401b00:	68ac      	ldr	r4, [r5, #8]
  401b02:	e7f1      	b.n	401ae8 <_fflush_r+0x1c>
  401b04:	4b05      	ldr	r3, [pc, #20]	; (401b1c <_fflush_r+0x50>)
  401b06:	429c      	cmp	r4, r3
  401b08:	bf08      	it	eq
  401b0a:	68ec      	ldreq	r4, [r5, #12]
  401b0c:	e7ec      	b.n	401ae8 <_fflush_r+0x1c>
  401b0e:	2000      	movs	r0, #0
  401b10:	bd38      	pop	{r3, r4, r5, pc}
  401b12:	bf00      	nop
  401b14:	00401fb8 	.word	0x00401fb8
  401b18:	00401fd8 	.word	0x00401fd8
  401b1c:	00401f98 	.word	0x00401f98

00401b20 <_cleanup_r>:
  401b20:	4901      	ldr	r1, [pc, #4]	; (401b28 <_cleanup_r+0x8>)
  401b22:	f000 b8a9 	b.w	401c78 <_fwalk_reent>
  401b26:	bf00      	nop
  401b28:	00401acd 	.word	0x00401acd

00401b2c <std.isra.0>:
  401b2c:	2300      	movs	r3, #0
  401b2e:	b510      	push	{r4, lr}
  401b30:	4604      	mov	r4, r0
  401b32:	6003      	str	r3, [r0, #0]
  401b34:	6043      	str	r3, [r0, #4]
  401b36:	6083      	str	r3, [r0, #8]
  401b38:	8181      	strh	r1, [r0, #12]
  401b3a:	6643      	str	r3, [r0, #100]	; 0x64
  401b3c:	81c2      	strh	r2, [r0, #14]
  401b3e:	6103      	str	r3, [r0, #16]
  401b40:	6143      	str	r3, [r0, #20]
  401b42:	6183      	str	r3, [r0, #24]
  401b44:	4619      	mov	r1, r3
  401b46:	2208      	movs	r2, #8
  401b48:	305c      	adds	r0, #92	; 0x5c
  401b4a:	f7ff fdbd 	bl	4016c8 <memset>
  401b4e:	4b05      	ldr	r3, [pc, #20]	; (401b64 <std.isra.0+0x38>)
  401b50:	6263      	str	r3, [r4, #36]	; 0x24
  401b52:	4b05      	ldr	r3, [pc, #20]	; (401b68 <std.isra.0+0x3c>)
  401b54:	62a3      	str	r3, [r4, #40]	; 0x28
  401b56:	4b05      	ldr	r3, [pc, #20]	; (401b6c <std.isra.0+0x40>)
  401b58:	62e3      	str	r3, [r4, #44]	; 0x2c
  401b5a:	4b05      	ldr	r3, [pc, #20]	; (401b70 <std.isra.0+0x44>)
  401b5c:	6224      	str	r4, [r4, #32]
  401b5e:	6323      	str	r3, [r4, #48]	; 0x30
  401b60:	bd10      	pop	{r4, pc}
  401b62:	bf00      	nop
  401b64:	00401d01 	.word	0x00401d01
  401b68:	00401d23 	.word	0x00401d23
  401b6c:	00401d5b 	.word	0x00401d5b
  401b70:	00401d7f 	.word	0x00401d7f

00401b74 <__sfmoreglue>:
  401b74:	b570      	push	{r4, r5, r6, lr}
  401b76:	1e4a      	subs	r2, r1, #1
  401b78:	2568      	movs	r5, #104	; 0x68
  401b7a:	4355      	muls	r5, r2
  401b7c:	460e      	mov	r6, r1
  401b7e:	f105 0174 	add.w	r1, r5, #116	; 0x74
  401b82:	f7ff fdf7 	bl	401774 <_malloc_r>
  401b86:	4604      	mov	r4, r0
  401b88:	b140      	cbz	r0, 401b9c <__sfmoreglue+0x28>
  401b8a:	2100      	movs	r1, #0
  401b8c:	e880 0042 	stmia.w	r0, {r1, r6}
  401b90:	300c      	adds	r0, #12
  401b92:	60a0      	str	r0, [r4, #8]
  401b94:	f105 0268 	add.w	r2, r5, #104	; 0x68
  401b98:	f7ff fd96 	bl	4016c8 <memset>
  401b9c:	4620      	mov	r0, r4
  401b9e:	bd70      	pop	{r4, r5, r6, pc}

00401ba0 <__sinit>:
  401ba0:	6983      	ldr	r3, [r0, #24]
  401ba2:	b510      	push	{r4, lr}
  401ba4:	4604      	mov	r4, r0
  401ba6:	bb33      	cbnz	r3, 401bf6 <__sinit+0x56>
  401ba8:	6483      	str	r3, [r0, #72]	; 0x48
  401baa:	64c3      	str	r3, [r0, #76]	; 0x4c
  401bac:	6503      	str	r3, [r0, #80]	; 0x50
  401bae:	4b12      	ldr	r3, [pc, #72]	; (401bf8 <__sinit+0x58>)
  401bb0:	4a12      	ldr	r2, [pc, #72]	; (401bfc <__sinit+0x5c>)
  401bb2:	681b      	ldr	r3, [r3, #0]
  401bb4:	6282      	str	r2, [r0, #40]	; 0x28
  401bb6:	4298      	cmp	r0, r3
  401bb8:	bf04      	itt	eq
  401bba:	2301      	moveq	r3, #1
  401bbc:	6183      	streq	r3, [r0, #24]
  401bbe:	f000 f81f 	bl	401c00 <__sfp>
  401bc2:	6060      	str	r0, [r4, #4]
  401bc4:	4620      	mov	r0, r4
  401bc6:	f000 f81b 	bl	401c00 <__sfp>
  401bca:	60a0      	str	r0, [r4, #8]
  401bcc:	4620      	mov	r0, r4
  401bce:	f000 f817 	bl	401c00 <__sfp>
  401bd2:	2200      	movs	r2, #0
  401bd4:	60e0      	str	r0, [r4, #12]
  401bd6:	2104      	movs	r1, #4
  401bd8:	6860      	ldr	r0, [r4, #4]
  401bda:	f7ff ffa7 	bl	401b2c <std.isra.0>
  401bde:	2201      	movs	r2, #1
  401be0:	2109      	movs	r1, #9
  401be2:	68a0      	ldr	r0, [r4, #8]
  401be4:	f7ff ffa2 	bl	401b2c <std.isra.0>
  401be8:	2202      	movs	r2, #2
  401bea:	2112      	movs	r1, #18
  401bec:	68e0      	ldr	r0, [r4, #12]
  401bee:	f7ff ff9d 	bl	401b2c <std.isra.0>
  401bf2:	2301      	movs	r3, #1
  401bf4:	61a3      	str	r3, [r4, #24]
  401bf6:	bd10      	pop	{r4, pc}
  401bf8:	00401f94 	.word	0x00401f94
  401bfc:	00401b21 	.word	0x00401b21

00401c00 <__sfp>:
  401c00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401c02:	4b1c      	ldr	r3, [pc, #112]	; (401c74 <__sfp+0x74>)
  401c04:	681e      	ldr	r6, [r3, #0]
  401c06:	69b3      	ldr	r3, [r6, #24]
  401c08:	4607      	mov	r7, r0
  401c0a:	b913      	cbnz	r3, 401c12 <__sfp+0x12>
  401c0c:	4630      	mov	r0, r6
  401c0e:	f7ff ffc7 	bl	401ba0 <__sinit>
  401c12:	3648      	adds	r6, #72	; 0x48
  401c14:	68b4      	ldr	r4, [r6, #8]
  401c16:	6873      	ldr	r3, [r6, #4]
  401c18:	3b01      	subs	r3, #1
  401c1a:	d503      	bpl.n	401c24 <__sfp+0x24>
  401c1c:	6833      	ldr	r3, [r6, #0]
  401c1e:	b133      	cbz	r3, 401c2e <__sfp+0x2e>
  401c20:	6836      	ldr	r6, [r6, #0]
  401c22:	e7f7      	b.n	401c14 <__sfp+0x14>
  401c24:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  401c28:	b16d      	cbz	r5, 401c46 <__sfp+0x46>
  401c2a:	3468      	adds	r4, #104	; 0x68
  401c2c:	e7f4      	b.n	401c18 <__sfp+0x18>
  401c2e:	2104      	movs	r1, #4
  401c30:	4638      	mov	r0, r7
  401c32:	f7ff ff9f 	bl	401b74 <__sfmoreglue>
  401c36:	6030      	str	r0, [r6, #0]
  401c38:	2800      	cmp	r0, #0
  401c3a:	d1f1      	bne.n	401c20 <__sfp+0x20>
  401c3c:	230c      	movs	r3, #12
  401c3e:	603b      	str	r3, [r7, #0]
  401c40:	4604      	mov	r4, r0
  401c42:	4620      	mov	r0, r4
  401c44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401c46:	f64f 73ff 	movw	r3, #65535	; 0xffff
  401c4a:	81e3      	strh	r3, [r4, #14]
  401c4c:	2301      	movs	r3, #1
  401c4e:	81a3      	strh	r3, [r4, #12]
  401c50:	6665      	str	r5, [r4, #100]	; 0x64
  401c52:	6025      	str	r5, [r4, #0]
  401c54:	60a5      	str	r5, [r4, #8]
  401c56:	6065      	str	r5, [r4, #4]
  401c58:	6125      	str	r5, [r4, #16]
  401c5a:	6165      	str	r5, [r4, #20]
  401c5c:	61a5      	str	r5, [r4, #24]
  401c5e:	2208      	movs	r2, #8
  401c60:	4629      	mov	r1, r5
  401c62:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  401c66:	f7ff fd2f 	bl	4016c8 <memset>
  401c6a:	6365      	str	r5, [r4, #52]	; 0x34
  401c6c:	63a5      	str	r5, [r4, #56]	; 0x38
  401c6e:	64a5      	str	r5, [r4, #72]	; 0x48
  401c70:	64e5      	str	r5, [r4, #76]	; 0x4c
  401c72:	e7e6      	b.n	401c42 <__sfp+0x42>
  401c74:	00401f94 	.word	0x00401f94

00401c78 <_fwalk_reent>:
  401c78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  401c7c:	4680      	mov	r8, r0
  401c7e:	4689      	mov	r9, r1
  401c80:	f100 0448 	add.w	r4, r0, #72	; 0x48
  401c84:	2600      	movs	r6, #0
  401c86:	b914      	cbnz	r4, 401c8e <_fwalk_reent+0x16>
  401c88:	4630      	mov	r0, r6
  401c8a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401c8e:	68a5      	ldr	r5, [r4, #8]
  401c90:	6867      	ldr	r7, [r4, #4]
  401c92:	3f01      	subs	r7, #1
  401c94:	d501      	bpl.n	401c9a <_fwalk_reent+0x22>
  401c96:	6824      	ldr	r4, [r4, #0]
  401c98:	e7f5      	b.n	401c86 <_fwalk_reent+0xe>
  401c9a:	89ab      	ldrh	r3, [r5, #12]
  401c9c:	2b01      	cmp	r3, #1
  401c9e:	d907      	bls.n	401cb0 <_fwalk_reent+0x38>
  401ca0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  401ca4:	3301      	adds	r3, #1
  401ca6:	d003      	beq.n	401cb0 <_fwalk_reent+0x38>
  401ca8:	4629      	mov	r1, r5
  401caa:	4640      	mov	r0, r8
  401cac:	47c8      	blx	r9
  401cae:	4306      	orrs	r6, r0
  401cb0:	3568      	adds	r5, #104	; 0x68
  401cb2:	e7ee      	b.n	401c92 <_fwalk_reent+0x1a>

00401cb4 <__swhatbuf_r>:
  401cb4:	b570      	push	{r4, r5, r6, lr}
  401cb6:	460e      	mov	r6, r1
  401cb8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401cbc:	2900      	cmp	r1, #0
  401cbe:	b090      	sub	sp, #64	; 0x40
  401cc0:	4614      	mov	r4, r2
  401cc2:	461d      	mov	r5, r3
  401cc4:	da07      	bge.n	401cd6 <__swhatbuf_r+0x22>
  401cc6:	2300      	movs	r3, #0
  401cc8:	602b      	str	r3, [r5, #0]
  401cca:	89b3      	ldrh	r3, [r6, #12]
  401ccc:	061a      	lsls	r2, r3, #24
  401cce:	d410      	bmi.n	401cf2 <__swhatbuf_r+0x3e>
  401cd0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401cd4:	e00e      	b.n	401cf4 <__swhatbuf_r+0x40>
  401cd6:	aa01      	add	r2, sp, #4
  401cd8:	f000 f878 	bl	401dcc <_fstat_r>
  401cdc:	2800      	cmp	r0, #0
  401cde:	dbf2      	blt.n	401cc6 <__swhatbuf_r+0x12>
  401ce0:	9a02      	ldr	r2, [sp, #8]
  401ce2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  401ce6:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  401cea:	425a      	negs	r2, r3
  401cec:	415a      	adcs	r2, r3
  401cee:	602a      	str	r2, [r5, #0]
  401cf0:	e7ee      	b.n	401cd0 <__swhatbuf_r+0x1c>
  401cf2:	2340      	movs	r3, #64	; 0x40
  401cf4:	2000      	movs	r0, #0
  401cf6:	6023      	str	r3, [r4, #0]
  401cf8:	b010      	add	sp, #64	; 0x40
  401cfa:	bd70      	pop	{r4, r5, r6, pc}

00401cfc <__malloc_lock>:
  401cfc:	4770      	bx	lr

00401cfe <__malloc_unlock>:
  401cfe:	4770      	bx	lr

00401d00 <__sread>:
  401d00:	b510      	push	{r4, lr}
  401d02:	460c      	mov	r4, r1
  401d04:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401d08:	f000 f884 	bl	401e14 <_read_r>
  401d0c:	2800      	cmp	r0, #0
  401d0e:	bfab      	itete	ge
  401d10:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  401d12:	89a3      	ldrhlt	r3, [r4, #12]
  401d14:	181b      	addge	r3, r3, r0
  401d16:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  401d1a:	bfac      	ite	ge
  401d1c:	6563      	strge	r3, [r4, #84]	; 0x54
  401d1e:	81a3      	strhlt	r3, [r4, #12]
  401d20:	bd10      	pop	{r4, pc}

00401d22 <__swrite>:
  401d22:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401d26:	461f      	mov	r7, r3
  401d28:	898b      	ldrh	r3, [r1, #12]
  401d2a:	05db      	lsls	r3, r3, #23
  401d2c:	4605      	mov	r5, r0
  401d2e:	460c      	mov	r4, r1
  401d30:	4616      	mov	r6, r2
  401d32:	d505      	bpl.n	401d40 <__swrite+0x1e>
  401d34:	2302      	movs	r3, #2
  401d36:	2200      	movs	r2, #0
  401d38:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401d3c:	f000 f858 	bl	401df0 <_lseek_r>
  401d40:	89a3      	ldrh	r3, [r4, #12]
  401d42:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  401d46:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  401d4a:	81a3      	strh	r3, [r4, #12]
  401d4c:	4632      	mov	r2, r6
  401d4e:	463b      	mov	r3, r7
  401d50:	4628      	mov	r0, r5
  401d52:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  401d56:	f000 b817 	b.w	401d88 <_write_r>

00401d5a <__sseek>:
  401d5a:	b510      	push	{r4, lr}
  401d5c:	460c      	mov	r4, r1
  401d5e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401d62:	f000 f845 	bl	401df0 <_lseek_r>
  401d66:	1c43      	adds	r3, r0, #1
  401d68:	89a3      	ldrh	r3, [r4, #12]
  401d6a:	bf15      	itete	ne
  401d6c:	6560      	strne	r0, [r4, #84]	; 0x54
  401d6e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  401d72:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  401d76:	81a3      	strheq	r3, [r4, #12]
  401d78:	bf18      	it	ne
  401d7a:	81a3      	strhne	r3, [r4, #12]
  401d7c:	bd10      	pop	{r4, pc}

00401d7e <__sclose>:
  401d7e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401d82:	f000 b813 	b.w	401dac <_close_r>
	...

00401d88 <_write_r>:
  401d88:	b538      	push	{r3, r4, r5, lr}
  401d8a:	4c07      	ldr	r4, [pc, #28]	; (401da8 <_write_r+0x20>)
  401d8c:	4605      	mov	r5, r0
  401d8e:	4608      	mov	r0, r1
  401d90:	4611      	mov	r1, r2
  401d92:	2200      	movs	r2, #0
  401d94:	6022      	str	r2, [r4, #0]
  401d96:	461a      	mov	r2, r3
  401d98:	f7ff fc0c 	bl	4015b4 <_write>
  401d9c:	1c43      	adds	r3, r0, #1
  401d9e:	d102      	bne.n	401da6 <_write_r+0x1e>
  401da0:	6823      	ldr	r3, [r4, #0]
  401da2:	b103      	cbz	r3, 401da6 <_write_r+0x1e>
  401da4:	602b      	str	r3, [r5, #0]
  401da6:	bd38      	pop	{r3, r4, r5, pc}
  401da8:	204000f0 	.word	0x204000f0

00401dac <_close_r>:
  401dac:	b538      	push	{r3, r4, r5, lr}
  401dae:	4c06      	ldr	r4, [pc, #24]	; (401dc8 <_close_r+0x1c>)
  401db0:	2300      	movs	r3, #0
  401db2:	4605      	mov	r5, r0
  401db4:	4608      	mov	r0, r1
  401db6:	6023      	str	r3, [r4, #0]
  401db8:	f7fe fe0e 	bl	4009d8 <_close>
  401dbc:	1c43      	adds	r3, r0, #1
  401dbe:	d102      	bne.n	401dc6 <_close_r+0x1a>
  401dc0:	6823      	ldr	r3, [r4, #0]
  401dc2:	b103      	cbz	r3, 401dc6 <_close_r+0x1a>
  401dc4:	602b      	str	r3, [r5, #0]
  401dc6:	bd38      	pop	{r3, r4, r5, pc}
  401dc8:	204000f0 	.word	0x204000f0

00401dcc <_fstat_r>:
  401dcc:	b538      	push	{r3, r4, r5, lr}
  401dce:	4c07      	ldr	r4, [pc, #28]	; (401dec <_fstat_r+0x20>)
  401dd0:	2300      	movs	r3, #0
  401dd2:	4605      	mov	r5, r0
  401dd4:	4608      	mov	r0, r1
  401dd6:	4611      	mov	r1, r2
  401dd8:	6023      	str	r3, [r4, #0]
  401dda:	f7fe fe00 	bl	4009de <_fstat>
  401dde:	1c43      	adds	r3, r0, #1
  401de0:	d102      	bne.n	401de8 <_fstat_r+0x1c>
  401de2:	6823      	ldr	r3, [r4, #0]
  401de4:	b103      	cbz	r3, 401de8 <_fstat_r+0x1c>
  401de6:	602b      	str	r3, [r5, #0]
  401de8:	bd38      	pop	{r3, r4, r5, pc}
  401dea:	bf00      	nop
  401dec:	204000f0 	.word	0x204000f0

00401df0 <_lseek_r>:
  401df0:	b538      	push	{r3, r4, r5, lr}
  401df2:	4c07      	ldr	r4, [pc, #28]	; (401e10 <_lseek_r+0x20>)
  401df4:	4605      	mov	r5, r0
  401df6:	4608      	mov	r0, r1
  401df8:	4611      	mov	r1, r2
  401dfa:	2200      	movs	r2, #0
  401dfc:	6022      	str	r2, [r4, #0]
  401dfe:	461a      	mov	r2, r3
  401e00:	f7fe fdf2 	bl	4009e8 <_lseek>
  401e04:	1c43      	adds	r3, r0, #1
  401e06:	d102      	bne.n	401e0e <_lseek_r+0x1e>
  401e08:	6823      	ldr	r3, [r4, #0]
  401e0a:	b103      	cbz	r3, 401e0e <_lseek_r+0x1e>
  401e0c:	602b      	str	r3, [r5, #0]
  401e0e:	bd38      	pop	{r3, r4, r5, pc}
  401e10:	204000f0 	.word	0x204000f0

00401e14 <_read_r>:
  401e14:	b538      	push	{r3, r4, r5, lr}
  401e16:	4c07      	ldr	r4, [pc, #28]	; (401e34 <_read_r+0x20>)
  401e18:	4605      	mov	r5, r0
  401e1a:	4608      	mov	r0, r1
  401e1c:	4611      	mov	r1, r2
  401e1e:	2200      	movs	r2, #0
  401e20:	6022      	str	r2, [r4, #0]
  401e22:	461a      	mov	r2, r3
  401e24:	f7ff fbb4 	bl	401590 <_read>
  401e28:	1c43      	adds	r3, r0, #1
  401e2a:	d102      	bne.n	401e32 <_read_r+0x1e>
  401e2c:	6823      	ldr	r3, [r4, #0]
  401e2e:	b103      	cbz	r3, 401e32 <_read_r+0x1e>
  401e30:	602b      	str	r3, [r5, #0]
  401e32:	bd38      	pop	{r3, r4, r5, pc}
  401e34:	204000f0 	.word	0x204000f0
  401e38:	682f2e2e 	.word	0x682f2e2e
  401e3c:	732f6c61 	.word	0x732f6c61
  401e40:	682f6372 	.word	0x682f6372
  401e44:	695f6c61 	.word	0x695f6c61
  401e48:	6d5f6332 	.word	0x6d5f6332
  401e4c:	6e79735f 	.word	0x6e79735f
  401e50:	00632e63 	.word	0x00632e63
  401e54:	682f2e2e 	.word	0x682f2e2e
  401e58:	732f6c61 	.word	0x732f6c61
  401e5c:	682f6372 	.word	0x682f6372
  401e60:	695f6c61 	.word	0x695f6c61
  401e64:	00632e6f 	.word	0x00632e6f
  401e68:	682f2e2e 	.word	0x682f2e2e
  401e6c:	732f6c61 	.word	0x732f6c61
  401e70:	682f6372 	.word	0x682f6372
  401e74:	735f6c61 	.word	0x735f6c61
  401e78:	6d5f6970 	.word	0x6d5f6970
  401e7c:	6e79735f 	.word	0x6e79735f
  401e80:	00632e63 	.word	0x00632e63
  401e84:	682f2e2e 	.word	0x682f2e2e
  401e88:	732f6c61 	.word	0x732f6c61
  401e8c:	682f6372 	.word	0x682f6372
  401e90:	755f6c61 	.word	0x755f6c61
  401e94:	74726173 	.word	0x74726173
  401e98:	6e79735f 	.word	0x6e79735f
  401e9c:	00632e63 	.word	0x00632e63

00401ea0 <_ext_irq>:
  401ea0:	00000000 00000020 00000020 00000020     .... ... ... ...
	...
  401eb8:	00000020 00000001 00000002 00000002      ...............
  401ec8:	00000002 00000000 00000000 00000002     ................

00401ed8 <_pio_irq_n>:
  401ed8:	100c0b0a 00000011 682f2e2e 702f6c70     ........../hpl/p
  401ee8:	682f6f69 705f6c70 655f6f69 632e7478     io/hpl_pio_ext.c
  401ef8:	00000000                                ....

00401efc <spi_regs>:
  401efc:	00000000 80000000 00000001 0496fa02     ................
  401f0c:	0000ffff 682f2e2e 732f6c70 682f6970     ....../hpl/spi/h
  401f1c:	735f6c70 632e6970 00000000              pl_spi.c....

00401f28 <_i2cm_sync_cfgs>:
  401f28:	40018000 00000020 00000000 00000000     ...@ ...........
  401f38:	0002baba 000249f0 682f2e2e 742f6c70     .....I..../hpl/t
  401f48:	73686977 6c70682f 6977745f 632e7368     wihs/hpl_twihs.c
  401f58:	00000000                                ....

00401f5c <_usarts>:
  401f5c:	00000001 001008c0 000100f4 682f2e2e     ............../h
  401f6c:	752f6c70 74726173 6c70682f 6173755f     pl/usart/hpl_usa
  401f7c:	632e7472 00000000 6c6c6548 6f57206f     rt.c....Hello Wo
  401f8c:	21646c72 00000000                       rld!....

00401f94 <_global_impure_ptr>:
  401f94:	20400004                                ..@ 

00401f98 <__sf_fake_stderr>:
	...

00401fb8 <__sf_fake_stdin>:
	...

00401fd8 <__sf_fake_stdout>:
	...

00401ff8 <_init>:
  401ff8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401ffa:	bf00      	nop
  401ffc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  401ffe:	bc08      	pop	{r3}
  402000:	469e      	mov	lr, r3
  402002:	4770      	bx	lr

00402004 <__init_array_start>:
  402004:	0040018d 	.word	0x0040018d

00402008 <_fini>:
  402008:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40200a:	bf00      	nop
  40200c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40200e:	bc08      	pop	{r3}
  402010:	469e      	mov	lr, r3
  402012:	4770      	bx	lr

00402014 <__fini_array_start>:
  402014:	00400169 	.word	0x00400169
