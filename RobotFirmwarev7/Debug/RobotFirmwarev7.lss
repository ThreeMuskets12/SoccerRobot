
RobotFirmwarev7.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000029a8  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000064  20400000  004029a8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000090  20400064  00402a0c  00020064  2**2
                  ALLOC
  3 .heap         00000204  204000f4  00402a9c  00020064  2**0
                  ALLOC
  4 .stack        00000400  204002f8  00402ca0  00020064  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020064  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020092  2**0
                  CONTENTS, READONLY
  7 .debug_info   00018040  00000000  00000000  000200eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000374f  00000000  00000000  0003812b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00008d25  00000000  00000000  0003b87a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000ae0  00000000  00000000  0004459f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000009d8  00000000  00000000  0004507f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00042594  00000000  00000000  00045a57  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00016adc  00000000  00000000  00087feb  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0014d3ed  00000000  00000000  0009eac7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000022f8  00000000  00000000  001ebeb4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	f8 06 40 20 ed 01 40 00 e9 01 40 00 e9 01 40 00     ..@ ..@...@...@.
  400010:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e9 01 40 00 e9 01 40 00 00 00 00 00 e9 01 40 00     ..@...@.......@.
  40003c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40004c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40005c:	e9 01 40 00 e9 01 40 00 00 00 00 00 4d 0c 40 00     ..@...@.....M.@.
  40006c:	59 0c 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     Y.@...@...@...@.
  40007c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40008c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40009c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ac:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000bc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000cc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000dc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ec:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000fc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40010c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ......@...@...@.
  40012c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40013c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40014c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40015c:	e9 01 40 00 e9 01 40 00 e9 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400064 	.word	0x20400064
  400184:	00000000 	.word	0x00000000
  400188:	004029a8 	.word	0x004029a8

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	004029a8 	.word	0x004029a8
  4001c8:	20400068 	.word	0x20400068
  4001cc:	004029a8 	.word	0x004029a8
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b02      	ldr	r3, [pc, #8]	; (4001e0 <atmel_start_init+0xc>)
  4001d8:	4798      	blx	r3
	stdio_redirect_init();
  4001da:	4b02      	ldr	r3, [pc, #8]	; (4001e4 <atmel_start_init+0x10>)
  4001dc:	4798      	blx	r3
  4001de:	bd08      	pop	{r3, pc}
  4001e0:	0040043d 	.word	0x0040043d
  4001e4:	00401715 	.word	0x00401715

004001e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e8:	e7fe      	b.n	4001e8 <Dummy_Handler>
	...

004001ec <Reset_Handler>:
{
  4001ec:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001ee:	4b10      	ldr	r3, [pc, #64]	; (400230 <Reset_Handler+0x44>)
  4001f0:	4a10      	ldr	r2, [pc, #64]	; (400234 <Reset_Handler+0x48>)
  4001f2:	429a      	cmp	r2, r3
  4001f4:	d009      	beq.n	40020a <Reset_Handler+0x1e>
  4001f6:	4b0e      	ldr	r3, [pc, #56]	; (400230 <Reset_Handler+0x44>)
  4001f8:	4a0e      	ldr	r2, [pc, #56]	; (400234 <Reset_Handler+0x48>)
  4001fa:	e003      	b.n	400204 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001fc:	6811      	ldr	r1, [r2, #0]
  4001fe:	6019      	str	r1, [r3, #0]
  400200:	3304      	adds	r3, #4
  400202:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  400204:	490c      	ldr	r1, [pc, #48]	; (400238 <Reset_Handler+0x4c>)
  400206:	428b      	cmp	r3, r1
  400208:	d3f8      	bcc.n	4001fc <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  40020a:	4b0c      	ldr	r3, [pc, #48]	; (40023c <Reset_Handler+0x50>)
  40020c:	e002      	b.n	400214 <Reset_Handler+0x28>
                *pDest++ = 0;
  40020e:	2200      	movs	r2, #0
  400210:	601a      	str	r2, [r3, #0]
  400212:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  400214:	4a0a      	ldr	r2, [pc, #40]	; (400240 <Reset_Handler+0x54>)
  400216:	4293      	cmp	r3, r2
  400218:	d3f9      	bcc.n	40020e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40021a:	4a0a      	ldr	r2, [pc, #40]	; (400244 <Reset_Handler+0x58>)
  40021c:	4b0a      	ldr	r3, [pc, #40]	; (400248 <Reset_Handler+0x5c>)
  40021e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400222:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  400224:	4b09      	ldr	r3, [pc, #36]	; (40024c <Reset_Handler+0x60>)
  400226:	4798      	blx	r3
        main();
  400228:	4b09      	ldr	r3, [pc, #36]	; (400250 <Reset_Handler+0x64>)
  40022a:	4798      	blx	r3
  40022c:	e7fe      	b.n	40022c <Reset_Handler+0x40>
  40022e:	bf00      	nop
  400230:	20400000 	.word	0x20400000
  400234:	004029a8 	.word	0x004029a8
  400238:	20400064 	.word	0x20400064
  40023c:	20400064 	.word	0x20400064
  400240:	204000f4 	.word	0x204000f4
  400244:	e000ed00 	.word	0xe000ed00
  400248:	00400000 	.word	0x00400000
  40024c:	00401735 	.word	0x00401735
  400250:	0040139d 	.word	0x0040139d

00400254 <EXTERNAL_IRQ_0_init>:
	((Pio *)hw)->PIO_ODR = ~data;
}

static inline void hri_pio_clear_OSR_reg(const void *const hw, hri_pio_osr_reg_t mask)
{
	((Pio *)hw)->PIO_ODR = mask;
  400254:	4b03      	ldr	r3, [pc, #12]	; (400264 <EXTERNAL_IRQ_0_init+0x10>)
  400256:	2220      	movs	r2, #32
  400258:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = ~data;
}

static inline void hri_pio_clear_PUSR_reg(const void *const hw, hri_pio_pusr_reg_t mask)
{
	((Pio *)hw)->PIO_PUDR = mask;
  40025a:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = ~data;
}

static inline void hri_pio_clear_PPDSR_reg(const void *const hw, hri_pio_ppdsr_reg_t mask)
{
	((Pio *)hw)->PIO_PPDDR = mask;
  40025c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400260:	601a      	str	r2, [r3, #0]
  400262:	4770      	bx	lr
  400264:	400e0e00 	.word	0x400e0e00

00400268 <EXTERNAL_IRQ_1_init>:
	((Pio *)hw)->PIO_ODR = mask;
  400268:	4b03      	ldr	r3, [pc, #12]	; (400278 <EXTERNAL_IRQ_1_init+0x10>)
  40026a:	2202      	movs	r2, #2
  40026c:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40026e:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400270:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400274:	601a      	str	r2, [r3, #0]
  400276:	4770      	bx	lr
  400278:	400e1000 	.word	0x400e1000

0040027c <SPI_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40027c:	4b11      	ldr	r3, [pc, #68]	; (4002c4 <SPI_0_PORT_init+0x48>)
  40027e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400280:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  400284:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  40028c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40028e:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  400292:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400294:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400296:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  40029a:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40029c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40029e:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4002a2:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002a4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4002a8:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4002aa:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002ac:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  4002b0:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4002b2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002b4:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  4002b8:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002ba:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  4002be:	605a      	str	r2, [r3, #4]
  4002c0:	4770      	bx	lr
  4002c2:	bf00      	nop
  4002c4:	400e1400 	.word	0x400e1400

004002c8 <SPI_0_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4002c8:	4b04      	ldr	r3, [pc, #16]	; (4002dc <SPI_0_CLOCK_init+0x14>)
  4002ca:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4002cc:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  4002d0:	d103      	bne.n	4002da <SPI_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002d2:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4002d6:	4b01      	ldr	r3, [pc, #4]	; (4002dc <SPI_0_CLOCK_init+0x14>)
  4002d8:	611a      	str	r2, [r3, #16]
  4002da:	4770      	bx	lr
  4002dc:	400e0600 	.word	0x400e0600

004002e0 <SPI_0_init>:
{
	_pmc_enable_periph_clock(ID_SPI0);
}

void SPI_0_init(void)
{
  4002e0:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
  4002e2:	4b08      	ldr	r3, [pc, #32]	; (400304 <SPI_0_init+0x24>)
  4002e4:	4798      	blx	r3
	spi_m_sync_set_func_ptr(&SPI_0, _spi_get_spi_m_sync());
  4002e6:	4b08      	ldr	r3, [pc, #32]	; (400308 <SPI_0_init+0x28>)
  4002e8:	4798      	blx	r3
  4002ea:	4c08      	ldr	r4, [pc, #32]	; (40030c <SPI_0_init+0x2c>)
  4002ec:	4601      	mov	r1, r0
  4002ee:	4620      	mov	r0, r4
  4002f0:	4b07      	ldr	r3, [pc, #28]	; (400310 <SPI_0_init+0x30>)
  4002f2:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SPI0);
  4002f4:	4907      	ldr	r1, [pc, #28]	; (400314 <SPI_0_init+0x34>)
  4002f6:	4620      	mov	r0, r4
  4002f8:	4b07      	ldr	r3, [pc, #28]	; (400318 <SPI_0_init+0x38>)
  4002fa:	4798      	blx	r3
	SPI_0_PORT_init();
  4002fc:	4b07      	ldr	r3, [pc, #28]	; (40031c <SPI_0_init+0x3c>)
  4002fe:	4798      	blx	r3
  400300:	bd10      	pop	{r4, pc}
  400302:	bf00      	nop
  400304:	004002c9 	.word	0x004002c9
  400308:	00400f39 	.word	0x00400f39
  40030c:	204000b4 	.word	0x204000b4
  400310:	004006cd 	.word	0x004006cd
  400314:	40008000 	.word	0x40008000
  400318:	004006ed 	.word	0x004006ed
  40031c:	0040027d 	.word	0x0040027d

00400320 <I2C_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400320:	4b0a      	ldr	r3, [pc, #40]	; (40034c <I2C_0_PORT_init+0x2c>)
  400322:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400324:	f022 0210 	bic.w	r2, r2, #16
  400328:	671a      	str	r2, [r3, #112]	; 0x70
  40032a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40032c:	f022 0210 	bic.w	r2, r2, #16
  400330:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400332:	2210      	movs	r2, #16
  400334:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400336:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400338:	f022 0208 	bic.w	r2, r2, #8
  40033c:	671a      	str	r2, [r3, #112]	; 0x70
  40033e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400340:	f022 0208 	bic.w	r2, r2, #8
  400344:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400346:	2208      	movs	r2, #8
  400348:	605a      	str	r2, [r3, #4]
  40034a:	4770      	bx	lr
  40034c:	400e0e00 	.word	0x400e0e00

00400350 <I2C_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400350:	4b04      	ldr	r3, [pc, #16]	; (400364 <I2C_0_CLOCK_init+0x14>)
  400352:	699b      	ldr	r3, [r3, #24]
  400354:	f413 2f00 	tst.w	r3, #524288	; 0x80000
  400358:	d103      	bne.n	400362 <I2C_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40035a:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40035e:	4b01      	ldr	r3, [pc, #4]	; (400364 <I2C_0_CLOCK_init+0x14>)
  400360:	611a      	str	r2, [r3, #16]
  400362:	4770      	bx	lr
  400364:	400e0600 	.word	0x400e0600

00400368 <I2C_0_init>:
{
	_pmc_enable_periph_clock(ID_TWIHS0);
}

void I2C_0_init(void)
{
  400368:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
  40036a:	4b04      	ldr	r3, [pc, #16]	; (40037c <I2C_0_init+0x14>)
  40036c:	4798      	blx	r3

	i2c_m_sync_init(&I2C_0, TWIHS0);
  40036e:	4904      	ldr	r1, [pc, #16]	; (400380 <I2C_0_init+0x18>)
  400370:	4804      	ldr	r0, [pc, #16]	; (400384 <I2C_0_init+0x1c>)
  400372:	4b05      	ldr	r3, [pc, #20]	; (400388 <I2C_0_init+0x20>)
  400374:	4798      	blx	r3

	I2C_0_PORT_init();
  400376:	4b05      	ldr	r3, [pc, #20]	; (40038c <I2C_0_init+0x24>)
  400378:	4798      	blx	r3
  40037a:	bd08      	pop	{r3, pc}
  40037c:	00400351 	.word	0x00400351
  400380:	40018000 	.word	0x40018000
  400384:	204000cc 	.word	0x204000cc
  400388:	0040062d 	.word	0x0040062d
  40038c:	00400321 	.word	0x00400321

00400390 <delay_driver_init>:
}

void delay_driver_init(void)
{
  400390:	b508      	push	{r3, lr}
	delay_init(SysTick);
  400392:	4802      	ldr	r0, [pc, #8]	; (40039c <delay_driver_init+0xc>)
  400394:	4b02      	ldr	r3, [pc, #8]	; (4003a0 <delay_driver_init+0x10>)
  400396:	4798      	blx	r3
  400398:	bd08      	pop	{r3, pc}
  40039a:	bf00      	nop
  40039c:	e000e010 	.word	0xe000e010
  4003a0:	00400521 	.word	0x00400521

004003a4 <TARGET_IO_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4003a4:	4b0f      	ldr	r3, [pc, #60]	; (4003e4 <TARGET_IO_PORT_init+0x40>)
  4003a6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003a8:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4003ac:	671a      	str	r2, [r3, #112]	; 0x70
  4003ae:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003b0:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  4003b4:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003b6:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  4003ba:	605a      	str	r2, [r3, #4]
}

static inline void hri_matrix_set_CCFG_SYSIO_reg(const void *const hw, hri_matrix_ccfg_sysio_reg_t mask)
{
	MATRIX_CRITICAL_SECTION_ENTER();
	((Matrix *)hw)->CCFG_SYSIO |= mask;
  4003bc:	4a0a      	ldr	r2, [pc, #40]	; (4003e8 <TARGET_IO_PORT_init+0x44>)
  4003be:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  4003c2:	f043 0310 	orr.w	r3, r3, #16
  4003c6:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4003ca:	4b08      	ldr	r3, [pc, #32]	; (4003ec <TARGET_IO_PORT_init+0x48>)
  4003cc:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003ce:	f042 0210 	orr.w	r2, r2, #16
  4003d2:	671a      	str	r2, [r3, #112]	; 0x70
  4003d4:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003d6:	f042 0210 	orr.w	r2, r2, #16
  4003da:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003dc:	2210      	movs	r2, #16
  4003de:	605a      	str	r2, [r3, #4]
  4003e0:	4770      	bx	lr
  4003e2:	bf00      	nop
  4003e4:	400e0e00 	.word	0x400e0e00
  4003e8:	40088000 	.word	0x40088000
  4003ec:	400e1000 	.word	0x400e1000

004003f0 <TARGET_IO_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4003f0:	4b04      	ldr	r3, [pc, #16]	; (400404 <TARGET_IO_CLOCK_init+0x14>)
  4003f2:	699b      	ldr	r3, [r3, #24]
  4003f4:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  4003f8:	d103      	bne.n	400402 <TARGET_IO_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4003fa:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  4003fe:	4b01      	ldr	r3, [pc, #4]	; (400404 <TARGET_IO_CLOCK_init+0x14>)
  400400:	611a      	str	r2, [r3, #16]
  400402:	4770      	bx	lr
  400404:	400e0600 	.word	0x400e0600

00400408 <TARGET_IO_init>:
{
	_pmc_enable_periph_clock(ID_USART1);
}

void TARGET_IO_init(void)
{
  400408:	b508      	push	{r3, lr}
	TARGET_IO_CLOCK_init();
  40040a:	4b06      	ldr	r3, [pc, #24]	; (400424 <TARGET_IO_init+0x1c>)
  40040c:	4798      	blx	r3
	TARGET_IO_PORT_init();
  40040e:	4b06      	ldr	r3, [pc, #24]	; (400428 <TARGET_IO_init+0x20>)
  400410:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, USART1, _usart_get_usart_sync());
  400412:	4b06      	ldr	r3, [pc, #24]	; (40042c <TARGET_IO_init+0x24>)
  400414:	4798      	blx	r3
  400416:	4602      	mov	r2, r0
  400418:	4905      	ldr	r1, [pc, #20]	; (400430 <TARGET_IO_init+0x28>)
  40041a:	4806      	ldr	r0, [pc, #24]	; (400434 <TARGET_IO_init+0x2c>)
  40041c:	4b06      	ldr	r3, [pc, #24]	; (400438 <TARGET_IO_init+0x30>)
  40041e:	4798      	blx	r3
  400420:	bd08      	pop	{r3, pc}
  400422:	bf00      	nop
  400424:	004003f1 	.word	0x004003f1
  400428:	004003a5 	.word	0x004003a5
  40042c:	00401399 	.word	0x00401399
  400430:	40028000 	.word	0x40028000
  400434:	204000a8 	.word	0x204000a8
  400438:	00400919 	.word	0x00400919

0040043c <system_init>:
}

void system_init(void)
{
  40043c:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  40043e:	4b26      	ldr	r3, [pc, #152]	; (4004d8 <system_init+0x9c>)
  400440:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400442:	4b26      	ldr	r3, [pc, #152]	; (4004dc <system_init+0xa0>)
  400444:	699b      	ldr	r3, [r3, #24]
  400446:	f413 6f80 	tst.w	r3, #1024	; 0x400
  40044a:	d103      	bne.n	400454 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40044c:	f44f 6280 	mov.w	r2, #1024	; 0x400
  400450:	4b22      	ldr	r3, [pc, #136]	; (4004dc <system_init+0xa0>)
  400452:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400454:	4b21      	ldr	r3, [pc, #132]	; (4004dc <system_init+0xa0>)
  400456:	699b      	ldr	r3, [r3, #24]
  400458:	f413 6f00 	tst.w	r3, #2048	; 0x800
  40045c:	d103      	bne.n	400466 <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40045e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400462:	4b1e      	ldr	r3, [pc, #120]	; (4004dc <system_init+0xa0>)
  400464:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400466:	4b1d      	ldr	r3, [pc, #116]	; (4004dc <system_init+0xa0>)
  400468:	699b      	ldr	r3, [r3, #24]
  40046a:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  40046e:	d103      	bne.n	400478 <system_init+0x3c>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400470:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  400474:	4b19      	ldr	r3, [pc, #100]	; (4004dc <system_init+0xa0>)
  400476:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400478:	4b18      	ldr	r3, [pc, #96]	; (4004dc <system_init+0xa0>)
  40047a:	699b      	ldr	r3, [r3, #24]
  40047c:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400480:	d103      	bne.n	40048a <system_init+0x4e>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400482:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  400486:	4b15      	ldr	r3, [pc, #84]	; (4004dc <system_init+0xa0>)
  400488:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  40048a:	4a15      	ldr	r2, [pc, #84]	; (4004e0 <system_init+0xa4>)
  40048c:	6853      	ldr	r3, [r2, #4]
  40048e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  400492:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_SODR = mask;
  400494:	4b13      	ldr	r3, [pc, #76]	; (4004e4 <system_init+0xa8>)
  400496:	2201      	movs	r2, #1
  400498:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  40049a:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  40049c:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40049e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  4004a2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4004a6:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  4004a8:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  4004aa:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  4004ac:	f503 7300 	add.w	r3, r3, #512	; 0x200
  4004b0:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4004b4:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  4004b6:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  4004b8:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(RF24_CE, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(RF24_CE, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_0_init();
  4004ba:	4b0b      	ldr	r3, [pc, #44]	; (4004e8 <system_init+0xac>)
  4004bc:	4798      	blx	r3
	EXTERNAL_IRQ_1_init();
  4004be:	4b0b      	ldr	r3, [pc, #44]	; (4004ec <system_init+0xb0>)
  4004c0:	4798      	blx	r3

	SPI_0_init();
  4004c2:	4b0b      	ldr	r3, [pc, #44]	; (4004f0 <system_init+0xb4>)
  4004c4:	4798      	blx	r3

	I2C_0_init();
  4004c6:	4b0b      	ldr	r3, [pc, #44]	; (4004f4 <system_init+0xb8>)
  4004c8:	4798      	blx	r3

	delay_driver_init();
  4004ca:	4b0b      	ldr	r3, [pc, #44]	; (4004f8 <system_init+0xbc>)
  4004cc:	4798      	blx	r3

	TARGET_IO_init();
  4004ce:	4b0b      	ldr	r3, [pc, #44]	; (4004fc <system_init+0xc0>)
  4004d0:	4798      	blx	r3

	ext_irq_init();
  4004d2:	4b0b      	ldr	r3, [pc, #44]	; (400500 <system_init+0xc4>)
  4004d4:	4798      	blx	r3
  4004d6:	bd08      	pop	{r3, pc}
  4004d8:	004009dd 	.word	0x004009dd
  4004dc:	400e0600 	.word	0x400e0600
  4004e0:	400e1850 	.word	0x400e1850
  4004e4:	400e0e00 	.word	0x400e0e00
  4004e8:	00400255 	.word	0x00400255
  4004ec:	00400269 	.word	0x00400269
  4004f0:	004002e1 	.word	0x004002e1
  4004f4:	00400369 	.word	0x00400369
  4004f8:	00400391 	.word	0x00400391
  4004fc:	00400409 	.word	0x00400409
  400500:	00400599 	.word	0x00400599

00400504 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  400504:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  400508:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40050a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  40050c:	f3bf 8f5f 	dmb	sy
  400510:	4770      	bx	lr

00400512 <atomic_leave_critical>:
  400512:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  400516:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  400518:	f383 8810 	msr	PRIMASK, r3
  40051c:	4770      	bx	lr
	...

00400520 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  400520:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  400522:	4b02      	ldr	r3, [pc, #8]	; (40052c <delay_init+0xc>)
  400524:	6018      	str	r0, [r3, #0]
  400526:	4b02      	ldr	r3, [pc, #8]	; (400530 <delay_init+0x10>)
  400528:	4798      	blx	r3
  40052a:	bd08      	pop	{r3, pc}
  40052c:	20400080 	.word	0x20400080
  400530:	00400f51 	.word	0x00400f51

00400534 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
  400534:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
  400536:	4b04      	ldr	r3, [pc, #16]	; (400548 <delay_us+0x14>)
  400538:	681c      	ldr	r4, [r3, #0]
  40053a:	4b04      	ldr	r3, [pc, #16]	; (40054c <delay_us+0x18>)
  40053c:	4798      	blx	r3
  40053e:	4601      	mov	r1, r0
  400540:	4620      	mov	r0, r4
  400542:	4b03      	ldr	r3, [pc, #12]	; (400550 <delay_us+0x1c>)
  400544:	4798      	blx	r3
  400546:	bd10      	pop	{r4, pc}
  400548:	20400080 	.word	0x20400080
  40054c:	004009d1 	.word	0x004009d1
  400550:	00400f5d 	.word	0x00400f5d

00400554 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  400554:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  400556:	2502      	movs	r5, #2
  400558:	2400      	movs	r4, #0

	while (upper >= lower) {
  40055a:	e007      	b.n	40056c <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  40055c:	4a0d      	ldr	r2, [pc, #52]	; (400594 <process_ext_irq+0x40>)
  40055e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  400562:	b1b3      	cbz	r3, 400592 <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  400564:	4798      	blx	r3
  400566:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  400568:	3a01      	subs	r2, #1
  40056a:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
  40056c:	42ac      	cmp	r4, r5
  40056e:	d810      	bhi.n	400592 <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  400570:	192b      	adds	r3, r5, r4
  400572:	105b      	asrs	r3, r3, #1
  400574:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
  400576:	2a01      	cmp	r2, #1
  400578:	d80b      	bhi.n	400592 <process_ext_irq+0x3e>
  40057a:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
  40057c:	4905      	ldr	r1, [pc, #20]	; (400594 <process_ext_irq+0x40>)
  40057e:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  400582:	6849      	ldr	r1, [r1, #4]
  400584:	4281      	cmp	r1, r0
  400586:	d0e9      	beq.n	40055c <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  400588:	4281      	cmp	r1, r0
  40058a:	d2ed      	bcs.n	400568 <process_ext_irq+0x14>
			lower = middle + 1;
  40058c:	3201      	adds	r2, #1
  40058e:	b2d4      	uxtb	r4, r2
  400590:	e7ec      	b.n	40056c <process_ext_irq+0x18>
  400592:	bd38      	pop	{r3, r4, r5, pc}
  400594:	20400084 	.word	0x20400084

00400598 <ext_irq_init>:
{
  400598:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  40059a:	2300      	movs	r3, #0
  40059c:	e00a      	b.n	4005b4 <ext_irq_init+0x1c>
		ext_irqs[i].pin = 0xFFFFFFFF;
  40059e:	4a08      	ldr	r2, [pc, #32]	; (4005c0 <ext_irq_init+0x28>)
  4005a0:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  4005a4:	f04f 30ff 	mov.w	r0, #4294967295
  4005a8:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  4005aa:	2100      	movs	r1, #0
  4005ac:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  4005b0:	3301      	adds	r3, #1
  4005b2:	b29b      	uxth	r3, r3
  4005b4:	2b01      	cmp	r3, #1
  4005b6:	d9f2      	bls.n	40059e <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
  4005b8:	4802      	ldr	r0, [pc, #8]	; (4005c4 <ext_irq_init+0x2c>)
  4005ba:	4b03      	ldr	r3, [pc, #12]	; (4005c8 <ext_irq_init+0x30>)
  4005bc:	4798      	blx	r3
}
  4005be:	bd08      	pop	{r3, pc}
  4005c0:	20400084 	.word	0x20400084
  4005c4:	00400555 	.word	0x00400555
  4005c8:	00400c65 	.word	0x00400c65

004005cc <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
  4005cc:	b510      	push	{r4, lr}
  4005ce:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
  4005d0:	8903      	ldrh	r3, [r0, #8]
  4005d2:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  4005d6:	4614      	mov	r4, r2
  4005d8:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
  4005da:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4005de:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
  4005e2:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  4005e4:	a901      	add	r1, sp, #4
  4005e6:	3814      	subs	r0, #20
  4005e8:	4b03      	ldr	r3, [pc, #12]	; (4005f8 <i2c_m_sync_write+0x2c>)
  4005ea:	4798      	blx	r3

	if (ret) {
  4005ec:	b910      	cbnz	r0, 4005f4 <i2c_m_sync_write+0x28>
		return ret;
	}

	return n;
}
  4005ee:	4620      	mov	r0, r4
  4005f0:	b004      	add	sp, #16
  4005f2:	bd10      	pop	{r4, pc}
		return ret;
  4005f4:	4604      	mov	r4, r0
  4005f6:	e7fa      	b.n	4005ee <i2c_m_sync_write+0x22>
  4005f8:	0040101d 	.word	0x0040101d

004005fc <i2c_m_sync_read>:
{
  4005fc:	b510      	push	{r4, lr}
  4005fe:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
  400600:	8903      	ldrh	r3, [r0, #8]
  400602:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  400606:	4614      	mov	r4, r2
  400608:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
  40060a:	f248 0301 	movw	r3, #32769	; 0x8001
  40060e:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
  400612:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400614:	a901      	add	r1, sp, #4
  400616:	3814      	subs	r0, #20
  400618:	4b03      	ldr	r3, [pc, #12]	; (400628 <i2c_m_sync_read+0x2c>)
  40061a:	4798      	blx	r3
	if (ret) {
  40061c:	b910      	cbnz	r0, 400624 <i2c_m_sync_read+0x28>
}
  40061e:	4620      	mov	r0, r4
  400620:	b004      	add	sp, #16
  400622:	bd10      	pop	{r4, pc}
		return ret;
  400624:	4604      	mov	r4, r0
  400626:	e7fa      	b.n	40061e <i2c_m_sync_read+0x22>
  400628:	0040101d 	.word	0x0040101d

0040062c <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
  40062c:	b538      	push	{r3, r4, r5, lr}
  40062e:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
  400630:	4604      	mov	r4, r0
  400632:	225e      	movs	r2, #94	; 0x5e
  400634:	4908      	ldr	r1, [pc, #32]	; (400658 <i2c_m_sync_init+0x2c>)
  400636:	3000      	adds	r0, #0
  400638:	bf18      	it	ne
  40063a:	2001      	movne	r0, #1
  40063c:	4b07      	ldr	r3, [pc, #28]	; (40065c <i2c_m_sync_init+0x30>)
  40063e:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
  400640:	4629      	mov	r1, r5
  400642:	4620      	mov	r0, r4
  400644:	4b06      	ldr	r3, [pc, #24]	; (400660 <i2c_m_sync_init+0x34>)
  400646:	4798      	blx	r3
	if (init_status) {
  400648:	4603      	mov	r3, r0
  40064a:	b918      	cbnz	r0, 400654 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
  40064c:	4a05      	ldr	r2, [pc, #20]	; (400664 <i2c_m_sync_init+0x38>)
  40064e:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
  400650:	4a05      	ldr	r2, [pc, #20]	; (400668 <i2c_m_sync_init+0x3c>)
  400652:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
  400654:	4618      	mov	r0, r3
  400656:	bd38      	pop	{r3, r4, r5, pc}
  400658:	00402794 	.word	0x00402794
  40065c:	0040098d 	.word	0x0040098d
  400660:	00400fd5 	.word	0x00400fd5
  400664:	004005fd 	.word	0x004005fd
  400668:	004005cd 	.word	0x004005cd

0040066c <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  40066c:	b570      	push	{r4, r5, r6, lr}
  40066e:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  400670:	4604      	mov	r4, r0
  400672:	460d      	mov	r5, r1
  400674:	2800      	cmp	r0, #0
  400676:	bf18      	it	ne
  400678:	2900      	cmpne	r1, #0
  40067a:	bf14      	ite	ne
  40067c:	2001      	movne	r0, #1
  40067e:	2000      	moveq	r0, #0
  400680:	2234      	movs	r2, #52	; 0x34
  400682:	4904      	ldr	r1, [pc, #16]	; (400694 <io_write+0x28>)
  400684:	4b04      	ldr	r3, [pc, #16]	; (400698 <io_write+0x2c>)
  400686:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  400688:	6823      	ldr	r3, [r4, #0]
  40068a:	4632      	mov	r2, r6
  40068c:	4629      	mov	r1, r5
  40068e:	4620      	mov	r0, r4
  400690:	4798      	blx	r3
}
  400692:	bd70      	pop	{r4, r5, r6, pc}
  400694:	004027b0 	.word	0x004027b0
  400698:	0040098d 	.word	0x0040098d

0040069c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  40069c:	b570      	push	{r4, r5, r6, lr}
  40069e:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4006a0:	4604      	mov	r4, r0
  4006a2:	460d      	mov	r5, r1
  4006a4:	2800      	cmp	r0, #0
  4006a6:	bf18      	it	ne
  4006a8:	2900      	cmpne	r1, #0
  4006aa:	bf14      	ite	ne
  4006ac:	2001      	movne	r0, #1
  4006ae:	2000      	moveq	r0, #0
  4006b0:	223d      	movs	r2, #61	; 0x3d
  4006b2:	4904      	ldr	r1, [pc, #16]	; (4006c4 <io_read+0x28>)
  4006b4:	4b04      	ldr	r3, [pc, #16]	; (4006c8 <io_read+0x2c>)
  4006b6:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  4006b8:	6863      	ldr	r3, [r4, #4]
  4006ba:	4632      	mov	r2, r6
  4006bc:	4629      	mov	r1, r5
  4006be:	4620      	mov	r0, r4
  4006c0:	4798      	blx	r3
}
  4006c2:	bd70      	pop	{r4, r5, r6, pc}
  4006c4:	004027b0 	.word	0x004027b0
  4006c8:	0040098d 	.word	0x0040098d

004006cc <spi_m_sync_set_func_ptr>:

/**
 *  \brief Initialize the SPI HAL instance function pointer for HPL APIs.
 */
void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi, void *const func)
{
  4006cc:	b538      	push	{r3, r4, r5, lr}
  4006ce:	460d      	mov	r5, r1
	ASSERT(spi);
  4006d0:	4604      	mov	r4, r0
  4006d2:	2239      	movs	r2, #57	; 0x39
  4006d4:	4903      	ldr	r1, [pc, #12]	; (4006e4 <spi_m_sync_set_func_ptr+0x18>)
  4006d6:	3000      	adds	r0, #0
  4006d8:	bf18      	it	ne
  4006da:	2001      	movne	r0, #1
  4006dc:	4b02      	ldr	r3, [pc, #8]	; (4006e8 <spi_m_sync_set_func_ptr+0x1c>)
  4006de:	4798      	blx	r3
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
  4006e0:	6025      	str	r5, [r4, #0]
  4006e2:	bd38      	pop	{r3, r4, r5, pc}
  4006e4:	004027c4 	.word	0x004027c4
  4006e8:	0040098d 	.word	0x0040098d

004006ec <spi_m_sync_init>:
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
  4006ec:	b538      	push	{r3, r4, r5, lr}
	int32_t rc = 0;
	ASSERT(spi && hw);
  4006ee:	4604      	mov	r4, r0
  4006f0:	460d      	mov	r5, r1
  4006f2:	2800      	cmp	r0, #0
  4006f4:	bf18      	it	ne
  4006f6:	2900      	cmpne	r1, #0
  4006f8:	bf14      	ite	ne
  4006fa:	2001      	movne	r0, #1
  4006fc:	2000      	moveq	r0, #0
  4006fe:	2240      	movs	r2, #64	; 0x40
  400700:	4909      	ldr	r1, [pc, #36]	; (400728 <spi_m_sync_init+0x3c>)
  400702:	4b0a      	ldr	r3, [pc, #40]	; (40072c <spi_m_sync_init+0x40>)
  400704:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
  400706:	4620      	mov	r0, r4
  400708:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
  40070c:	4629      	mov	r1, r5
  40070e:	4b08      	ldr	r3, [pc, #32]	; (400730 <spi_m_sync_init+0x44>)
  400710:	4798      	blx	r3

	if (rc < 0) {
  400712:	2800      	cmp	r0, #0
  400714:	db07      	blt.n	400726 <spi_m_sync_init+0x3a>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
  400716:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40071a:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
  40071c:	4b05      	ldr	r3, [pc, #20]	; (400734 <spi_m_sync_init+0x48>)
  40071e:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
  400720:	4b05      	ldr	r3, [pc, #20]	; (400738 <spi_m_sync_init+0x4c>)
  400722:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
  400724:	2000      	movs	r0, #0
}
  400726:	bd38      	pop	{r3, r4, r5, pc}
  400728:	004027c4 	.word	0x004027c4
  40072c:	0040098d 	.word	0x0040098d
  400730:	00400d5d 	.word	0x00400d5d
  400734:	004007e1 	.word	0x004007e1
  400738:	004007a5 	.word	0x004007a5

0040073c <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
  40073c:	b510      	push	{r4, lr}
	ASSERT(spi);
  40073e:	4604      	mov	r4, r0
  400740:	2257      	movs	r2, #87	; 0x57
  400742:	4905      	ldr	r1, [pc, #20]	; (400758 <spi_m_sync_enable+0x1c>)
  400744:	3000      	adds	r0, #0
  400746:	bf18      	it	ne
  400748:	2001      	movne	r0, #1
  40074a:	4b04      	ldr	r3, [pc, #16]	; (40075c <spi_m_sync_enable+0x20>)
  40074c:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
  40074e:	1d20      	adds	r0, r4, #4
  400750:	4b03      	ldr	r3, [pc, #12]	; (400760 <spi_m_sync_enable+0x24>)
  400752:	4798      	blx	r3
  400754:	bd10      	pop	{r4, pc}
  400756:	bf00      	nop
  400758:	004027c4 	.word	0x004027c4
  40075c:	0040098d 	.word	0x0040098d
  400760:	00400e05 	.word	0x00400e05

00400764 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
  400764:	b530      	push	{r4, r5, lr}
  400766:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
  400768:	4605      	mov	r5, r0
  40076a:	460c      	mov	r4, r1
  40076c:	2800      	cmp	r0, #0
  40076e:	bf18      	it	ne
  400770:	2900      	cmpne	r1, #0
  400772:	bf14      	ite	ne
  400774:	2001      	movne	r0, #1
  400776:	2000      	moveq	r0, #0
  400778:	22b3      	movs	r2, #179	; 0xb3
  40077a:	4907      	ldr	r1, [pc, #28]	; (400798 <spi_m_sync_transfer+0x34>)
  40077c:	4b07      	ldr	r3, [pc, #28]	; (40079c <spi_m_sync_transfer+0x38>)
  40077e:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
  400780:	6823      	ldr	r3, [r4, #0]
  400782:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
  400784:	6863      	ldr	r3, [r4, #4]
  400786:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
  400788:	68a3      	ldr	r3, [r4, #8]
  40078a:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
  40078c:	a901      	add	r1, sp, #4
  40078e:	1d28      	adds	r0, r5, #4
  400790:	4b03      	ldr	r3, [pc, #12]	; (4007a0 <spi_m_sync_transfer+0x3c>)
  400792:	4798      	blx	r3
}
  400794:	b005      	add	sp, #20
  400796:	bd30      	pop	{r4, r5, pc}
  400798:	004027c4 	.word	0x004027c4
  40079c:	0040098d 	.word	0x0040098d
  4007a0:	00400e39 	.word	0x00400e39

004007a4 <_spi_m_sync_io_write>:
{
  4007a4:	b570      	push	{r4, r5, r6, lr}
  4007a6:	b084      	sub	sp, #16
  4007a8:	460e      	mov	r6, r1
  4007aa:	4615      	mov	r5, r2
	ASSERT(io);
  4007ac:	4604      	mov	r4, r0
  4007ae:	22a3      	movs	r2, #163	; 0xa3
  4007b0:	4908      	ldr	r1, [pc, #32]	; (4007d4 <_spi_m_sync_io_write+0x30>)
  4007b2:	3000      	adds	r0, #0
  4007b4:	bf18      	it	ne
  4007b6:	2001      	movne	r0, #1
  4007b8:	4b07      	ldr	r3, [pc, #28]	; (4007d8 <_spi_m_sync_io_write+0x34>)
  4007ba:	4798      	blx	r3
	xfer.rxbuf = 0;
  4007bc:	2300      	movs	r3, #0
  4007be:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
  4007c0:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
  4007c2:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  4007c4:	a901      	add	r1, sp, #4
  4007c6:	f1a4 000c 	sub.w	r0, r4, #12
  4007ca:	4b04      	ldr	r3, [pc, #16]	; (4007dc <_spi_m_sync_io_write+0x38>)
  4007cc:	4798      	blx	r3
}
  4007ce:	b004      	add	sp, #16
  4007d0:	bd70      	pop	{r4, r5, r6, pc}
  4007d2:	bf00      	nop
  4007d4:	004027c4 	.word	0x004027c4
  4007d8:	0040098d 	.word	0x0040098d
  4007dc:	00400765 	.word	0x00400765

004007e0 <_spi_m_sync_io_read>:
{
  4007e0:	b570      	push	{r4, r5, r6, lr}
  4007e2:	b084      	sub	sp, #16
  4007e4:	460e      	mov	r6, r1
  4007e6:	4615      	mov	r5, r2
	ASSERT(io);
  4007e8:	4604      	mov	r4, r0
  4007ea:	2287      	movs	r2, #135	; 0x87
  4007ec:	4908      	ldr	r1, [pc, #32]	; (400810 <_spi_m_sync_io_read+0x30>)
  4007ee:	3000      	adds	r0, #0
  4007f0:	bf18      	it	ne
  4007f2:	2001      	movne	r0, #1
  4007f4:	4b07      	ldr	r3, [pc, #28]	; (400814 <_spi_m_sync_io_read+0x34>)
  4007f6:	4798      	blx	r3
	xfer.rxbuf = buf;
  4007f8:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
  4007fa:	2300      	movs	r3, #0
  4007fc:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
  4007fe:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400800:	a901      	add	r1, sp, #4
  400802:	f1a4 000c 	sub.w	r0, r4, #12
  400806:	4b04      	ldr	r3, [pc, #16]	; (400818 <_spi_m_sync_io_read+0x38>)
  400808:	4798      	blx	r3
}
  40080a:	b004      	add	sp, #16
  40080c:	bd70      	pop	{r4, r5, r6, pc}
  40080e:	bf00      	nop
  400810:	004027c4 	.word	0x004027c4
  400814:	0040098d 	.word	0x0040098d
  400818:	00400765 	.word	0x00400765

0040081c <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
  40081c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(spi && io);
  40081e:	4604      	mov	r4, r0
  400820:	460d      	mov	r5, r1
  400822:	2800      	cmp	r0, #0
  400824:	bf18      	it	ne
  400826:	2900      	cmpne	r1, #0
  400828:	bf14      	ite	ne
  40082a:	2001      	movne	r0, #1
  40082c:	2000      	moveq	r0, #0
  40082e:	22bd      	movs	r2, #189	; 0xbd
  400830:	4903      	ldr	r1, [pc, #12]	; (400840 <spi_m_sync_get_io_descriptor+0x24>)
  400832:	4b04      	ldr	r3, [pc, #16]	; (400844 <spi_m_sync_get_io_descriptor+0x28>)
  400834:	4798      	blx	r3
	*io = &spi->io;
  400836:	340c      	adds	r4, #12
  400838:	602c      	str	r4, [r5, #0]
	return 0;
}
  40083a:	2000      	movs	r0, #0
  40083c:	bd38      	pop	{r3, r4, r5, pc}
  40083e:	bf00      	nop
  400840:	004027c4 	.word	0x004027c4
  400844:	0040098d 	.word	0x0040098d

00400848 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  400848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40084a:	4616      	mov	r6, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  40084c:	4605      	mov	r5, r0
  40084e:	460f      	mov	r7, r1
  400850:	2800      	cmp	r0, #0
  400852:	bf18      	it	ne
  400854:	2900      	cmpne	r1, #0
  400856:	d002      	beq.n	40085e <usart_sync_write+0x16>
  400858:	bb0a      	cbnz	r2, 40089e <usart_sync_write+0x56>
  40085a:	2000      	movs	r0, #0
  40085c:	e000      	b.n	400860 <usart_sync_write+0x18>
  40085e:	2000      	movs	r0, #0
  400860:	22f1      	movs	r2, #241	; 0xf1
  400862:	4910      	ldr	r1, [pc, #64]	; (4008a4 <usart_sync_write+0x5c>)
  400864:	4b10      	ldr	r3, [pc, #64]	; (4008a8 <usart_sync_write+0x60>)
  400866:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
  400868:	f105 0408 	add.w	r4, r5, #8
  40086c:	4620      	mov	r0, r4
  40086e:	4b0f      	ldr	r3, [pc, #60]	; (4008ac <usart_sync_write+0x64>)
  400870:	4798      	blx	r3
  400872:	2800      	cmp	r0, #0
  400874:	d0f8      	beq.n	400868 <usart_sync_write+0x20>
  400876:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
  400878:	5d79      	ldrb	r1, [r7, r5]
  40087a:	4620      	mov	r0, r4
  40087c:	4b0c      	ldr	r3, [pc, #48]	; (4008b0 <usart_sync_write+0x68>)
  40087e:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
  400880:	4620      	mov	r0, r4
  400882:	4b0a      	ldr	r3, [pc, #40]	; (4008ac <usart_sync_write+0x64>)
  400884:	4798      	blx	r3
  400886:	2800      	cmp	r0, #0
  400888:	d0fa      	beq.n	400880 <usart_sync_write+0x38>
			;
	} while (++offset < length);
  40088a:	3501      	adds	r5, #1
  40088c:	42b5      	cmp	r5, r6
  40088e:	d3f3      	bcc.n	400878 <usart_sync_write+0x30>
	while (!_usart_sync_is_transmit_done(&descr->device))
  400890:	4620      	mov	r0, r4
  400892:	4b08      	ldr	r3, [pc, #32]	; (4008b4 <usart_sync_write+0x6c>)
  400894:	4798      	blx	r3
  400896:	2800      	cmp	r0, #0
  400898:	d0fa      	beq.n	400890 <usart_sync_write+0x48>
		;
	return (int32_t)offset;
}
  40089a:	4628      	mov	r0, r5
  40089c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
  40089e:	2001      	movs	r0, #1
  4008a0:	e7de      	b.n	400860 <usart_sync_write+0x18>
  4008a2:	bf00      	nop
  4008a4:	004027e0 	.word	0x004027e0
  4008a8:	0040098d 	.word	0x0040098d
  4008ac:	00401321 	.word	0x00401321
  4008b0:	004012d9 	.word	0x004012d9
  4008b4:	00401349 	.word	0x00401349

004008b8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4008b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4008bc:	4617      	mov	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  4008be:	4605      	mov	r5, r0
  4008c0:	4688      	mov	r8, r1
  4008c2:	2800      	cmp	r0, #0
  4008c4:	bf18      	it	ne
  4008c6:	2900      	cmpne	r1, #0
  4008c8:	d002      	beq.n	4008d0 <usart_sync_read+0x18>
  4008ca:	b9d2      	cbnz	r2, 400902 <usart_sync_read+0x4a>
  4008cc:	2000      	movs	r0, #0
  4008ce:	e000      	b.n	4008d2 <usart_sync_read+0x1a>
  4008d0:	2000      	movs	r0, #0
  4008d2:	f44f 7286 	mov.w	r2, #268	; 0x10c
  4008d6:	490c      	ldr	r1, [pc, #48]	; (400908 <usart_sync_read+0x50>)
  4008d8:	4b0c      	ldr	r3, [pc, #48]	; (40090c <usart_sync_read+0x54>)
  4008da:	4798      	blx	r3
	uint32_t                      offset = 0;
  4008dc:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
  4008de:	f105 0408 	add.w	r4, r5, #8
  4008e2:	4620      	mov	r0, r4
  4008e4:	4b0a      	ldr	r3, [pc, #40]	; (400910 <usart_sync_read+0x58>)
  4008e6:	4798      	blx	r3
  4008e8:	2800      	cmp	r0, #0
  4008ea:	d0f8      	beq.n	4008de <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
  4008ec:	4620      	mov	r0, r4
  4008ee:	4b09      	ldr	r3, [pc, #36]	; (400914 <usart_sync_read+0x5c>)
  4008f0:	4798      	blx	r3
  4008f2:	f808 0006 	strb.w	r0, [r8, r6]
	} while (++offset < length);
  4008f6:	3601      	adds	r6, #1
  4008f8:	42be      	cmp	r6, r7
  4008fa:	d3f0      	bcc.n	4008de <usart_sync_read+0x26>

	return (int32_t)offset;
}
  4008fc:	4630      	mov	r0, r6
  4008fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(io_descr && buf && length);
  400902:	2001      	movs	r0, #1
  400904:	e7e5      	b.n	4008d2 <usart_sync_read+0x1a>
  400906:	bf00      	nop
  400908:	004027e0 	.word	0x004027e0
  40090c:	0040098d 	.word	0x0040098d
  400910:	00401371 	.word	0x00401371
  400914:	004012fd 	.word	0x004012fd

00400918 <usart_sync_init>:
{
  400918:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  40091a:	4604      	mov	r4, r0
  40091c:	460d      	mov	r5, r1
  40091e:	2800      	cmp	r0, #0
  400920:	bf18      	it	ne
  400922:	2900      	cmpne	r1, #0
  400924:	bf14      	ite	ne
  400926:	2001      	movne	r0, #1
  400928:	2000      	moveq	r0, #0
  40092a:	2234      	movs	r2, #52	; 0x34
  40092c:	4907      	ldr	r1, [pc, #28]	; (40094c <usart_sync_init+0x34>)
  40092e:	4b08      	ldr	r3, [pc, #32]	; (400950 <usart_sync_init+0x38>)
  400930:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
  400932:	4629      	mov	r1, r5
  400934:	f104 0008 	add.w	r0, r4, #8
  400938:	4b06      	ldr	r3, [pc, #24]	; (400954 <usart_sync_init+0x3c>)
  40093a:	4798      	blx	r3
	if (init_status) {
  40093c:	4603      	mov	r3, r0
  40093e:	b918      	cbnz	r0, 400948 <usart_sync_init+0x30>
	descr->io.read  = usart_sync_read;
  400940:	4a05      	ldr	r2, [pc, #20]	; (400958 <usart_sync_init+0x40>)
  400942:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
  400944:	4a05      	ldr	r2, [pc, #20]	; (40095c <usart_sync_init+0x44>)
  400946:	6022      	str	r2, [r4, #0]
}
  400948:	4618      	mov	r0, r3
  40094a:	bd38      	pop	{r3, r4, r5, pc}
  40094c:	004027e0 	.word	0x004027e0
  400950:	0040098d 	.word	0x0040098d
  400954:	0040126d 	.word	0x0040126d
  400958:	004008b9 	.word	0x004008b9
  40095c:	00400849 	.word	0x00400849

00400960 <usart_sync_enable>:
{
  400960:	b510      	push	{r4, lr}
	ASSERT(descr);
  400962:	4604      	mov	r4, r0
  400964:	2253      	movs	r2, #83	; 0x53
  400966:	4906      	ldr	r1, [pc, #24]	; (400980 <usart_sync_enable+0x20>)
  400968:	3000      	adds	r0, #0
  40096a:	bf18      	it	ne
  40096c:	2001      	movne	r0, #1
  40096e:	4b05      	ldr	r3, [pc, #20]	; (400984 <usart_sync_enable+0x24>)
  400970:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
  400972:	f104 0008 	add.w	r0, r4, #8
  400976:	4b04      	ldr	r3, [pc, #16]	; (400988 <usart_sync_enable+0x28>)
  400978:	4798      	blx	r3
}
  40097a:	2000      	movs	r0, #0
  40097c:	bd10      	pop	{r4, pc}
  40097e:	bf00      	nop
  400980:	004027e0 	.word	0x004027e0
  400984:	0040098d 	.word	0x0040098d
  400988:	004012a5 	.word	0x004012a5

0040098c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  40098c:	b900      	cbnz	r0, 400990 <assert+0x4>
		__asm("BKPT #0");
  40098e:	be00      	bkpt	0x0000
  400990:	4770      	bx	lr
	...

00400994 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
  400994:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
  400996:	4a06      	ldr	r2, [pc, #24]	; (4009b0 <_sbrk+0x1c>)
  400998:	6812      	ldr	r2, [r2, #0]
  40099a:	b122      	cbz	r2, 4009a6 <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
  40099c:	4a04      	ldr	r2, [pc, #16]	; (4009b0 <_sbrk+0x1c>)
  40099e:	6810      	ldr	r0, [r2, #0]

	heap += incr;
  4009a0:	4403      	add	r3, r0
  4009a2:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
  4009a4:	4770      	bx	lr
		heap = (unsigned char *)&_end;
  4009a6:	4903      	ldr	r1, [pc, #12]	; (4009b4 <_sbrk+0x20>)
  4009a8:	4a01      	ldr	r2, [pc, #4]	; (4009b0 <_sbrk+0x1c>)
  4009aa:	6011      	str	r1, [r2, #0]
  4009ac:	e7f6      	b.n	40099c <_sbrk+0x8>
  4009ae:	bf00      	nop
  4009b0:	20400094 	.word	0x20400094
  4009b4:	204006f8 	.word	0x204006f8

004009b8 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
  4009b8:	f04f 30ff 	mov.w	r0, #4294967295
  4009bc:	4770      	bx	lr

004009be <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
  4009be:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  4009c2:	604b      	str	r3, [r1, #4]

	return 0;
}
  4009c4:	2000      	movs	r0, #0
  4009c6:	4770      	bx	lr

004009c8 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
  4009c8:	2001      	movs	r0, #1
  4009ca:	4770      	bx	lr

004009cc <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
  4009cc:	2000      	movs	r0, #0
  4009ce:	4770      	bx	lr

004009d0 <_get_cycles_for_us>:
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
	return _get_cycles_for_us_internal(us, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  4009d0:	f44f 7396 	mov.w	r3, #300	; 0x12c
  4009d4:	fb03 f000 	mul.w	r0, r3, r0
  4009d8:	4770      	bx	lr
	...

004009dc <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  4009dc:	b500      	push	{lr}
  4009de:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  4009e0:	a801      	add	r0, sp, #4
  4009e2:	4b0e      	ldr	r3, [pc, #56]	; (400a1c <_init_chip+0x40>)
  4009e4:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  4009e6:	4a0e      	ldr	r2, [pc, #56]	; (400a20 <_init_chip+0x44>)
  4009e8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  4009ec:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4009f0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  4009f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4009f8:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  4009fc:	a801      	add	r0, sp, #4
  4009fe:	4b09      	ldr	r3, [pc, #36]	; (400a24 <_init_chip+0x48>)
  400a00:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  400a02:	4a09      	ldr	r2, [pc, #36]	; (400a28 <_init_chip+0x4c>)
  400a04:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  400a06:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  400a0a:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  400a0e:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  400a10:	4b06      	ldr	r3, [pc, #24]	; (400a2c <_init_chip+0x50>)
  400a12:	4798      	blx	r3
}
  400a14:	b003      	add	sp, #12
  400a16:	f85d fb04 	ldr.w	pc, [sp], #4
  400a1a:	bf00      	nop
  400a1c:	00400505 	.word	0x00400505
  400a20:	e000ed00 	.word	0xe000ed00
  400a24:	00400513 	.word	0x00400513
  400a28:	400e0c00 	.word	0x400e0c00
  400a2c:	00400d29 	.word	0x00400d29

00400a30 <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  400a30:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  400a32:	2500      	movs	r5, #0
  400a34:	428d      	cmp	r5, r1
  400a36:	d210      	bcs.n	400a5a <_ffs+0x2a>
  400a38:	2201      	movs	r2, #1
  400a3a:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400a3c:	2b1f      	cmp	r3, #31
  400a3e:	d80a      	bhi.n	400a56 <_ffs+0x26>
			if (v[i] & bit) {
  400a40:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  400a44:	4222      	tst	r2, r4
  400a46:	d102      	bne.n	400a4e <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400a48:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400a4a:	3301      	adds	r3, #1
  400a4c:	e7f6      	b.n	400a3c <_ffs+0xc>
				return i * 32 + j;
  400a4e:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  400a52:	bc30      	pop	{r4, r5}
  400a54:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  400a56:	3501      	adds	r5, #1
  400a58:	e7ec      	b.n	400a34 <_ffs+0x4>
	return -1;
  400a5a:	f04f 30ff 	mov.w	r0, #4294967295
  400a5e:	e7f8      	b.n	400a52 <_ffs+0x22>

00400a60 <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  400a60:	b510      	push	{r4, lr}
  400a62:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  400a64:	2300      	movs	r3, #0
  400a66:	9301      	str	r3, [sp, #4]
  400a68:	9302      	str	r3, [sp, #8]
  400a6a:	9303      	str	r3, [sp, #12]
  400a6c:	9304      	str	r3, [sp, #16]
  400a6e:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  400a70:	4b21      	ldr	r3, [pc, #132]	; (400af8 <_ext_irq_handler+0x98>)
  400a72:	6818      	ldr	r0, [r3, #0]
  400a74:	22f8      	movs	r2, #248	; 0xf8
  400a76:	4921      	ldr	r1, [pc, #132]	; (400afc <_ext_irq_handler+0x9c>)
  400a78:	3000      	adds	r0, #0
  400a7a:	bf18      	it	ne
  400a7c:	2001      	movne	r0, #1
  400a7e:	4b20      	ldr	r3, [pc, #128]	; (400b00 <_ext_irq_handler+0xa0>)
  400a80:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  400a82:	4b20      	ldr	r3, [pc, #128]	; (400b04 <_ext_irq_handler+0xa4>)
  400a84:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400a86:	6c9b      	ldr	r3, [r3, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400a88:	4013      	ands	r3, r2
  400a8a:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400a8c:	491e      	ldr	r1, [pc, #120]	; (400b08 <_ext_irq_handler+0xa8>)
  400a8e:	6cca      	ldr	r2, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400a90:	6c89      	ldr	r1, [r1, #72]	; 0x48
	flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	flags[1] = hri_pio_read_ISR_reg(PIOB);
	flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400a92:	400a      	ands	r2, r1
  400a94:	9202      	str	r2, [sp, #8]
	flag_total |= flags[1];
  400a96:	4313      	orrs	r3, r2
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400a98:	e025      	b.n	400ae6 <_ext_irq_handler+0x86>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  400a9a:	4b17      	ldr	r3, [pc, #92]	; (400af8 <_ext_irq_handler+0x98>)
  400a9c:	681b      	ldr	r3, [r3, #0]
  400a9e:	4620      	mov	r0, r4
  400aa0:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  400aa2:	1163      	asrs	r3, r4, #5
  400aa4:	f004 041f 	and.w	r4, r4, #31
  400aa8:	2201      	movs	r2, #1
  400aaa:	fa02 f404 	lsl.w	r4, r2, r4
  400aae:	aa06      	add	r2, sp, #24
  400ab0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400ab4:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400ab8:	ea22 0204 	bic.w	r2, r2, r4
  400abc:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  400ac0:	2105      	movs	r1, #5
  400ac2:	a801      	add	r0, sp, #4
  400ac4:	4b11      	ldr	r3, [pc, #68]	; (400b0c <_ext_irq_handler+0xac>)
  400ac6:	4798      	blx	r3
  400ac8:	4604      	mov	r4, r0
		while (-1 != pos) {
  400aca:	f1b4 3fff 	cmp.w	r4, #4294967295
  400ace:	d1e4      	bne.n	400a9a <_ext_irq_handler+0x3a>
	return ((Pio *)hw)->PIO_ISR;
  400ad0:	4a0c      	ldr	r2, [pc, #48]	; (400b04 <_ext_irq_handler+0xa4>)
  400ad2:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400ad4:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400ad6:	400b      	ands	r3, r1
  400ad8:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400ada:	490b      	ldr	r1, [pc, #44]	; (400b08 <_ext_irq_handler+0xa8>)
  400adc:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400ade:	6c8a      	ldr	r2, [r1, #72]	; 0x48
		flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
		flags[1] = hri_pio_read_ISR_reg(PIOB);
		flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400ae0:	4002      	ands	r2, r0
  400ae2:	9202      	str	r2, [sp, #8]
		flag_total |= flags[1];
  400ae4:	4313      	orrs	r3, r2
	while (flag_total) {
  400ae6:	b12b      	cbz	r3, 400af4 <_ext_irq_handler+0x94>
		pos = _ffs(flags, 5);
  400ae8:	2105      	movs	r1, #5
  400aea:	a801      	add	r0, sp, #4
  400aec:	4b07      	ldr	r3, [pc, #28]	; (400b0c <_ext_irq_handler+0xac>)
  400aee:	4798      	blx	r3
  400af0:	4604      	mov	r4, r0
		while (-1 != pos) {
  400af2:	e7ea      	b.n	400aca <_ext_irq_handler+0x6a>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  400af4:	b006      	add	sp, #24
  400af6:	bd10      	pop	{r4, pc}
  400af8:	20400098 	.word	0x20400098
  400afc:	0040283c 	.word	0x0040283c
  400b00:	0040098d 	.word	0x0040098d
  400b04:	400e0e00 	.word	0x400e0e00
  400b08:	400e1000 	.word	0x400e1000
  400b0c:	00400a31 	.word	0x00400a31

00400b10 <_pio_get_hardware_index>:
{
  400b10:	b510      	push	{r4, lr}
	ASSERT(hw);
  400b12:	4604      	mov	r4, r0
  400b14:	22d2      	movs	r2, #210	; 0xd2
  400b16:	4905      	ldr	r1, [pc, #20]	; (400b2c <_pio_get_hardware_index+0x1c>)
  400b18:	3000      	adds	r0, #0
  400b1a:	bf18      	it	ne
  400b1c:	2001      	movne	r0, #1
  400b1e:	4b04      	ldr	r3, [pc, #16]	; (400b30 <_pio_get_hardware_index+0x20>)
  400b20:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  400b22:	4804      	ldr	r0, [pc, #16]	; (400b34 <_pio_get_hardware_index+0x24>)
  400b24:	4420      	add	r0, r4
}
  400b26:	f3c0 2047 	ubfx	r0, r0, #9, #8
  400b2a:	bd10      	pop	{r4, pc}
  400b2c:	0040283c 	.word	0x0040283c
  400b30:	0040098d 	.word	0x0040098d
  400b34:	bff1f200 	.word	0xbff1f200

00400b38 <_pio_get_index>:
{
  400b38:	b510      	push	{r4, lr}
	ASSERT(hw);
  400b3a:	4604      	mov	r4, r0
  400b3c:	22e0      	movs	r2, #224	; 0xe0
  400b3e:	490d      	ldr	r1, [pc, #52]	; (400b74 <_pio_get_index+0x3c>)
  400b40:	3000      	adds	r0, #0
  400b42:	bf18      	it	ne
  400b44:	2001      	movne	r0, #1
  400b46:	4b0c      	ldr	r3, [pc, #48]	; (400b78 <_pio_get_index+0x40>)
  400b48:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  400b4a:	4620      	mov	r0, r4
  400b4c:	4b0b      	ldr	r3, [pc, #44]	; (400b7c <_pio_get_index+0x44>)
  400b4e:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400b50:	2300      	movs	r3, #0
  400b52:	2b01      	cmp	r3, #1
  400b54:	d80b      	bhi.n	400b6e <_pio_get_index+0x36>
		if (_ext_irq[i].number == offset) {
  400b56:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  400b5a:	008a      	lsls	r2, r1, #2
  400b5c:	4908      	ldr	r1, [pc, #32]	; (400b80 <_pio_get_index+0x48>)
  400b5e:	5c8a      	ldrb	r2, [r1, r2]
  400b60:	4290      	cmp	r0, r2
  400b62:	d002      	beq.n	400b6a <_pio_get_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400b64:	3301      	adds	r3, #1
  400b66:	b2db      	uxtb	r3, r3
  400b68:	e7f3      	b.n	400b52 <_pio_get_index+0x1a>
			return i;
  400b6a:	b258      	sxtb	r0, r3
  400b6c:	bd10      	pop	{r4, pc}
	return ERR_INVALID_DATA;
  400b6e:	f04f 30ff 	mov.w	r0, #4294967295
}
  400b72:	bd10      	pop	{r4, pc}
  400b74:	0040283c 	.word	0x0040283c
  400b78:	0040098d 	.word	0x0040098d
  400b7c:	00400b11 	.word	0x00400b11
  400b80:	004027fc 	.word	0x004027fc

00400b84 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400b84:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400b86:	4604      	mov	r4, r0
  400b88:	f240 1259 	movw	r2, #345	; 0x159
  400b8c:	4929      	ldr	r1, [pc, #164]	; (400c34 <_pio_init+0xb0>)
  400b8e:	3000      	adds	r0, #0
  400b90:	bf18      	it	ne
  400b92:	2001      	movne	r0, #1
  400b94:	4b28      	ldr	r3, [pc, #160]	; (400c38 <_pio_init+0xb4>)
  400b96:	4798      	blx	r3

	i = _pio_get_index(hw);
  400b98:	4620      	mov	r0, r4
  400b9a:	4b28      	ldr	r3, [pc, #160]	; (400c3c <_pio_init+0xb8>)
  400b9c:	4798      	blx	r3
	if (i < 0) {
  400b9e:	2800      	cmp	r0, #0
  400ba0:	db43      	blt.n	400c2a <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  400ba2:	4d27      	ldr	r5, [pc, #156]	; (400c40 <_pio_init+0xbc>)
  400ba4:	00c2      	lsls	r2, r0, #3
  400ba6:	1a11      	subs	r1, r2, r0
  400ba8:	008b      	lsls	r3, r1, #2
  400baa:	442b      	add	r3, r5
  400bac:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  400bae:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  400bb2:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400bb4:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400bb8:	6919      	ldr	r1, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  400bba:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
  400bbe:	699b      	ldr	r3, [r3, #24]
	((Pio *)hw)->PIO_FELLSR = mask;
  400bc0:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400bc4:	1a10      	subs	r0, r2, r0
  400bc6:	0083      	lsls	r3, r0, #2
  400bc8:	442b      	add	r3, r5
  400bca:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  400bcc:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  400bd0:	4620      	mov	r0, r4
  400bd2:	4b1c      	ldr	r3, [pc, #112]	; (400c44 <_pio_init+0xc0>)
  400bd4:	4798      	blx	r3
  400bd6:	4428      	add	r0, r5
  400bd8:	f990 3038 	ldrsb.w	r3, [r0, #56]	; 0x38
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400bdc:	2b00      	cmp	r3, #0
  400bde:	db0c      	blt.n	400bfa <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400be0:	095a      	lsrs	r2, r3, #5
  400be2:	f003 001f 	and.w	r0, r3, #31
  400be6:	2101      	movs	r1, #1
  400be8:	4081      	lsls	r1, r0
  400bea:	3220      	adds	r2, #32
  400bec:	4816      	ldr	r0, [pc, #88]	; (400c48 <_pio_init+0xc4>)
  400bee:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  400bf2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400bf6:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400bfa:	2b00      	cmp	r3, #0
  400bfc:	db08      	blt.n	400c10 <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400bfe:	095a      	lsrs	r2, r3, #5
  400c00:	f003 001f 	and.w	r0, r3, #31
  400c04:	2101      	movs	r1, #1
  400c06:	4081      	lsls	r1, r0
  400c08:	3260      	adds	r2, #96	; 0x60
  400c0a:	480f      	ldr	r0, [pc, #60]	; (400c48 <_pio_init+0xc4>)
  400c0c:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  400c10:	2b00      	cmp	r3, #0
  400c12:	db0d      	blt.n	400c30 <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c14:	0959      	lsrs	r1, r3, #5
  400c16:	f003 031f 	and.w	r3, r3, #31
  400c1a:	2201      	movs	r2, #1
  400c1c:	fa02 f303 	lsl.w	r3, r2, r3
  400c20:	4a09      	ldr	r2, [pc, #36]	; (400c48 <_pio_init+0xc4>)
  400c22:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  400c26:	2000      	movs	r0, #0
  400c28:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  400c2a:	f06f 0010 	mvn.w	r0, #16
  400c2e:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  400c30:	2000      	movs	r0, #0
}
  400c32:	bd38      	pop	{r3, r4, r5, pc}
  400c34:	0040283c 	.word	0x0040283c
  400c38:	0040098d 	.word	0x0040098d
  400c3c:	00400b39 	.word	0x00400b39
  400c40:	004027fc 	.word	0x004027fc
  400c44:	00400b11 	.word	0x00400b11
  400c48:	e000e100 	.word	0xe000e100

00400c4c <PIOA_Handler>:
{
  400c4c:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400c4e:	4b01      	ldr	r3, [pc, #4]	; (400c54 <PIOA_Handler+0x8>)
  400c50:	4798      	blx	r3
  400c52:	bd08      	pop	{r3, pc}
  400c54:	00400a61 	.word	0x00400a61

00400c58 <PIOB_Handler>:
{
  400c58:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400c5a:	4b01      	ldr	r3, [pc, #4]	; (400c60 <PIOB_Handler+0x8>)
  400c5c:	4798      	blx	r3
  400c5e:	bd08      	pop	{r3, pc}
  400c60:	00400a61 	.word	0x00400a61

00400c64 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400c64:	b538      	push	{r3, r4, r5, lr}
  400c66:	4605      	mov	r5, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  400c68:	4804      	ldr	r0, [pc, #16]	; (400c7c <_ext_irq_init+0x18>)
  400c6a:	4c05      	ldr	r4, [pc, #20]	; (400c80 <_ext_irq_init+0x1c>)
  400c6c:	47a0      	blx	r4
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	_pio_init(PIOB);
  400c6e:	4805      	ldr	r0, [pc, #20]	; (400c84 <_ext_irq_init+0x20>)
  400c70:	47a0      	blx	r4

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  400c72:	4b05      	ldr	r3, [pc, #20]	; (400c88 <_ext_irq_init+0x24>)
  400c74:	601d      	str	r5, [r3, #0]

	return ERR_NONE;
}
  400c76:	2000      	movs	r0, #0
  400c78:	bd38      	pop	{r3, r4, r5, pc}
  400c7a:	bf00      	nop
  400c7c:	400e0e00 	.word	0x400e0e00
  400c80:	00400b85 	.word	0x00400b85
  400c84:	400e1000 	.word	0x400e1000
  400c88:	20400098 	.word	0x20400098

00400c8c <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400c8c:	490e      	ldr	r1, [pc, #56]	; (400cc8 <_pmc_init_sources+0x3c>)
  400c8e:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400c90:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400c94:	4b0d      	ldr	r3, [pc, #52]	; (400ccc <_pmc_init_sources+0x40>)
  400c96:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400c98:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400c9a:	4b0b      	ldr	r3, [pc, #44]	; (400cc8 <_pmc_init_sources+0x3c>)
  400c9c:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400c9e:	f013 0f01 	tst.w	r3, #1
  400ca2:	d0fa      	beq.n	400c9a <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400ca4:	4b08      	ldr	r3, [pc, #32]	; (400cc8 <_pmc_init_sources+0x3c>)
  400ca6:	6a19      	ldr	r1, [r3, #32]
  400ca8:	4a09      	ldr	r2, [pc, #36]	; (400cd0 <_pmc_init_sources+0x44>)
  400caa:	430a      	orrs	r2, r1
  400cac:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400cae:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400cb0:	4a08      	ldr	r2, [pc, #32]	; (400cd4 <_pmc_init_sources+0x48>)
  400cb2:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400cb4:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  400cb6:	4a08      	ldr	r2, [pc, #32]	; (400cd8 <_pmc_init_sources+0x4c>)
  400cb8:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400cba:	4b03      	ldr	r3, [pc, #12]	; (400cc8 <_pmc_init_sources+0x3c>)
  400cbc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400cbe:	f013 0f02 	tst.w	r3, #2
  400cc2:	d0fa      	beq.n	400cba <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  400cc4:	4770      	bx	lr
  400cc6:	bf00      	nop
  400cc8:	400e0600 	.word	0x400e0600
  400ccc:	00373e01 	.word	0x00373e01
  400cd0:	01370000 	.word	0x01370000
  400cd4:	f800ffff 	.word	0xf800ffff
  400cd8:	20183f01 	.word	0x20183f01

00400cdc <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400cdc:	4a11      	ldr	r2, [pc, #68]	; (400d24 <_pmc_init_master_clock+0x48>)
  400cde:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400ce0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  400ce4:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400ce6:	4b0f      	ldr	r3, [pc, #60]	; (400d24 <_pmc_init_master_clock+0x48>)
  400ce8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400cea:	f013 0f08 	tst.w	r3, #8
  400cee:	d0fa      	beq.n	400ce6 <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400cf0:	4a0c      	ldr	r2, [pc, #48]	; (400d24 <_pmc_init_master_clock+0x48>)
  400cf2:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  400cf4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  400cf8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400cfc:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400cfe:	4b09      	ldr	r3, [pc, #36]	; (400d24 <_pmc_init_master_clock+0x48>)
  400d00:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d02:	f013 0f08 	tst.w	r3, #8
  400d06:	d0fa      	beq.n	400cfe <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400d08:	4a06      	ldr	r2, [pc, #24]	; (400d24 <_pmc_init_master_clock+0x48>)
  400d0a:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400d0c:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400d10:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400d14:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400d16:	4b03      	ldr	r3, [pc, #12]	; (400d24 <_pmc_init_master_clock+0x48>)
  400d18:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400d1a:	f013 0f08 	tst.w	r3, #8
  400d1e:	d0fa      	beq.n	400d16 <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  400d20:	4770      	bx	lr
  400d22:	bf00      	nop
  400d24:	400e0600 	.word	0x400e0600

00400d28 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  400d28:	b508      	push	{r3, lr}
	_pmc_init_sources();
  400d2a:	4b02      	ldr	r3, [pc, #8]	; (400d34 <_pmc_init+0xc>)
  400d2c:	4798      	blx	r3
	_pmc_init_master_clock();
  400d2e:	4b02      	ldr	r3, [pc, #8]	; (400d38 <_pmc_init+0x10>)
  400d30:	4798      	blx	r3
  400d32:	bd08      	pop	{r3, pc}
  400d34:	00400c8d 	.word	0x00400c8d
  400d38:	00400cdd 	.word	0x00400cdd

00400d3c <_spi_sync_enable>:
}

static inline void hri_spi_write_CR_reg(const void *const hw, hri_spi_cr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_CR = data;
  400d3c:	2301      	movs	r3, #1
  400d3e:	6003      	str	r3, [r0, #0]
static int32_t _spi_sync_enable(void *const hw)
{
	hri_spi_write_CR_reg(hw, SPI_CR_SPIEN);

	return ERR_NONE;
}
  400d40:	2000      	movs	r0, #0
  400d42:	4770      	bx	lr

00400d44 <_spi_get_hardware_index>:
 * \brief Retrieve ordinal number of the given SPI hardware instance
 */
static uint8_t _spi_get_hardware_index(const void *const hw)
{

	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  400d44:	4b04      	ldr	r3, [pc, #16]	; (400d58 <_spi_get_hardware_index+0x14>)
  400d46:	4403      	add	r3, r0
  400d48:	f3c3 4307 	ubfx	r3, r3, #16, #8

	if (index == 5) {
  400d4c:	2b05      	cmp	r3, #5
  400d4e:	d001      	beq.n	400d54 <_spi_get_hardware_index+0x10>
		return 1;
	} else {
		return 0;
  400d50:	2000      	movs	r0, #0
	}
}
  400d52:	4770      	bx	lr
		return 1;
  400d54:	2001      	movs	r0, #1
  400d56:	4770      	bx	lr
  400d58:	bfff8000 	.word	0xbfff8000

00400d5c <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  400d5c:	b570      	push	{r4, r5, r6, lr}
  400d5e:	4606      	mov	r6, r0
  400d60:	460c      	mov	r4, r1
	uint8_t n = _spi_get_hardware_index((const void *)hw_addr);
  400d62:	4608      	mov	r0, r1
  400d64:	4b20      	ldr	r3, [pc, #128]	; (400de8 <_spi_m_sync_init+0x8c>)
  400d66:	4798      	blx	r3
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  400d68:	2300      	movs	r3, #0
  400d6a:	b33b      	cbz	r3, 400dbc <_spi_m_sync_init+0x60>
	return NULL;
  400d6c:	2500      	movs	r5, #0
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  400d6e:	f44f 729a 	mov.w	r2, #308	; 0x134
  400d72:	491e      	ldr	r1, [pc, #120]	; (400dec <_spi_m_sync_init+0x90>)
  400d74:	2e00      	cmp	r6, #0
  400d76:	bf18      	it	ne
  400d78:	2c00      	cmpne	r4, #0
  400d7a:	bf14      	ite	ne
  400d7c:	2001      	movne	r0, #1
  400d7e:	2000      	moveq	r0, #0
  400d80:	4b1b      	ldr	r3, [pc, #108]	; (400df0 <_spi_m_sync_init+0x94>)
  400d82:	4798      	blx	r3

	if (regs == NULL) {
  400d84:	b355      	cbz	r5, 400ddc <_spi_m_sync_init+0x80>
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  400d86:	6923      	ldr	r3, [r4, #16]
		return ERR_INVALID_ARG;
	}

	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  400d88:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400d8c:	d129      	bne.n	400de2 <_spi_m_sync_init+0x86>
	((Spi *)hw)->SPI_CR = data;
  400d8e:	2380      	movs	r3, #128	; 0x80
  400d90:	6023      	str	r3, [r4, #0]
		return ERR_DENIED;
	}
	hri_spi_write_CR_reg(hw, SPI_CR_SWRST);
	dev->prvt = hw;
  400d92:	6034      	str	r4, [r6, #0]
	hri_spi_write_CR_reg(hw, (regs->cr & ~(SPI_CR_SPIEN | SPI_CR_SPIDIS | SPI_CR_SWRST | SPI_CR_LASTXFER)));
  400d94:	686a      	ldr	r2, [r5, #4]
  400d96:	4b17      	ldr	r3, [pc, #92]	; (400df4 <_spi_m_sync_init+0x98>)
  400d98:	4013      	ands	r3, r2
  400d9a:	6023      	str	r3, [r4, #0]
	hri_spi_write_MR_reg(hw, ((regs->mr | SPI_MR_PCS(0x0E) | SPI_MR_MODFDIS) & ~SPI_MR_LLB));
  400d9c:	68ab      	ldr	r3, [r5, #8]
  400d9e:	4a16      	ldr	r2, [pc, #88]	; (400df8 <_spi_m_sync_init+0x9c>)
  400da0:	401a      	ands	r2, r3
  400da2:	4b16      	ldr	r3, [pc, #88]	; (400dfc <_spi_m_sync_init+0xa0>)
  400da4:	4313      	orrs	r3, r2
	((Spi *)hw)->SPI_MR = data;
  400da6:	6063      	str	r3, [r4, #4]
	hri_spi_write_CSR_reg(hw, 0, regs->csr);
  400da8:	68eb      	ldr	r3, [r5, #12]
	((Spi *)hw)->SPI_CSR[index] = data;
  400daa:	6323      	str	r3, [r4, #48]	; 0x30

	dev->dummy_byte = regs->dummy_byte;
  400dac:	8a2b      	ldrh	r3, [r5, #16]
  400dae:	80f3      	strh	r3, [r6, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  400db0:	68eb      	ldr	r3, [r5, #12]
  400db2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  400db6:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
  400db8:	2000      	movs	r0, #0
  400dba:	bd70      	pop	{r4, r5, r6, pc}
		if (spi_regs[i].number == n) {
  400dbc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  400dc0:	008a      	lsls	r2, r1, #2
  400dc2:	490f      	ldr	r1, [pc, #60]	; (400e00 <_spi_m_sync_init+0xa4>)
  400dc4:	5c8a      	ldrb	r2, [r1, r2]
  400dc6:	4290      	cmp	r0, r2
  400dc8:	d002      	beq.n	400dd0 <_spi_m_sync_init+0x74>
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  400dca:	3301      	adds	r3, #1
  400dcc:	b2db      	uxtb	r3, r3
  400dce:	e7cc      	b.n	400d6a <_spi_m_sync_init+0xe>
			return &spi_regs[i];
  400dd0:	eb03 0583 	add.w	r5, r3, r3, lsl #2
  400dd4:	00ab      	lsls	r3, r5, #2
  400dd6:	460d      	mov	r5, r1
  400dd8:	441d      	add	r5, r3
  400dda:	e7c8      	b.n	400d6e <_spi_m_sync_init+0x12>
		return ERR_INVALID_ARG;
  400ddc:	f06f 000c 	mvn.w	r0, #12
  400de0:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
  400de2:	f06f 0010 	mvn.w	r0, #16
}
  400de6:	bd70      	pop	{r4, r5, r6, pc}
  400de8:	00400d45 	.word	0x00400d45
  400dec:	0040286c 	.word	0x0040286c
  400df0:	0040098d 	.word	0x0040098d
  400df4:	feffff7c 	.word	0xfeffff7c
  400df8:	fff1ff6f 	.word	0xfff1ff6f
  400dfc:	000e0010 	.word	0x000e0010
  400e00:	00402858 	.word	0x00402858

00400e04 <_spi_m_sync_enable>:

	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
  400e04:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  400e06:	4604      	mov	r4, r0
  400e08:	b168      	cbz	r0, 400e26 <_spi_m_sync_enable+0x22>
  400e0a:	6803      	ldr	r3, [r0, #0]
  400e0c:	b14b      	cbz	r3, 400e22 <_spi_m_sync_enable+0x1e>
  400e0e:	2001      	movs	r0, #1
  400e10:	f44f 72b9 	mov.w	r2, #370	; 0x172
  400e14:	4905      	ldr	r1, [pc, #20]	; (400e2c <_spi_m_sync_enable+0x28>)
  400e16:	4b06      	ldr	r3, [pc, #24]	; (400e30 <_spi_m_sync_enable+0x2c>)
  400e18:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
  400e1a:	6820      	ldr	r0, [r4, #0]
  400e1c:	4b05      	ldr	r3, [pc, #20]	; (400e34 <_spi_m_sync_enable+0x30>)
  400e1e:	4798      	blx	r3
}
  400e20:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
  400e22:	2000      	movs	r0, #0
  400e24:	e7f4      	b.n	400e10 <_spi_m_sync_enable+0xc>
  400e26:	2000      	movs	r0, #0
  400e28:	e7f2      	b.n	400e10 <_spi_m_sync_enable+0xc>
  400e2a:	bf00      	nop
  400e2c:	0040286c 	.word	0x0040286c
  400e30:	0040098d 	.word	0x0040098d
  400e34:	00400d3d 	.word	0x00400d3d

00400e38 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
  400e38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400e3c:	b086      	sub	sp, #24
  400e3e:	4607      	mov	r7, r0
  400e40:	460d      	mov	r5, r1
	void *                 hw   = dev->prvt;
  400e42:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
  400e44:	680b      	ldr	r3, [r1, #0]
  400e46:	9301      	str	r3, [sp, #4]
  400e48:	684b      	ldr	r3, [r1, #4]
  400e4a:	9302      	str	r3, [sp, #8]
  400e4c:	2300      	movs	r3, #0
  400e4e:	9303      	str	r3, [sp, #12]
  400e50:	9304      	str	r3, [sp, #16]
  400e52:	7903      	ldrb	r3, [r0, #4]
  400e54:	f88d 3014 	strb.w	r3, [sp, #20]

	ASSERT(dev && hw);
  400e58:	1c26      	adds	r6, r4, #0
  400e5a:	bf18      	it	ne
  400e5c:	2601      	movne	r6, #1
  400e5e:	f240 2231 	movw	r2, #561	; 0x231
  400e62:	4933      	ldr	r1, [pc, #204]	; (400f30 <_spi_m_sync_trans+0xf8>)
  400e64:	2800      	cmp	r0, #0
  400e66:	bf0c      	ite	eq
  400e68:	2000      	moveq	r0, #0
  400e6a:	f006 0001 	andne.w	r0, r6, #1
  400e6e:	4b31      	ldr	r3, [pc, #196]	; (400f34 <_spi_m_sync_trans+0xfc>)
  400e70:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  400e72:	6923      	ldr	r3, [r4, #16]

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_spi_get_SR_SPIENS_bit(hw)) {
  400e74:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400e78:	d122      	bne.n	400ec0 <_spi_m_sync_trans+0x88>
		return ERR_NOT_INITIALIZED;
  400e7a:	f06f 0013 	mvn.w	r0, #19
  400e7e:	e053      	b.n	400f28 <_spi_m_sync_trans+0xf0>
		return false;
  400e80:	2300      	movs	r3, #0
  400e82:	e035      	b.n	400ef0 <_spi_m_sync_trans+0xb8>
			data |= (*ctrl->txbuf) << 8;
  400e84:	7850      	ldrb	r0, [r2, #1]
  400e86:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			ctrl->txbuf++;
  400e8a:	3202      	adds	r2, #2
  400e8c:	9201      	str	r2, [sp, #4]
	ctrl->txcnt++;
  400e8e:	3301      	adds	r3, #1
  400e90:	9303      	str	r3, [sp, #12]
}

static inline void hri_spi_write_TDR_reg(const void *const hw, hri_spi_tdr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_TDR = data;
  400e92:	60e1      	str	r1, [r4, #12]
	return ((Spi *)hw)->SPI_SR;
  400e94:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ASSERT(hw);
  400e98:	f240 2222 	movw	r2, #546	; 0x222
  400e9c:	4924      	ldr	r1, [pc, #144]	; (400f30 <_spi_m_sync_trans+0xf8>)
  400e9e:	4630      	mov	r0, r6
  400ea0:	4b24      	ldr	r3, [pc, #144]	; (400f34 <_spi_m_sync_trans+0xfc>)
  400ea2:	4798      	blx	r3
	if (SPI_SR_OVRES & iflag) {
  400ea4:	f018 0f08 	tst.w	r8, #8
  400ea8:	d038      	beq.n	400f1c <_spi_m_sync_trans+0xe4>
		return ERR_OVERFLOW;
  400eaa:	f06f 0012 	mvn.w	r0, #18
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
			}
		}
		rc = _spi_err_check(hri_spi_read_SR_reg(hw), hw);
		if (rc < 0) {
  400eae:	2800      	cmp	r0, #0
  400eb0:	db36      	blt.n	400f20 <_spi_m_sync_trans+0xe8>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
  400eb2:	9803      	ldr	r0, [sp, #12]
  400eb4:	68ab      	ldr	r3, [r5, #8]
  400eb6:	4298      	cmp	r0, r3
  400eb8:	d302      	bcc.n	400ec0 <_spi_m_sync_trans+0x88>
  400eba:	9a04      	ldr	r2, [sp, #16]
  400ebc:	4293      	cmp	r3, r2
  400ebe:	d92f      	bls.n	400f20 <_spi_m_sync_trans+0xe8>
  400ec0:	6923      	ldr	r3, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_RDRF)) {
  400ec2:	f013 0f01 	tst.w	r3, #1
  400ec6:	d0db      	beq.n	400e80 <_spi_m_sync_trans+0x48>
	return (((Spi *)hw)->SPI_RDR & SPI_RDR_RD_Msk) >> SPI_RDR_RD_Pos;
  400ec8:	68a3      	ldr	r3, [r4, #8]
  400eca:	b29b      	uxth	r3, r3
	if (ctrl->rxbuf) {
  400ecc:	9a02      	ldr	r2, [sp, #8]
  400ece:	b15a      	cbz	r2, 400ee8 <_spi_m_sync_trans+0xb0>
		*ctrl->rxbuf++ = (uint8_t)data;
  400ed0:	1c51      	adds	r1, r2, #1
  400ed2:	9102      	str	r1, [sp, #8]
  400ed4:	7013      	strb	r3, [r2, #0]
		if (ctrl->char_size > 1) {
  400ed6:	f89d 2014 	ldrb.w	r2, [sp, #20]
  400eda:	2a01      	cmp	r2, #1
  400edc:	d904      	bls.n	400ee8 <_spi_m_sync_trans+0xb0>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
  400ede:	460a      	mov	r2, r1
  400ee0:	3101      	adds	r1, #1
  400ee2:	9102      	str	r1, [sp, #8]
  400ee4:	0a1b      	lsrs	r3, r3, #8
  400ee6:	7013      	strb	r3, [r2, #0]
	ctrl->rxcnt++;
  400ee8:	9b04      	ldr	r3, [sp, #16]
  400eea:	3301      	adds	r3, #1
  400eec:	9304      	str	r3, [sp, #16]
	return true;
  400eee:	2301      	movs	r3, #1
		if (!_spi_rx_check_and_receive(hw, &ctrl)) {
  400ef0:	2b00      	cmp	r3, #0
  400ef2:	d1cf      	bne.n	400e94 <_spi_m_sync_trans+0x5c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
  400ef4:	9b03      	ldr	r3, [sp, #12]
  400ef6:	9a04      	ldr	r2, [sp, #16]
  400ef8:	429a      	cmp	r2, r3
  400efa:	d3cb      	bcc.n	400e94 <_spi_m_sync_trans+0x5c>
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
  400efc:	88f9      	ldrh	r1, [r7, #6]
	return ((Spi *)hw)->SPI_SR;
  400efe:	6922      	ldr	r2, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_TDRE)) {
  400f00:	f012 0f02 	tst.w	r2, #2
  400f04:	d0c6      	beq.n	400e94 <_spi_m_sync_trans+0x5c>
	if (ctrl->txbuf) {
  400f06:	9a01      	ldr	r2, [sp, #4]
  400f08:	2a00      	cmp	r2, #0
  400f0a:	d0c0      	beq.n	400e8e <_spi_m_sync_trans+0x56>
		data = *ctrl->txbuf++;
  400f0c:	1c51      	adds	r1, r2, #1
  400f0e:	9101      	str	r1, [sp, #4]
  400f10:	7811      	ldrb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
  400f12:	f89d 0014 	ldrb.w	r0, [sp, #20]
  400f16:	2801      	cmp	r0, #1
  400f18:	d8b4      	bhi.n	400e84 <_spi_m_sync_trans+0x4c>
  400f1a:	e7b8      	b.n	400e8e <_spi_m_sync_trans+0x56>
	return ERR_NONE;
  400f1c:	2000      	movs	r0, #0
  400f1e:	e7c6      	b.n	400eae <_spi_m_sync_trans+0x76>
	tmp = ((Spi *)hw)->SPI_SR;
  400f20:	6923      	ldr	r3, [r4, #16]
	while (!(hri_spi_get_SR_reg(hw, SPI_SR_TXEMPTY))) {
  400f22:	f413 7f00 	tst.w	r3, #512	; 0x200
  400f26:	d0fb      	beq.n	400f20 <_spi_m_sync_trans+0xe8>

	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
  400f28:	b006      	add	sp, #24
  400f2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  400f2e:	bf00      	nop
  400f30:	0040286c 	.word	0x0040286c
  400f34:	0040098d 	.word	0x0040098d

00400f38 <_spi_get_spi_m_sync>:
 * \brief Retrieve usart sync helper functions
 */
void *_spi_get_spi_m_sync(void)
{
	return (void *)NULL;
}
  400f38:	2000      	movs	r0, #0
  400f3a:	4770      	bx	lr

00400f3c <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  400f3c:	4b03      	ldr	r3, [pc, #12]	; (400f4c <_system_time_init+0x10>)
  400f3e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  400f42:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  400f44:	2205      	movs	r2, #5
  400f46:	601a      	str	r2, [r3, #0]
  400f48:	4770      	bx	lr
  400f4a:	bf00      	nop
  400f4c:	e000e010 	.word	0xe000e010

00400f50 <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  400f50:	b508      	push	{r3, lr}
	_system_time_init(hw);
  400f52:	4b01      	ldr	r3, [pc, #4]	; (400f58 <_delay_init+0x8>)
  400f54:	4798      	blx	r3
  400f56:	bd08      	pop	{r3, pc}
  400f58:	00400f3d 	.word	0x00400f3d

00400f5c <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
  400f5c:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
  400f5e:	e00d      	b.n	400f7c <_delay_cycles+0x20>
		SysTick->LOAD = 0xFFFFFF;
  400f60:	4b0d      	ldr	r3, [pc, #52]	; (400f98 <_delay_cycles+0x3c>)
  400f62:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
  400f66:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
  400f68:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  400f6a:	4b0b      	ldr	r3, [pc, #44]	; (400f98 <_delay_cycles+0x3c>)
  400f6c:	681b      	ldr	r3, [r3, #0]
  400f6e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400f72:	d0fa      	beq.n	400f6a <_delay_cycles+0xe>
			;
		buf -= 0xFFFFFF;
  400f74:	f101 417f 	add.w	r1, r1, #4278190080	; 0xff000000
  400f78:	3101      	adds	r1, #1
	while (n--) {
  400f7a:	4610      	mov	r0, r2
  400f7c:	1e43      	subs	r3, r0, #1
  400f7e:	b2da      	uxtb	r2, r3
  400f80:	2800      	cmp	r0, #0
  400f82:	d1ed      	bne.n	400f60 <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
  400f84:	4b04      	ldr	r3, [pc, #16]	; (400f98 <_delay_cycles+0x3c>)
  400f86:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
  400f88:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  400f8a:	4b03      	ldr	r3, [pc, #12]	; (400f98 <_delay_cycles+0x3c>)
  400f8c:	681b      	ldr	r3, [r3, #0]
  400f8e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  400f92:	d0fa      	beq.n	400f8a <_delay_cycles+0x2e>
		;
}
  400f94:	4770      	bx	lr
  400f96:	bf00      	nop
  400f98:	e000e010 	.word	0xe000e010

00400f9c <_get_i2cm_sync_cfg>:
 */
static const struct _i2cm_sync_cfg *_get_i2cm_sync_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  400f9c:	2300      	movs	r3, #0
  400f9e:	b13b      	cbz	r3, 400fb0 <_get_i2cm_sync_cfg+0x14>
		if (_i2cm_sync_cfgs[i].hw == hw) {
			return &(_i2cm_sync_cfgs[i]);
		}
	}
	return NULL;
  400fa0:	2000      	movs	r0, #0
  400fa2:	4770      	bx	lr
			return &(_i2cm_sync_cfgs[i]);
  400fa4:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  400fa8:	00e3      	lsls	r3, r4, #3
  400faa:	4608      	mov	r0, r1
  400fac:	4418      	add	r0, r3
  400fae:	e00c      	b.n	400fca <_get_i2cm_sync_cfg+0x2e>
{
  400fb0:	b410      	push	{r4}
		if (_i2cm_sync_cfgs[i].hw == hw) {
  400fb2:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  400fb6:	00ca      	lsls	r2, r1, #3
  400fb8:	4905      	ldr	r1, [pc, #20]	; (400fd0 <_get_i2cm_sync_cfg+0x34>)
  400fba:	588a      	ldr	r2, [r1, r2]
  400fbc:	4282      	cmp	r2, r0
  400fbe:	d0f1      	beq.n	400fa4 <_get_i2cm_sync_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  400fc0:	3301      	adds	r3, #1
  400fc2:	b2db      	uxtb	r3, r3
  400fc4:	2b00      	cmp	r3, #0
  400fc6:	d0f4      	beq.n	400fb2 <_get_i2cm_sync_cfg+0x16>
	return NULL;
  400fc8:	2000      	movs	r0, #0
}
  400fca:	f85d 4b04 	ldr.w	r4, [sp], #4
  400fce:	4770      	bx	lr
  400fd0:	00402884 	.word	0x00402884

00400fd4 <_i2c_m_sync_init>:

int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const dev, void *const hw)
{
  400fd4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && hw);
  400fd6:	4604      	mov	r4, r0
  400fd8:	460d      	mov	r5, r1
  400fda:	2800      	cmp	r0, #0
  400fdc:	bf18      	it	ne
  400fde:	2900      	cmpne	r1, #0
  400fe0:	bf14      	ite	ne
  400fe2:	2001      	movne	r0, #1
  400fe4:	2000      	moveq	r0, #0
  400fe6:	2278      	movs	r2, #120	; 0x78
  400fe8:	4909      	ldr	r1, [pc, #36]	; (401010 <_i2c_m_sync_init+0x3c>)
  400fea:	4b0a      	ldr	r3, [pc, #40]	; (401014 <_i2c_m_sync_init+0x40>)
  400fec:	4798      	blx	r3

	const struct _i2cm_sync_cfg *cfg;

	dev->hw = hw;
  400fee:	6125      	str	r5, [r4, #16]
	cfg     = _get_i2cm_sync_cfg(dev->hw);
  400ff0:	4628      	mov	r0, r5
  400ff2:	4b09      	ldr	r3, [pc, #36]	; (401018 <_i2c_m_sync_init+0x44>)
  400ff4:	4798      	blx	r3

	// hri_twihs_write_CR_reg(hw, TWIHS_CR_SWRST);
	// hri_twihs_read_RHR_reg(hw);
	hri_twihs_write_CR_reg(dev->hw, cfg->ctrl);
  400ff6:	6843      	ldr	r3, [r0, #4]
}

static inline void hri_twihs_write_CR_reg(const void *const hw, hri_twihs_cr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_CR = data;
  400ff8:	602b      	str	r3, [r5, #0]
	hri_twihs_write_SMBTR_reg(dev->hw, cfg->smbtr);
  400ffa:	6923      	ldr	r3, [r4, #16]
  400ffc:	6882      	ldr	r2, [r0, #8]
	((Twihs *)hw)->TWIHS_SMBTR = data;
  400ffe:	639a      	str	r2, [r3, #56]	; 0x38
	hri_twihs_write_FILTR_reg(dev->hw, cfg->filtr);
  401000:	6923      	ldr	r3, [r4, #16]
  401002:	68c2      	ldr	r2, [r0, #12]
	((Twihs *)hw)->TWIHS_FILTR = data;
  401004:	645a      	str	r2, [r3, #68]	; 0x44
	hri_twihs_write_CWGR_reg(dev->hw, cfg->cwgr);
  401006:	6923      	ldr	r3, [r4, #16]
  401008:	6902      	ldr	r2, [r0, #16]
	((Twihs *)hw)->TWIHS_CWGR = data;
  40100a:	611a      	str	r2, [r3, #16]

	return ERR_NONE;
}
  40100c:	2000      	movs	r0, #0
  40100e:	bd38      	pop	{r3, r4, r5, pc}
  401010:	0040289c 	.word	0x0040289c
  401014:	0040098d 	.word	0x0040098d
  401018:	00400f9d 	.word	0x00400f9d

0040101c <_i2c_m_sync_transfer>:

	return ERR_NONE;
}

int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
  40101c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && msg);
  40101e:	4604      	mov	r4, r0
  401020:	460d      	mov	r5, r1
  401022:	2800      	cmp	r0, #0
  401024:	bf18      	it	ne
  401026:	2900      	cmpne	r1, #0
  401028:	bf14      	ite	ne
  40102a:	2001      	movne	r0, #1
  40102c:	2000      	moveq	r0, #0
  40102e:	22ba      	movs	r2, #186	; 0xba
  401030:	4952      	ldr	r1, [pc, #328]	; (40117c <_i2c_m_sync_transfer+0x160>)
  401032:	4b53      	ldr	r3, [pc, #332]	; (401180 <_i2c_m_sync_transfer+0x164>)
  401034:	4798      	blx	r3

	if (dev->service.msg.flags & I2C_M_BUSY) {
  401036:	8863      	ldrh	r3, [r4, #2]
  401038:	f413 7f80 	tst.w	r3, #256	; 0x100
  40103c:	f040 809a 	bne.w	401174 <_i2c_m_sync_transfer+0x158>
		return I2C_ERR_BUSY;
	}

	if (msg->flags & I2C_M_RD) {
  401040:	886b      	ldrh	r3, [r5, #2]
  401042:	f013 0f01 	tst.w	r3, #1
  401046:	d118      	bne.n	40107a <_i2c_m_sync_transfer+0x5e>
{
	uint32_t i;
	uint32_t sr;
	int      ret = ERR_NONE;

	msg->flags |= I2C_M_BUSY;
  401048:	886b      	ldrh	r3, [r5, #2]
  40104a:	b29b      	uxth	r3, r3
  40104c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401050:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401052:	882b      	ldrh	r3, [r5, #0]
  401054:	f413 6f80 	tst.w	r3, #1024	; 0x400
  401058:	d05f      	beq.n	40111a <_i2c_m_sync_transfer+0xfe>
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1));
  40105a:	6922      	ldr	r2, [r4, #16]
  40105c:	0a1b      	lsrs	r3, r3, #8
  40105e:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401062:	041b      	lsls	r3, r3, #16
  401064:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401068:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Twihs *)hw)->TWIHS_MMR = data;
  40106c:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  40106e:	6923      	ldr	r3, [r4, #16]
  401070:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401072:	60da      	str	r2, [r3, #12]
	for (i = 0; i < msg->len; i++) {
		/* Wait for data is transferred from TWIHS_THR or if NACK is detected */
		do {
			sr = hri_twihs_read_SR_reg(dev->hw);
			if (sr & TWIHS_SR_NACK) {
				ret = I2C_NACK;
  401074:	2000      	movs	r0, #0
  401076:	4601      	mov	r1, r0
  401078:	e05c      	b.n	401134 <_i2c_m_sync_transfer+0x118>

static inline int32_t _i2c_m_sync_read(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
	uint32_t i;

	msg->flags |= I2C_M_BUSY;
  40107a:	886b      	ldrh	r3, [r5, #2]
  40107c:	b29b      	uxth	r3, r3
  40107e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401082:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401084:	882b      	ldrh	r3, [r5, #0]
  401086:	f413 6f80 	tst.w	r3, #1024	; 0x400
  40108a:	d022      	beq.n	4010d2 <_i2c_m_sync_transfer+0xb6>
		hri_twihs_write_MMR_reg(dev->hw,
  40108c:	6922      	ldr	r2, [r4, #16]
		                        TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1) | TWIHS_MMR_MREAD);
  40108e:	0a1b      	lsrs	r3, r3, #8
  401090:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401094:	041b      	lsls	r3, r3, #16
  401096:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  40109a:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
	((Twihs *)hw)->TWIHS_MMR = data;
  40109e:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  4010a0:	6923      	ldr	r3, [r4, #16]
  4010a2:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  4010a4:	60da      	str	r2, [r3, #12]
	} else {
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
	}
	/* In single data byte master read, the START and STOP must both be set */
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  4010a6:	6923      	ldr	r3, [r4, #16]
  4010a8:	686a      	ldr	r2, [r5, #4]
  4010aa:	2a01      	cmp	r2, #1
  4010ac:	d019      	beq.n	4010e2 <_i2c_m_sync_transfer+0xc6>
  4010ae:	2201      	movs	r2, #1
	((Twihs *)hw)->TWIHS_CR = data;
  4010b0:	601a      	str	r2, [r3, #0]

	for (i = 0; i < msg->len; i++) {
  4010b2:	2100      	movs	r1, #0
  4010b4:	686b      	ldr	r3, [r5, #4]
  4010b6:	4299      	cmp	r1, r3
  4010b8:	d222      	bcs.n	401100 <_i2c_m_sync_transfer+0xe4>
		/* Wait for a byte has been received in TWIHS_RHR since last read */
		while (!hri_twihs_get_SR_RXRDY_bit(dev->hw)) {
  4010ba:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_RXRDY) > 0;
  4010bc:	6a1a      	ldr	r2, [r3, #32]
  4010be:	f012 0f02 	tst.w	r2, #2
  4010c2:	d110      	bne.n	4010e6 <_i2c_m_sync_transfer+0xca>
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_NACK) > 0;
  4010c4:	6a1b      	ldr	r3, [r3, #32]
			/* Check whether slave acknowledge received after the address byte */
			if (hri_twihs_get_SR_NACK_bit(dev->hw))
  4010c6:	f413 7f80 	tst.w	r3, #256	; 0x100
  4010ca:	d0f6      	beq.n	4010ba <_i2c_m_sync_transfer+0x9e>
				return I2C_NACK;
  4010cc:	f06f 0001 	mvn.w	r0, #1
		return _i2c_m_sync_read(dev, msg);
  4010d0:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
  4010d2:	6922      	ldr	r2, [r4, #16]
  4010d4:	041b      	lsls	r3, r3, #16
  4010d6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  4010da:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Twihs *)hw)->TWIHS_MMR = data;
  4010de:	6053      	str	r3, [r2, #4]
  4010e0:	e7e1      	b.n	4010a6 <_i2c_m_sync_transfer+0x8a>
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  4010e2:	2203      	movs	r2, #3
  4010e4:	e7e4      	b.n	4010b0 <_i2c_m_sync_transfer+0x94>
		};

		msg->buffer[i] = hri_twihs_read_RHR_reg(dev->hw);
  4010e6:	68aa      	ldr	r2, [r5, #8]
	return ((Twihs *)hw)->TWIHS_RHR;
  4010e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4010ea:	5453      	strb	r3, [r2, r1]
		/* In multiple data bytes master read, the STOP must be set after the
		 * last data received but one */
		if (i == (msg->len - 2)) {
  4010ec:	686b      	ldr	r3, [r5, #4]
  4010ee:	3b02      	subs	r3, #2
  4010f0:	4299      	cmp	r1, r3
  4010f2:	d001      	beq.n	4010f8 <_i2c_m_sync_transfer+0xdc>
	for (i = 0; i < msg->len; i++) {
  4010f4:	3101      	adds	r1, #1
  4010f6:	e7dd      	b.n	4010b4 <_i2c_m_sync_transfer+0x98>
			hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  4010f8:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  4010fa:	2202      	movs	r2, #2
  4010fc:	601a      	str	r2, [r3, #0]
  4010fe:	e7f9      	b.n	4010f4 <_i2c_m_sync_transfer+0xd8>
		}
	}

	while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401100:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  401102:	6a1b      	ldr	r3, [r3, #32]
  401104:	f013 0f01 	tst.w	r3, #1
  401108:	d0fa      	beq.n	401100 <_i2c_m_sync_transfer+0xe4>
	};
	dev->service.msg.flags &= ~I2C_M_BUSY;
  40110a:	8863      	ldrh	r3, [r4, #2]
  40110c:	b29b      	uxth	r3, r3
  40110e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401112:	b29b      	uxth	r3, r3
  401114:	8063      	strh	r3, [r4, #2]

	return ERR_NONE;
  401116:	2000      	movs	r0, #0
  401118:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr));
  40111a:	6922      	ldr	r2, [r4, #16]
  40111c:	041b      	lsls	r3, r3, #16
  40111e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
	((Twihs *)hw)->TWIHS_MMR = data;
  401122:	6053      	str	r3, [r2, #4]
  401124:	e7a6      	b.n	401074 <_i2c_m_sync_transfer+0x58>
				ret = I2C_NACK;
  401126:	f06f 0001 	mvn.w	r0, #1
		if (ret != ERR_NONE)
  40112a:	b978      	cbnz	r0, 40114c <_i2c_m_sync_transfer+0x130>
		hri_twihs_write_THR_reg(dev->hw, msg->buffer[i]);
  40112c:	68ab      	ldr	r3, [r5, #8]
  40112e:	5c5b      	ldrb	r3, [r3, r1]
}

static inline void hri_twihs_write_THR_reg(const void *const hw, hri_twihs_thr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_THR = data;
  401130:	6353      	str	r3, [r2, #52]	; 0x34
	for (i = 0; i < msg->len; i++) {
  401132:	3101      	adds	r1, #1
  401134:	686b      	ldr	r3, [r5, #4]
  401136:	4299      	cmp	r1, r3
  401138:	d208      	bcs.n	40114c <_i2c_m_sync_transfer+0x130>
			sr = hri_twihs_read_SR_reg(dev->hw);
  40113a:	6922      	ldr	r2, [r4, #16]
	return ((Twihs *)hw)->TWIHS_SR;
  40113c:	6a13      	ldr	r3, [r2, #32]
			if (sr & TWIHS_SR_NACK) {
  40113e:	f413 7f80 	tst.w	r3, #256	; 0x100
  401142:	d1f0      	bne.n	401126 <_i2c_m_sync_transfer+0x10a>
		} while (!(sr & TWIHS_SR_TXRDY));
  401144:	f013 0f04 	tst.w	r3, #4
  401148:	d0f7      	beq.n	40113a <_i2c_m_sync_transfer+0x11e>
  40114a:	e7ee      	b.n	40112a <_i2c_m_sync_transfer+0x10e>
	if (msg->flags & I2C_M_STOP) {
  40114c:	886b      	ldrh	r3, [r5, #2]
  40114e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401152:	d106      	bne.n	401162 <_i2c_m_sync_transfer+0x146>
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401154:	8863      	ldrh	r3, [r4, #2]
  401156:	b29b      	uxth	r3, r3
  401158:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  40115c:	b29b      	uxth	r3, r3
  40115e:	8063      	strh	r3, [r4, #2]
		return _i2c_m_sync_write(dev, msg);
  401160:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401162:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401164:	2202      	movs	r2, #2
  401166:	601a      	str	r2, [r3, #0]
		while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401168:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  40116a:	6a1b      	ldr	r3, [r3, #32]
  40116c:	f013 0f01 	tst.w	r3, #1
  401170:	d0fa      	beq.n	401168 <_i2c_m_sync_transfer+0x14c>
  401172:	e7ef      	b.n	401154 <_i2c_m_sync_transfer+0x138>
		return I2C_ERR_BUSY;
  401174:	f06f 0005 	mvn.w	r0, #5
}
  401178:	bd38      	pop	{r3, r4, r5, pc}
  40117a:	bf00      	nop
  40117c:	0040289c 	.word	0x0040289c
  401180:	0040098d 	.word	0x0040098d

00401184 <_usart_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given usart hardware instance
 */
static uint8_t _usart_get_hardware_index(const void *const hw)
{
  401184:	b510      	push	{r4, lr}
	ASSERT(hw);
  401186:	4604      	mov	r4, r0
  401188:	f240 222b 	movw	r2, #555	; 0x22b
  40118c:	4905      	ldr	r1, [pc, #20]	; (4011a4 <_usart_get_hardware_index+0x20>)
  40118e:	3000      	adds	r0, #0
  401190:	bf18      	it	ne
  401192:	2001      	movne	r0, #1
  401194:	4b04      	ldr	r3, [pc, #16]	; (4011a8 <_usart_get_hardware_index+0x24>)
  401196:	4798      	blx	r3

#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)USART0) / sizeof(Usart);
#endif

	return ((uint32_t)hw - (uint32_t)USART0) >> 14;
  401198:	4804      	ldr	r0, [pc, #16]	; (4011ac <_usart_get_hardware_index+0x28>)
  40119a:	4420      	add	r0, r4
}
  40119c:	f3c0 3087 	ubfx	r0, r0, #14, #8
  4011a0:	bd10      	pop	{r4, pc}
  4011a2:	bf00      	nop
  4011a4:	004028c4 	.word	0x004028c4
  4011a8:	0040098d 	.word	0x0040098d
  4011ac:	bffdc000 	.word	0xbffdc000

004011b0 <_get_usart_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given usart hardware instance
 */
static uint8_t _get_usart_index(const void *const hw)
{
  4011b0:	b510      	push	{r4, lr}
	ASSERT(hw);
  4011b2:	4604      	mov	r4, r0
  4011b4:	f240 2287 	movw	r2, #647	; 0x287
  4011b8:	490e      	ldr	r1, [pc, #56]	; (4011f4 <_get_usart_index+0x44>)
  4011ba:	3000      	adds	r0, #0
  4011bc:	bf18      	it	ne
  4011be:	2001      	movne	r0, #1
  4011c0:	4b0d      	ldr	r3, [pc, #52]	; (4011f8 <_get_usart_index+0x48>)
  4011c2:	4798      	blx	r3
	uint8_t usart_offset = _usart_get_hardware_index(hw);
  4011c4:	4620      	mov	r0, r4
  4011c6:	4b0d      	ldr	r3, [pc, #52]	; (4011fc <_get_usart_index+0x4c>)
  4011c8:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  4011ca:	2300      	movs	r3, #0
  4011cc:	b143      	cbz	r3, 4011e0 <_get_usart_index+0x30>
		if (_usarts[i].number == usart_offset) {
			return i;
		}
	}

	ASSERT(false);
  4011ce:	f240 2291 	movw	r2, #657	; 0x291
  4011d2:	4908      	ldr	r1, [pc, #32]	; (4011f4 <_get_usart_index+0x44>)
  4011d4:	2000      	movs	r0, #0
  4011d6:	4b08      	ldr	r3, [pc, #32]	; (4011f8 <_get_usart_index+0x48>)
  4011d8:	4798      	blx	r3
	return 0;
  4011da:	2300      	movs	r3, #0
}
  4011dc:	4618      	mov	r0, r3
  4011de:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == usart_offset) {
  4011e0:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  4011e4:	008a      	lsls	r2, r1, #2
  4011e6:	4906      	ldr	r1, [pc, #24]	; (401200 <_get_usart_index+0x50>)
  4011e8:	5c8a      	ldrb	r2, [r1, r2]
  4011ea:	4290      	cmp	r0, r2
  4011ec:	d0f6      	beq.n	4011dc <_get_usart_index+0x2c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  4011ee:	3301      	adds	r3, #1
  4011f0:	b2db      	uxtb	r3, r3
  4011f2:	e7eb      	b.n	4011cc <_get_usart_index+0x1c>
  4011f4:	004028c4 	.word	0x004028c4
  4011f8:	0040098d 	.word	0x0040098d
  4011fc:	00401185 	.word	0x00401185
  401200:	004028b8 	.word	0x004028b8

00401204 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
  401204:	b510      	push	{r4, lr}
	ASSERT(hw);
  401206:	4604      	mov	r4, r0
  401208:	f240 229e 	movw	r2, #670	; 0x29e
  40120c:	4911      	ldr	r1, [pc, #68]	; (401254 <_usart_init+0x50>)
  40120e:	3000      	adds	r0, #0
  401210:	bf18      	it	ne
  401212:	2001      	movne	r0, #1
  401214:	4b10      	ldr	r3, [pc, #64]	; (401258 <_usart_init+0x54>)
  401216:	4798      	blx	r3
	uint8_t i = _get_usart_index(hw);
  401218:	4620      	mov	r0, r4
  40121a:	4b10      	ldr	r3, [pc, #64]	; (40125c <_usart_init+0x58>)
  40121c:	4798      	blx	r3
}

static inline void hri_usart_write_US_WPMR_reg(const void *const hw, hri_usart_us_wpmr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_WPMR = data;
  40121e:	4b10      	ldr	r3, [pc, #64]	; (401260 <_usart_init+0x5c>)
  401220:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	((Usart *)hw)->US_MR = data;
  401224:	2300      	movs	r3, #0
  401226:	6063      	str	r3, [r4, #4]
	((Usart *)hw)->US_RTOR = data;
  401228:	6263      	str	r3, [r4, #36]	; 0x24
	((Usart *)hw)->US_TTGR = data;
  40122a:	62a3      	str	r3, [r4, #40]	; 0x28
}

static inline void hri_usart_write_US_CR_reg(const void *const hw, hri_usart_us_cr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_CR = data;
  40122c:	22ac      	movs	r2, #172	; 0xac
  40122e:	6022      	str	r2, [r4, #0]
  401230:	f44f 7280 	mov.w	r2, #256	; 0x100
  401234:	6022      	str	r2, [r4, #0]
  401236:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40123a:	6022      	str	r2, [r4, #0]
	/* Reset status bits. */
	hri_usart_write_US_CR_reg(hw, US_CR_RSTSTA);
	/* Turn off RTS and DTR if exist. */
	hri_usart_write_US_CR_reg(hw, US_CR_USART_RTSDIS);

	hri_usart_write_US_MR_reg(hw, _usarts[i].us_mr);
  40123c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  401240:	0081      	lsls	r1, r0, #2
  401242:	4a08      	ldr	r2, [pc, #32]	; (401264 <_usart_init+0x60>)
  401244:	440a      	add	r2, r1
  401246:	6852      	ldr	r2, [r2, #4]
	((Usart *)hw)->US_MR = data;
  401248:	6062      	str	r2, [r4, #4]
	((Usart *)hw)->US_BRGR = data;
  40124a:	4a07      	ldr	r2, [pc, #28]	; (401268 <_usart_init+0x64>)
  40124c:	6222      	str	r2, [r4, #32]
	hri_usart_write_US_BRGR_reg(hw, _usarts[i].us_brgr);

	return ERR_NONE;
}
  40124e:	4618      	mov	r0, r3
  401250:	bd10      	pop	{r4, pc}
  401252:	bf00      	nop
  401254:	004028c4 	.word	0x004028c4
  401258:	0040098d 	.word	0x0040098d
  40125c:	004011b1 	.word	0x004011b1
  401260:	55534100 	.word	0x55534100
  401264:	004028b8 	.word	0x004028b8
  401268:	000100f4 	.word	0x000100f4

0040126c <_usart_sync_init>:
{
  40126c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40126e:	460c      	mov	r4, r1
	ASSERT(device);
  401270:	4e09      	ldr	r6, [pc, #36]	; (401298 <_usart_sync_init+0x2c>)
  401272:	4607      	mov	r7, r0
  401274:	22bd      	movs	r2, #189	; 0xbd
  401276:	4631      	mov	r1, r6
  401278:	3000      	adds	r0, #0
  40127a:	bf18      	it	ne
  40127c:	2001      	movne	r0, #1
  40127e:	4d07      	ldr	r5, [pc, #28]	; (40129c <_usart_sync_init+0x30>)
  401280:	47a8      	blx	r5
	ASSERT(hw);
  401282:	22be      	movs	r2, #190	; 0xbe
  401284:	4631      	mov	r1, r6
  401286:	1c20      	adds	r0, r4, #0
  401288:	bf18      	it	ne
  40128a:	2001      	movne	r0, #1
  40128c:	47a8      	blx	r5
	device->hw = hw;
  40128e:	603c      	str	r4, [r7, #0]
	return _usart_init(hw);
  401290:	4620      	mov	r0, r4
  401292:	4b03      	ldr	r3, [pc, #12]	; (4012a0 <_usart_sync_init+0x34>)
  401294:	4798      	blx	r3
}
  401296:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401298:	004028c4 	.word	0x004028c4
  40129c:	0040098d 	.word	0x0040098d
  4012a0:	00401205 	.word	0x00401205

004012a4 <_usart_sync_enable>:
{
  4012a4:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
  4012a6:	4e0a      	ldr	r6, [pc, #40]	; (4012d0 <_usart_sync_enable+0x2c>)
  4012a8:	4604      	mov	r4, r0
  4012aa:	f240 1205 	movw	r2, #261	; 0x105
  4012ae:	4631      	mov	r1, r6
  4012b0:	3000      	adds	r0, #0
  4012b2:	bf18      	it	ne
  4012b4:	2001      	movne	r0, #1
  4012b6:	4d07      	ldr	r5, [pc, #28]	; (4012d4 <_usart_sync_enable+0x30>)
  4012b8:	47a8      	blx	r5
	_usart_enable(device->hw);
  4012ba:	6824      	ldr	r4, [r4, #0]
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline void _usart_enable(void *const hw)
{
	ASSERT(hw);
  4012bc:	f240 22c7 	movw	r2, #711	; 0x2c7
  4012c0:	4631      	mov	r1, r6
  4012c2:	1c20      	adds	r0, r4, #0
  4012c4:	bf18      	it	ne
  4012c6:	2001      	movne	r0, #1
  4012c8:	47a8      	blx	r5
	((Usart *)hw)->US_CR = data;
  4012ca:	2350      	movs	r3, #80	; 0x50
  4012cc:	6023      	str	r3, [r4, #0]
  4012ce:	bd70      	pop	{r4, r5, r6, pc}
  4012d0:	004028c4 	.word	0x004028c4
  4012d4:	0040098d 	.word	0x0040098d

004012d8 <_usart_sync_write_byte>:
{
  4012d8:	b538      	push	{r3, r4, r5, lr}
  4012da:	460c      	mov	r4, r1
	ASSERT(device);
  4012dc:	4605      	mov	r5, r0
  4012de:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
  4012e2:	4904      	ldr	r1, [pc, #16]	; (4012f4 <_usart_sync_write_byte+0x1c>)
  4012e4:	3000      	adds	r0, #0
  4012e6:	bf18      	it	ne
  4012e8:	2001      	movne	r0, #1
  4012ea:	4b03      	ldr	r3, [pc, #12]	; (4012f8 <_usart_sync_write_byte+0x20>)
  4012ec:	4798      	blx	r3
	hri_usart_write_US_THR_reg(device->hw, (hri_usart_us_thr_reg_t)data);
  4012ee:	682b      	ldr	r3, [r5, #0]
}

static inline void hri_usart_write_US_THR_reg(const void *const hw, hri_usart_us_thr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_THR = data;
  4012f0:	61dc      	str	r4, [r3, #28]
  4012f2:	bd38      	pop	{r3, r4, r5, pc}
  4012f4:	004028c4 	.word	0x004028c4
  4012f8:	0040098d 	.word	0x0040098d

004012fc <_usart_sync_read_byte>:
{
  4012fc:	b510      	push	{r4, lr}
	ASSERT(device);
  4012fe:	4604      	mov	r4, r0
  401300:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
  401304:	4904      	ldr	r1, [pc, #16]	; (401318 <_usart_sync_read_byte+0x1c>)
  401306:	3000      	adds	r0, #0
  401308:	bf18      	it	ne
  40130a:	2001      	movne	r0, #1
  40130c:	4b03      	ldr	r3, [pc, #12]	; (40131c <_usart_sync_read_byte+0x20>)
  40130e:	4798      	blx	r3
	return (uint8_t)(hri_usart_read_US_RHR_reg(device->hw) & 0xff);
  401310:	6823      	ldr	r3, [r4, #0]
	return ((Usart *)hw)->US_RHR;
  401312:	6998      	ldr	r0, [r3, #24]
}
  401314:	b2c0      	uxtb	r0, r0
  401316:	bd10      	pop	{r4, pc}
  401318:	004028c4 	.word	0x004028c4
  40131c:	0040098d 	.word	0x0040098d

00401320 <_usart_sync_is_ready_to_send>:
{
  401320:	b510      	push	{r4, lr}
	ASSERT(device);
  401322:	4604      	mov	r4, r0
  401324:	f240 12c3 	movw	r2, #451	; 0x1c3
  401328:	4905      	ldr	r1, [pc, #20]	; (401340 <_usart_sync_is_ready_to_send+0x20>)
  40132a:	3000      	adds	r0, #0
  40132c:	bf18      	it	ne
  40132e:	2001      	movne	r0, #1
  401330:	4b04      	ldr	r3, [pc, #16]	; (401344 <_usart_sync_is_ready_to_send+0x24>)
  401332:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXRDY_bit(device->hw);
  401334:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXRDY) > 0;
  401336:	6958      	ldr	r0, [r3, #20]
}
  401338:	f3c0 0040 	ubfx	r0, r0, #1, #1
  40133c:	bd10      	pop	{r4, pc}
  40133e:	bf00      	nop
  401340:	004028c4 	.word	0x004028c4
  401344:	0040098d 	.word	0x0040098d

00401348 <_usart_sync_is_transmit_done>:
{
  401348:	b510      	push	{r4, lr}
	ASSERT(device);
  40134a:	4604      	mov	r4, r0
  40134c:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
  401350:	4905      	ldr	r1, [pc, #20]	; (401368 <_usart_sync_is_transmit_done+0x20>)
  401352:	3000      	adds	r0, #0
  401354:	bf18      	it	ne
  401356:	2001      	movne	r0, #1
  401358:	4b04      	ldr	r3, [pc, #16]	; (40136c <_usart_sync_is_transmit_done+0x24>)
  40135a:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXEMPTY_bit(device->hw);
  40135c:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXEMPTY) > 0;
  40135e:	6958      	ldr	r0, [r3, #20]
}
  401360:	f3c0 2040 	ubfx	r0, r0, #9, #1
  401364:	bd10      	pop	{r4, pc}
  401366:	bf00      	nop
  401368:	004028c4 	.word	0x004028c4
  40136c:	0040098d 	.word	0x0040098d

00401370 <_usart_sync_is_byte_received>:
{
  401370:	b510      	push	{r4, lr}
	ASSERT(device);
  401372:	4604      	mov	r4, r0
  401374:	f44f 72ef 	mov.w	r2, #478	; 0x1de
  401378:	4905      	ldr	r1, [pc, #20]	; (401390 <_usart_sync_is_byte_received+0x20>)
  40137a:	3000      	adds	r0, #0
  40137c:	bf18      	it	ne
  40137e:	2001      	movne	r0, #1
  401380:	4b04      	ldr	r3, [pc, #16]	; (401394 <_usart_sync_is_byte_received+0x24>)
  401382:	4798      	blx	r3
	return hri_usart_get_US_CSR_RXRDY_bit(device->hw);
  401384:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_RXRDY) > 0;
  401386:	6958      	ldr	r0, [r3, #20]
  401388:	f000 0001 	and.w	r0, r0, #1
}
  40138c:	bd10      	pop	{r4, pc}
  40138e:	bf00      	nop
  401390:	004028c4 	.word	0x004028c4
  401394:	0040098d 	.word	0x0040098d

00401398 <_usart_get_usart_sync>:
}
  401398:	2000      	movs	r0, #0
  40139a:	4770      	bx	lr

0040139c <main>:
#include <stdlib.h>
#include "bno085_driver.h"
#include "nRF24_driver.h"

int main(void)
{
  40139c:	b500      	push	{lr}
  40139e:	b089      	sub	sp, #36	; 0x24
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  4013a0:	4b0f      	ldr	r3, [pc, #60]	; (4013e0 <main+0x44>)
  4013a2:	4798      	blx	r3
	
	/*Initialize the IMU, making sure to pass in the address of the start of the float array that will hold the quaternion coefficients*/
	
	//init_IMU(&imu_vector_buffer[0]);
	
	nRF24_init();
  4013a4:	4b0f      	ldr	r3, [pc, #60]	; (4013e4 <main+0x48>)
  4013a6:	4798      	blx	r3
	delay_us(200); //Should be 200 us, setting higher for testing
  4013a8:	20c8      	movs	r0, #200	; 0xc8
  4013aa:	4b0f      	ldr	r3, [pc, #60]	; (4013e8 <main+0x4c>)
  4013ac:	4798      	blx	r3
	nRF24_enter_receive();
  4013ae:	4b0f      	ldr	r3, [pc, #60]	; (4013ec <main+0x50>)
  4013b0:	4798      	blx	r3
	
	uint8_t data_store[32];
	memset(&data_store[0], 0, sizeof(uint8_t)*32);
  4013b2:	2220      	movs	r2, #32
  4013b4:	2100      	movs	r1, #0
  4013b6:	4668      	mov	r0, sp
  4013b8:	4b0d      	ldr	r3, [pc, #52]	; (4013f0 <main+0x54>)
  4013ba:	4798      	blx	r3
		should only fetch when needed, regardless of whether we have missed some or not), while being slow enough that we aren't asking the
		IMU for new quaternion coefficients before it is ready with the next set of them. (also really only relevant for the demo code, in
		reality it doesn't matter if we ask for coefficients before the IMU is ready with new ones, as the function will just return the last
		valid coefficients it collected in the event that the IMU isn't ready with new ones) */
		
		if(nRF_24_is_data_available(1)){ //There is data for me to collect :)
  4013bc:	2001      	movs	r0, #1
  4013be:	4b0d      	ldr	r3, [pc, #52]	; (4013f4 <main+0x58>)
  4013c0:	4798      	blx	r3
  4013c2:	2800      	cmp	r0, #0
  4013c4:	d0fa      	beq.n	4013bc <main+0x20>
			nRF24_receive_data(&data_store[0]);
  4013c6:	4668      	mov	r0, sp
  4013c8:	4b0b      	ldr	r3, [pc, #44]	; (4013f8 <main+0x5c>)
  4013ca:	4798      	blx	r3
			/*for(int i = 0; i < 32; i++){
				printf("0x%02x\r\n", data_store[i]);
			}*/
			printf("%s\r\n",data_store);
  4013cc:	4669      	mov	r1, sp
  4013ce:	480b      	ldr	r0, [pc, #44]	; (4013fc <main+0x60>)
  4013d0:	4b0b      	ldr	r3, [pc, #44]	; (401400 <main+0x64>)
  4013d2:	4798      	blx	r3
			memset(&data_store[0], 0, sizeof(uint8_t)*32);
  4013d4:	2220      	movs	r2, #32
  4013d6:	2100      	movs	r1, #0
  4013d8:	4668      	mov	r0, sp
  4013da:	4b05      	ldr	r3, [pc, #20]	; (4013f0 <main+0x54>)
  4013dc:	4798      	blx	r3
  4013de:	e7ed      	b.n	4013bc <main+0x20>
  4013e0:	004001d5 	.word	0x004001d5
  4013e4:	004014f5 	.word	0x004014f5
  4013e8:	00400535 	.word	0x00400535
  4013ec:	004015a5 	.word	0x004015a5
  4013f0:	0040178d 	.word	0x0040178d
  4013f4:	0040157d 	.word	0x0040157d
  4013f8:	004015fd 	.word	0x004015fd
  4013fc:	004028e0 	.word	0x004028e0
  401400:	004018f5 	.word	0x004018f5

00401404 <nRF24_write_to_register>:

#include "nRF24_driver.h"

struct io_descriptor *spi_0_io;

void nRF24_write_to_register(uint8_t registerd, uint8_t data){ //SPI Command "W_REGISTER"
  401404:	b530      	push	{r4, r5, lr}
  401406:	b083      	sub	sp, #12
	uint8_t buffer[2];
	memset(&buffer[0], 0, sizeof(uint8_t)*2);
	buffer[0] = buffer[0] | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer[0] = (buffer[0]) | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401408:	f040 0020 	orr.w	r0, r0, #32
  40140c:	f88d 0004 	strb.w	r0, [sp, #4]
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	buffer[1] = data;
  401410:	f88d 1005 	strb.w	r1, [sp, #5]
	((Pio *)hw)->PIO_CODR = mask;
  401414:	4c06      	ldr	r4, [pc, #24]	; (401430 <nRF24_write_to_register+0x2c>)
  401416:	f44f 7500 	mov.w	r5, #512	; 0x200
  40141a:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, buffer, 2); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  40141c:	2202      	movs	r2, #2
  40141e:	a901      	add	r1, sp, #4
  401420:	4b04      	ldr	r3, [pc, #16]	; (401434 <nRF24_write_to_register+0x30>)
  401422:	6818      	ldr	r0, [r3, #0]
  401424:	4b04      	ldr	r3, [pc, #16]	; (401438 <nRF24_write_to_register+0x34>)
  401426:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401428:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40142a:	b003      	add	sp, #12
  40142c:	bd30      	pop	{r4, r5, pc}
  40142e:	bf00      	nop
  401430:	400e1200 	.word	0x400e1200
  401434:	204000ec 	.word	0x204000ec
  401438:	0040066d 	.word	0x0040066d

0040143c <nRF24_write_to_register_multi_byte>:

void nRF24_write_to_register_multi_byte(uint8_t registerd, uint8_t *data, int length){ //SPI Command "W_REGISTER"
  40143c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  401440:	b083      	sub	sp, #12
  401442:	4688      	mov	r8, r1
  401444:	4691      	mov	r9, r2
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer = buffer | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401446:	f040 0020 	orr.w	r0, r0, #32
  40144a:	a902      	add	r1, sp, #8
  40144c:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401450:	4c08      	ldr	r4, [pc, #32]	; (401474 <nRF24_write_to_register_multi_byte+0x38>)
  401452:	f44f 7500 	mov.w	r5, #512	; 0x200
  401456:	6365      	str	r5, [r4, #52]	; 0x34
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1);
  401458:	4f07      	ldr	r7, [pc, #28]	; (401478 <nRF24_write_to_register_multi_byte+0x3c>)
  40145a:	2201      	movs	r2, #1
  40145c:	6838      	ldr	r0, [r7, #0]
  40145e:	4e07      	ldr	r6, [pc, #28]	; (40147c <nRF24_write_to_register_multi_byte+0x40>)
  401460:	47b0      	blx	r6
	io_write(spi_0_io, data, length); 
  401462:	fa1f f289 	uxth.w	r2, r9
  401466:	4641      	mov	r1, r8
  401468:	6838      	ldr	r0, [r7, #0]
  40146a:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  40146c:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40146e:	b003      	add	sp, #12
  401470:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401474:	400e1200 	.word	0x400e1200
  401478:	204000ec 	.word	0x204000ec
  40147c:	0040066d 	.word	0x0040066d

00401480 <nRF24_read_from_register>:

uint8_t nRF24_read_from_register(uint8_t registerd){ //SPI Command "R_REGISTER"
  401480:	b570      	push	{r4, r5, r6, lr}
  401482:	b082      	sub	sp, #8
	uint8_t in_byte;
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | registerd;
  401484:	a902      	add	r1, sp, #8
  401486:	f801 0d02 	strb.w	r0, [r1, #-2]!
	((Pio *)hw)->PIO_CODR = mask;
  40148a:	4c0a      	ldr	r4, [pc, #40]	; (4014b4 <nRF24_read_from_register+0x34>)
  40148c:	f44f 7500 	mov.w	r5, #512	; 0x200
  401490:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  401492:	4e09      	ldr	r6, [pc, #36]	; (4014b8 <nRF24_read_from_register+0x38>)
  401494:	2201      	movs	r2, #1
  401496:	6830      	ldr	r0, [r6, #0]
  401498:	4b08      	ldr	r3, [pc, #32]	; (4014bc <nRF24_read_from_register+0x3c>)
  40149a:	4798      	blx	r3
	io_read(spi_0_io, &in_byte, 1);
  40149c:	2201      	movs	r2, #1
  40149e:	f10d 0107 	add.w	r1, sp, #7
  4014a2:	6830      	ldr	r0, [r6, #0]
  4014a4:	4b06      	ldr	r3, [pc, #24]	; (4014c0 <nRF24_read_from_register+0x40>)
  4014a6:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  4014a8:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	return in_byte;
}
  4014aa:	f89d 0007 	ldrb.w	r0, [sp, #7]
  4014ae:	b002      	add	sp, #8
  4014b0:	bd70      	pop	{r4, r5, r6, pc}
  4014b2:	bf00      	nop
  4014b4:	400e1200 	.word	0x400e1200
  4014b8:	204000ec 	.word	0x204000ec
  4014bc:	0040066d 	.word	0x0040066d
  4014c0:	0040069d 	.word	0x0040069d

004014c4 <nRF24_send_SPI_command>:
	io_write(spi_0_io, &buffer, 1);
	io_read(spi_0_io, data_pointer, length);
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}

void nRF24_send_SPI_command(uint8_t command){
  4014c4:	b530      	push	{r4, r5, lr}
  4014c6:	b083      	sub	sp, #12
  4014c8:	a902      	add	r1, sp, #8
  4014ca:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  4014ce:	4c06      	ldr	r4, [pc, #24]	; (4014e8 <nRF24_send_SPI_command+0x24>)
  4014d0:	f44f 7500 	mov.w	r5, #512	; 0x200
  4014d4:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &command, 1);
  4014d6:	2201      	movs	r2, #1
  4014d8:	4b04      	ldr	r3, [pc, #16]	; (4014ec <nRF24_send_SPI_command+0x28>)
  4014da:	6818      	ldr	r0, [r3, #0]
  4014dc:	4b04      	ldr	r3, [pc, #16]	; (4014f0 <nRF24_send_SPI_command+0x2c>)
  4014de:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  4014e0:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  4014e2:	b003      	add	sp, #12
  4014e4:	bd30      	pop	{r4, r5, pc}
  4014e6:	bf00      	nop
  4014e8:	400e1200 	.word	0x400e1200
  4014ec:	204000ec 	.word	0x204000ec
  4014f0:	0040066d 	.word	0x0040066d

004014f4 <nRF24_init>:

void nRF24_init(){ //You are in standby-1 at the end of this call
  4014f4:	b510      	push	{r4, lr}
  4014f6:	b082      	sub	sp, #8
	spi_m_sync_get_io_descriptor(&SPI_0, &spi_0_io);
  4014f8:	4c18      	ldr	r4, [pc, #96]	; (40155c <nRF24_init+0x68>)
  4014fa:	4919      	ldr	r1, [pc, #100]	; (401560 <nRF24_init+0x6c>)
  4014fc:	4620      	mov	r0, r4
  4014fe:	4b19      	ldr	r3, [pc, #100]	; (401564 <nRF24_init+0x70>)
  401500:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
  401502:	4620      	mov	r0, r4
  401504:	4b18      	ldr	r3, [pc, #96]	; (401568 <nRF24_init+0x74>)
  401506:	4798      	blx	r3
	((Pio *)hw)->PIO_CODR = mask;
  401508:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  40150c:	4b17      	ldr	r3, [pc, #92]	; (40156c <nRF24_init+0x78>)
  40150e:	635a      	str	r2, [r3, #52]	; 0x34
	gpio_set_pin_level(RF24_CE, false); //Keeps us set to be ready to enter standby-1
	nRF24_write_to_register(CONFIG,0); //0000 0000 keep us in power down, disable checksums
  401510:	2100      	movs	r1, #0
  401512:	4608      	mov	r0, r1
  401514:	4c16      	ldr	r4, [pc, #88]	; (401570 <nRF24_init+0x7c>)
  401516:	47a0      	blx	r4
	nRF24_write_to_register(EN_AA,0); //0000 0000 no auto ACK
  401518:	2100      	movs	r1, #0
  40151a:	2001      	movs	r0, #1
  40151c:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR,0); //0000 0000 disable all RX pipes
  40151e:	2100      	movs	r1, #0
  401520:	2002      	movs	r0, #2
  401522:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_AW,3); //0000 0011 5 byte tx rx address fields
  401524:	2103      	movs	r1, #3
  401526:	4608      	mov	r0, r1
  401528:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_RETR,0); //0000 0000 no auto retransmission
  40152a:	2100      	movs	r1, #0
  40152c:	2004      	movs	r0, #4
  40152e:	47a0      	blx	r4
	nRF24_write_to_register(RF_CH,120); //0011 1111 first bit must be 0, 011 1111 = 63 freq = 2400 + 63 = 2463 = 2.463 GHz
  401530:	2178      	movs	r1, #120	; 0x78
  401532:	2005      	movs	r0, #5
  401534:	47a0      	blx	r4
	nRF24_write_to_register(RF_SETUP,6); //0000 0010 1 Mbps and -12 db //SET BACK TO 2
  401536:	2106      	movs	r1, #6
  401538:	4608      	mov	r0, r1
  40153a:	47a0      	blx	r4
	uint8_t tx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  40153c:	4b0d      	ldr	r3, [pc, #52]	; (401574 <nRF24_init+0x80>)
  40153e:	e893 0003 	ldmia.w	r3, {r0, r1}
  401542:	9000      	str	r0, [sp, #0]
  401544:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(TX_ADDR, &tx_address[0], 5); //Set TX addr as e7e7e7e7e7
  401548:	2205      	movs	r2, #5
  40154a:	4669      	mov	r1, sp
  40154c:	2010      	movs	r0, #16
  40154e:	4b0a      	ldr	r3, [pc, #40]	; (401578 <nRF24_init+0x84>)
  401550:	4798      	blx	r3
	nRF24_write_to_register(CONFIG,2); //0000 0020 enter standby-1, disable checksums
  401552:	2102      	movs	r1, #2
  401554:	2000      	movs	r0, #0
  401556:	47a0      	blx	r4
}
  401558:	b002      	add	sp, #8
  40155a:	bd10      	pop	{r4, pc}
  40155c:	204000b4 	.word	0x204000b4
  401560:	204000ec 	.word	0x204000ec
  401564:	0040081d 	.word	0x0040081d
  401568:	0040073d 	.word	0x0040073d
  40156c:	400e1400 	.word	0x400e1400
  401570:	00401405 	.word	0x00401405
  401574:	004028e8 	.word	0x004028e8
  401578:	0040143d 	.word	0x0040143d

0040157c <nRF_24_is_data_available>:
	gpio_set_pin_level(RF24_CE, true);
	delay_us(11); //This will put us into TX mode and empty the FIFO queue into the air
	gpio_set_pin_level(RF24_CE, false); //Return to standby-1 mode!
}

uint8_t nRF_24_is_data_available(int pipe_num){
  40157c:	b508      	push	{r3, lr}
	uint8_t status_reg;
	status_reg = nRF24_read_from_register(STATUS);
  40157e:	2007      	movs	r0, #7
  401580:	4b06      	ldr	r3, [pc, #24]	; (40159c <nRF_24_is_data_available+0x20>)
  401582:	4798      	blx	r3
	if((status_reg&(1<<6))&&(status_reg&(1<<1))){ //1<<6 is the data ready rx fifo interrupt and 1<<1 is the data from pipe 1 ready to read 
  401584:	f000 0042 	and.w	r0, r0, #66	; 0x42
  401588:	2842      	cmp	r0, #66	; 0x42
  40158a:	d001      	beq.n	401590 <nRF_24_is_data_available+0x14>
		nRF24_write_to_register(STATUS, (1<<6)); //clear data ready rx fifo
		return 1;
	}
	return 0;
  40158c:	2000      	movs	r0, #0
}
  40158e:	bd08      	pop	{r3, pc}
		nRF24_write_to_register(STATUS, (1<<6)); //clear data ready rx fifo
  401590:	2140      	movs	r1, #64	; 0x40
  401592:	2007      	movs	r0, #7
  401594:	4b02      	ldr	r3, [pc, #8]	; (4015a0 <nRF_24_is_data_available+0x24>)
  401596:	4798      	blx	r3
		return 1;
  401598:	2001      	movs	r0, #1
  40159a:	bd08      	pop	{r3, pc}
  40159c:	00401481 	.word	0x00401481
  4015a0:	00401405 	.word	0x00401405

004015a4 <nRF24_enter_receive>:

void nRF24_enter_receive(){ //You are in receive at the end of this call
  4015a4:	b510      	push	{r4, lr}
  4015a6:	b082      	sub	sp, #8
	uint8_t config_reg;
	config_reg = nRF24_read_from_register(CONFIG);
  4015a8:	2000      	movs	r0, #0
  4015aa:	4b0f      	ldr	r3, [pc, #60]	; (4015e8 <nRF24_enter_receive+0x44>)
  4015ac:	4798      	blx	r3
	config_reg = config_reg | 1; //XXXX XXX1 PRIM_RX to 1
  4015ae:	f040 0101 	orr.w	r1, r0, #1
	nRF24_write_to_register(CONFIG, config_reg);
  4015b2:	b2c9      	uxtb	r1, r1
  4015b4:	2000      	movs	r0, #0
  4015b6:	4c0d      	ldr	r4, [pc, #52]	; (4015ec <nRF24_enter_receive+0x48>)
  4015b8:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR, 2); //0000 0010 set data pipe 1 to on
  4015ba:	2102      	movs	r1, #2
  4015bc:	4608      	mov	r0, r1
  4015be:	47a0      	blx	r4
	uint8_t rx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  4015c0:	4b0b      	ldr	r3, [pc, #44]	; (4015f0 <nRF24_enter_receive+0x4c>)
  4015c2:	e893 0003 	ldmia.w	r3, {r0, r1}
  4015c6:	9000      	str	r0, [sp, #0]
  4015c8:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
  4015cc:	2205      	movs	r2, #5
  4015ce:	4669      	mov	r1, sp
  4015d0:	200b      	movs	r0, #11
  4015d2:	4b08      	ldr	r3, [pc, #32]	; (4015f4 <nRF24_enter_receive+0x50>)
  4015d4:	4798      	blx	r3
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
  4015d6:	2120      	movs	r1, #32
  4015d8:	2012      	movs	r0, #18
  4015da:	47a0      	blx	r4
	((Pio *)hw)->PIO_SODR = mask;
  4015dc:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4015e0:	4b05      	ldr	r3, [pc, #20]	; (4015f8 <nRF24_enter_receive+0x54>)
  4015e2:	631a      	str	r2, [r3, #48]	; 0x30
	gpio_set_pin_level(RF24_CE, true);
}
  4015e4:	b002      	add	sp, #8
  4015e6:	bd10      	pop	{r4, pc}
  4015e8:	00401481 	.word	0x00401481
  4015ec:	00401405 	.word	0x00401405
  4015f0:	004028e8 	.word	0x004028e8
  4015f4:	0040143d 	.word	0x0040143d
  4015f8:	400e1400 	.word	0x400e1400

004015fc <nRF24_receive_data>:

void nRF24_receive_data(uint8_t *data_pointer){
  4015fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  4015fe:	b083      	sub	sp, #12
  401600:	4607      	mov	r7, r0
	uint8_t cmd = R_RX_PAYLOAD;
  401602:	a902      	add	r1, sp, #8
  401604:	2361      	movs	r3, #97	; 0x61
  401606:	f801 3d01 	strb.w	r3, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  40160a:	4c0c      	ldr	r4, [pc, #48]	; (40163c <nRF24_receive_data+0x40>)
  40160c:	f44f 7500 	mov.w	r5, #512	; 0x200
  401610:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &cmd, 1);
  401612:	4e0b      	ldr	r6, [pc, #44]	; (401640 <nRF24_receive_data+0x44>)
  401614:	2201      	movs	r2, #1
  401616:	6830      	ldr	r0, [r6, #0]
  401618:	4b0a      	ldr	r3, [pc, #40]	; (401644 <nRF24_receive_data+0x48>)
  40161a:	4798      	blx	r3
	io_read(spi_0_io, data_pointer, 32);
  40161c:	2220      	movs	r2, #32
  40161e:	4639      	mov	r1, r7
  401620:	6830      	ldr	r0, [r6, #0]
  401622:	4b09      	ldr	r3, [pc, #36]	; (401648 <nRF24_receive_data+0x4c>)
  401624:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401626:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	delay_us(11); //Make sure we had enough time to grab the data before flushing
  401628:	200b      	movs	r0, #11
  40162a:	4b08      	ldr	r3, [pc, #32]	; (40164c <nRF24_receive_data+0x50>)
  40162c:	4798      	blx	r3
	cmd = FLUSH_RX;
  40162e:	20e2      	movs	r0, #226	; 0xe2
  401630:	f88d 0007 	strb.w	r0, [sp, #7]
	nRF24_send_SPI_command(cmd);
  401634:	4b06      	ldr	r3, [pc, #24]	; (401650 <nRF24_receive_data+0x54>)
  401636:	4798      	blx	r3
}
  401638:	b003      	add	sp, #12
  40163a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  40163c:	400e1200 	.word	0x400e1200
  401640:	204000ec 	.word	0x204000ec
  401644:	0040066d 	.word	0x0040066d
  401648:	0040069d 	.word	0x0040069d
  40164c:	00400535 	.word	0x00400535
  401650:	004014c5 	.word	0x004014c5

00401654 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
  401654:	b958      	cbnz	r0, 40166e <_read+0x1a>
{
  401656:	b508      	push	{r3, lr}
  401658:	460b      	mov	r3, r1
  40165a:	4611      	mov	r1, r2
  40165c:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
  40165e:	4b05      	ldr	r3, [pc, #20]	; (401674 <_read+0x20>)
  401660:	4798      	blx	r3
	if (n < 0) {
  401662:	2800      	cmp	r0, #0
  401664:	db00      	blt.n	401668 <_read+0x14>
		return -1;
	}

	return n;
}
  401666:	bd08      	pop	{r3, pc}
		return -1;
  401668:	f04f 30ff 	mov.w	r0, #4294967295
  40166c:	bd08      	pop	{r3, pc}
		return -1;
  40166e:	f04f 30ff 	mov.w	r0, #4294967295
  401672:	4770      	bx	lr
  401674:	004016cd 	.word	0x004016cd

00401678 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
  401678:	3801      	subs	r0, #1
  40167a:	2802      	cmp	r0, #2
  40167c:	d80b      	bhi.n	401696 <_write+0x1e>
{
  40167e:	b508      	push	{r3, lr}
  401680:	460b      	mov	r3, r1
  401682:	4611      	mov	r1, r2
  401684:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
  401686:	4b05      	ldr	r3, [pc, #20]	; (40169c <_write+0x24>)
  401688:	4798      	blx	r3
	if (n < 0) {
  40168a:	2800      	cmp	r0, #0
  40168c:	db00      	blt.n	401690 <_write+0x18>
		return -1;
	}

	return n;
}
  40168e:	bd08      	pop	{r3, pc}
		return -1;
  401690:	f04f 30ff 	mov.w	r0, #4294967295
  401694:	bd08      	pop	{r3, pc}
		return -1;
  401696:	f04f 30ff 	mov.w	r0, #4294967295
  40169a:	4770      	bx	lr
  40169c:	004016f1 	.word	0x004016f1

004016a0 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
  4016a0:	b570      	push	{r4, r5, r6, lr}
  4016a2:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
  4016a4:	4d06      	ldr	r5, [pc, #24]	; (4016c0 <stdio_io_init+0x20>)
  4016a6:	682b      	ldr	r3, [r5, #0]
  4016a8:	2100      	movs	r1, #0
  4016aa:	6898      	ldr	r0, [r3, #8]
  4016ac:	4c05      	ldr	r4, [pc, #20]	; (4016c4 <stdio_io_init+0x24>)
  4016ae:	47a0      	blx	r4
	setbuf(stdin, NULL);
  4016b0:	682b      	ldr	r3, [r5, #0]
  4016b2:	2100      	movs	r1, #0
  4016b4:	6858      	ldr	r0, [r3, #4]
  4016b6:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
  4016b8:	4b03      	ldr	r3, [pc, #12]	; (4016c8 <stdio_io_init+0x28>)
  4016ba:	601e      	str	r6, [r3, #0]
  4016bc:	bd70      	pop	{r4, r5, r6, pc}
  4016be:	bf00      	nop
  4016c0:	20400000 	.word	0x20400000
  4016c4:	00401945 	.word	0x00401945
  4016c8:	2040009c 	.word	0x2040009c

004016cc <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
  4016cc:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  4016ce:	4b06      	ldr	r3, [pc, #24]	; (4016e8 <stdio_io_read+0x1c>)
  4016d0:	681b      	ldr	r3, [r3, #0]
  4016d2:	b133      	cbz	r3, 4016e2 <stdio_io_read+0x16>
  4016d4:	460a      	mov	r2, r1
  4016d6:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
  4016d8:	b292      	uxth	r2, r2
  4016da:	4618      	mov	r0, r3
  4016dc:	4b03      	ldr	r3, [pc, #12]	; (4016ec <stdio_io_read+0x20>)
  4016de:	4798      	blx	r3
  4016e0:	bd08      	pop	{r3, pc}
		return 0;
  4016e2:	2000      	movs	r0, #0
}
  4016e4:	bd08      	pop	{r3, pc}
  4016e6:	bf00      	nop
  4016e8:	2040009c 	.word	0x2040009c
  4016ec:	0040069d 	.word	0x0040069d

004016f0 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
  4016f0:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  4016f2:	4b06      	ldr	r3, [pc, #24]	; (40170c <stdio_io_write+0x1c>)
  4016f4:	681b      	ldr	r3, [r3, #0]
  4016f6:	b133      	cbz	r3, 401706 <stdio_io_write+0x16>
  4016f8:	460a      	mov	r2, r1
  4016fa:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
  4016fc:	b292      	uxth	r2, r2
  4016fe:	4618      	mov	r0, r3
  401700:	4b03      	ldr	r3, [pc, #12]	; (401710 <stdio_io_write+0x20>)
  401702:	4798      	blx	r3
  401704:	bd08      	pop	{r3, pc}
		return 0;
  401706:	2000      	movs	r0, #0
}
  401708:	bd08      	pop	{r3, pc}
  40170a:	bf00      	nop
  40170c:	2040009c 	.word	0x2040009c
  401710:	0040066d 	.word	0x0040066d

00401714 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
  401714:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
  401716:	4c04      	ldr	r4, [pc, #16]	; (401728 <stdio_redirect_init+0x14>)
  401718:	4620      	mov	r0, r4
  40171a:	4b04      	ldr	r3, [pc, #16]	; (40172c <stdio_redirect_init+0x18>)
  40171c:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
  40171e:	4620      	mov	r0, r4
  401720:	4b03      	ldr	r3, [pc, #12]	; (401730 <stdio_redirect_init+0x1c>)
  401722:	4798      	blx	r3
  401724:	bd10      	pop	{r4, pc}
  401726:	bf00      	nop
  401728:	204000a8 	.word	0x204000a8
  40172c:	00400961 	.word	0x00400961
  401730:	004016a1 	.word	0x004016a1

00401734 <__libc_init_array>:
  401734:	b570      	push	{r4, r5, r6, lr}
  401736:	4e0d      	ldr	r6, [pc, #52]	; (40176c <__libc_init_array+0x38>)
  401738:	4c0d      	ldr	r4, [pc, #52]	; (401770 <__libc_init_array+0x3c>)
  40173a:	1ba4      	subs	r4, r4, r6
  40173c:	10a4      	asrs	r4, r4, #2
  40173e:	2500      	movs	r5, #0
  401740:	42a5      	cmp	r5, r4
  401742:	d109      	bne.n	401758 <__libc_init_array+0x24>
  401744:	4e0b      	ldr	r6, [pc, #44]	; (401774 <__libc_init_array+0x40>)
  401746:	4c0c      	ldr	r4, [pc, #48]	; (401778 <__libc_init_array+0x44>)
  401748:	f001 f91e 	bl	402988 <_init>
  40174c:	1ba4      	subs	r4, r4, r6
  40174e:	10a4      	asrs	r4, r4, #2
  401750:	2500      	movs	r5, #0
  401752:	42a5      	cmp	r5, r4
  401754:	d105      	bne.n	401762 <__libc_init_array+0x2e>
  401756:	bd70      	pop	{r4, r5, r6, pc}
  401758:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  40175c:	4798      	blx	r3
  40175e:	3501      	adds	r5, #1
  401760:	e7ee      	b.n	401740 <__libc_init_array+0xc>
  401762:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401766:	4798      	blx	r3
  401768:	3501      	adds	r5, #1
  40176a:	e7f2      	b.n	401752 <__libc_init_array+0x1e>
  40176c:	00402994 	.word	0x00402994
  401770:	00402994 	.word	0x00402994
  401774:	00402994 	.word	0x00402994
  401778:	00402998 	.word	0x00402998

0040177c <malloc>:
  40177c:	4b02      	ldr	r3, [pc, #8]	; (401788 <malloc+0xc>)
  40177e:	4601      	mov	r1, r0
  401780:	6818      	ldr	r0, [r3, #0]
  401782:	f000 b859 	b.w	401838 <_malloc_r>
  401786:	bf00      	nop
  401788:	20400000 	.word	0x20400000

0040178c <memset>:
  40178c:	4402      	add	r2, r0
  40178e:	4603      	mov	r3, r0
  401790:	4293      	cmp	r3, r2
  401792:	d100      	bne.n	401796 <memset+0xa>
  401794:	4770      	bx	lr
  401796:	f803 1b01 	strb.w	r1, [r3], #1
  40179a:	e7f9      	b.n	401790 <memset+0x4>

0040179c <_free_r>:
  40179c:	b538      	push	{r3, r4, r5, lr}
  40179e:	4605      	mov	r5, r0
  4017a0:	2900      	cmp	r1, #0
  4017a2:	d045      	beq.n	401830 <_free_r+0x94>
  4017a4:	f851 3c04 	ldr.w	r3, [r1, #-4]
  4017a8:	1f0c      	subs	r4, r1, #4
  4017aa:	2b00      	cmp	r3, #0
  4017ac:	bfb8      	it	lt
  4017ae:	18e4      	addlt	r4, r4, r3
  4017b0:	f000 fc1e 	bl	401ff0 <__malloc_lock>
  4017b4:	4a1f      	ldr	r2, [pc, #124]	; (401834 <_free_r+0x98>)
  4017b6:	6813      	ldr	r3, [r2, #0]
  4017b8:	4610      	mov	r0, r2
  4017ba:	b933      	cbnz	r3, 4017ca <_free_r+0x2e>
  4017bc:	6063      	str	r3, [r4, #4]
  4017be:	6014      	str	r4, [r2, #0]
  4017c0:	4628      	mov	r0, r5
  4017c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  4017c6:	f000 bc14 	b.w	401ff2 <__malloc_unlock>
  4017ca:	42a3      	cmp	r3, r4
  4017cc:	d90c      	bls.n	4017e8 <_free_r+0x4c>
  4017ce:	6821      	ldr	r1, [r4, #0]
  4017d0:	1862      	adds	r2, r4, r1
  4017d2:	4293      	cmp	r3, r2
  4017d4:	bf04      	itt	eq
  4017d6:	681a      	ldreq	r2, [r3, #0]
  4017d8:	685b      	ldreq	r3, [r3, #4]
  4017da:	6063      	str	r3, [r4, #4]
  4017dc:	bf04      	itt	eq
  4017de:	1852      	addeq	r2, r2, r1
  4017e0:	6022      	streq	r2, [r4, #0]
  4017e2:	6004      	str	r4, [r0, #0]
  4017e4:	e7ec      	b.n	4017c0 <_free_r+0x24>
  4017e6:	4613      	mov	r3, r2
  4017e8:	685a      	ldr	r2, [r3, #4]
  4017ea:	b10a      	cbz	r2, 4017f0 <_free_r+0x54>
  4017ec:	42a2      	cmp	r2, r4
  4017ee:	d9fa      	bls.n	4017e6 <_free_r+0x4a>
  4017f0:	6819      	ldr	r1, [r3, #0]
  4017f2:	1858      	adds	r0, r3, r1
  4017f4:	42a0      	cmp	r0, r4
  4017f6:	d10b      	bne.n	401810 <_free_r+0x74>
  4017f8:	6820      	ldr	r0, [r4, #0]
  4017fa:	4401      	add	r1, r0
  4017fc:	1858      	adds	r0, r3, r1
  4017fe:	4282      	cmp	r2, r0
  401800:	6019      	str	r1, [r3, #0]
  401802:	d1dd      	bne.n	4017c0 <_free_r+0x24>
  401804:	6810      	ldr	r0, [r2, #0]
  401806:	6852      	ldr	r2, [r2, #4]
  401808:	605a      	str	r2, [r3, #4]
  40180a:	4401      	add	r1, r0
  40180c:	6019      	str	r1, [r3, #0]
  40180e:	e7d7      	b.n	4017c0 <_free_r+0x24>
  401810:	d902      	bls.n	401818 <_free_r+0x7c>
  401812:	230c      	movs	r3, #12
  401814:	602b      	str	r3, [r5, #0]
  401816:	e7d3      	b.n	4017c0 <_free_r+0x24>
  401818:	6820      	ldr	r0, [r4, #0]
  40181a:	1821      	adds	r1, r4, r0
  40181c:	428a      	cmp	r2, r1
  40181e:	bf04      	itt	eq
  401820:	6811      	ldreq	r1, [r2, #0]
  401822:	6852      	ldreq	r2, [r2, #4]
  401824:	6062      	str	r2, [r4, #4]
  401826:	bf04      	itt	eq
  401828:	1809      	addeq	r1, r1, r0
  40182a:	6021      	streq	r1, [r4, #0]
  40182c:	605c      	str	r4, [r3, #4]
  40182e:	e7c7      	b.n	4017c0 <_free_r+0x24>
  401830:	bd38      	pop	{r3, r4, r5, pc}
  401832:	bf00      	nop
  401834:	204000a0 	.word	0x204000a0

00401838 <_malloc_r>:
  401838:	b570      	push	{r4, r5, r6, lr}
  40183a:	1ccd      	adds	r5, r1, #3
  40183c:	f025 0503 	bic.w	r5, r5, #3
  401840:	3508      	adds	r5, #8
  401842:	2d0c      	cmp	r5, #12
  401844:	bf38      	it	cc
  401846:	250c      	movcc	r5, #12
  401848:	2d00      	cmp	r5, #0
  40184a:	4606      	mov	r6, r0
  40184c:	db01      	blt.n	401852 <_malloc_r+0x1a>
  40184e:	42a9      	cmp	r1, r5
  401850:	d903      	bls.n	40185a <_malloc_r+0x22>
  401852:	230c      	movs	r3, #12
  401854:	6033      	str	r3, [r6, #0]
  401856:	2000      	movs	r0, #0
  401858:	bd70      	pop	{r4, r5, r6, pc}
  40185a:	f000 fbc9 	bl	401ff0 <__malloc_lock>
  40185e:	4a23      	ldr	r2, [pc, #140]	; (4018ec <_malloc_r+0xb4>)
  401860:	6814      	ldr	r4, [r2, #0]
  401862:	4621      	mov	r1, r4
  401864:	b991      	cbnz	r1, 40188c <_malloc_r+0x54>
  401866:	4c22      	ldr	r4, [pc, #136]	; (4018f0 <_malloc_r+0xb8>)
  401868:	6823      	ldr	r3, [r4, #0]
  40186a:	b91b      	cbnz	r3, 401874 <_malloc_r+0x3c>
  40186c:	4630      	mov	r0, r6
  40186e:	f000 f859 	bl	401924 <_sbrk_r>
  401872:	6020      	str	r0, [r4, #0]
  401874:	4629      	mov	r1, r5
  401876:	4630      	mov	r0, r6
  401878:	f000 f854 	bl	401924 <_sbrk_r>
  40187c:	1c43      	adds	r3, r0, #1
  40187e:	d126      	bne.n	4018ce <_malloc_r+0x96>
  401880:	230c      	movs	r3, #12
  401882:	6033      	str	r3, [r6, #0]
  401884:	4630      	mov	r0, r6
  401886:	f000 fbb4 	bl	401ff2 <__malloc_unlock>
  40188a:	e7e4      	b.n	401856 <_malloc_r+0x1e>
  40188c:	680b      	ldr	r3, [r1, #0]
  40188e:	1b5b      	subs	r3, r3, r5
  401890:	d41a      	bmi.n	4018c8 <_malloc_r+0x90>
  401892:	2b0b      	cmp	r3, #11
  401894:	d90f      	bls.n	4018b6 <_malloc_r+0x7e>
  401896:	600b      	str	r3, [r1, #0]
  401898:	50cd      	str	r5, [r1, r3]
  40189a:	18cc      	adds	r4, r1, r3
  40189c:	4630      	mov	r0, r6
  40189e:	f000 fba8 	bl	401ff2 <__malloc_unlock>
  4018a2:	f104 000b 	add.w	r0, r4, #11
  4018a6:	1d23      	adds	r3, r4, #4
  4018a8:	f020 0007 	bic.w	r0, r0, #7
  4018ac:	1ac3      	subs	r3, r0, r3
  4018ae:	d01b      	beq.n	4018e8 <_malloc_r+0xb0>
  4018b0:	425a      	negs	r2, r3
  4018b2:	50e2      	str	r2, [r4, r3]
  4018b4:	bd70      	pop	{r4, r5, r6, pc}
  4018b6:	428c      	cmp	r4, r1
  4018b8:	bf0d      	iteet	eq
  4018ba:	6863      	ldreq	r3, [r4, #4]
  4018bc:	684b      	ldrne	r3, [r1, #4]
  4018be:	6063      	strne	r3, [r4, #4]
  4018c0:	6013      	streq	r3, [r2, #0]
  4018c2:	bf18      	it	ne
  4018c4:	460c      	movne	r4, r1
  4018c6:	e7e9      	b.n	40189c <_malloc_r+0x64>
  4018c8:	460c      	mov	r4, r1
  4018ca:	6849      	ldr	r1, [r1, #4]
  4018cc:	e7ca      	b.n	401864 <_malloc_r+0x2c>
  4018ce:	1cc4      	adds	r4, r0, #3
  4018d0:	f024 0403 	bic.w	r4, r4, #3
  4018d4:	42a0      	cmp	r0, r4
  4018d6:	d005      	beq.n	4018e4 <_malloc_r+0xac>
  4018d8:	1a21      	subs	r1, r4, r0
  4018da:	4630      	mov	r0, r6
  4018dc:	f000 f822 	bl	401924 <_sbrk_r>
  4018e0:	3001      	adds	r0, #1
  4018e2:	d0cd      	beq.n	401880 <_malloc_r+0x48>
  4018e4:	6025      	str	r5, [r4, #0]
  4018e6:	e7d9      	b.n	40189c <_malloc_r+0x64>
  4018e8:	bd70      	pop	{r4, r5, r6, pc}
  4018ea:	bf00      	nop
  4018ec:	204000a0 	.word	0x204000a0
  4018f0:	204000a4 	.word	0x204000a4

004018f4 <iprintf>:
  4018f4:	b40f      	push	{r0, r1, r2, r3}
  4018f6:	4b0a      	ldr	r3, [pc, #40]	; (401920 <iprintf+0x2c>)
  4018f8:	b513      	push	{r0, r1, r4, lr}
  4018fa:	681c      	ldr	r4, [r3, #0]
  4018fc:	b124      	cbz	r4, 401908 <iprintf+0x14>
  4018fe:	69a3      	ldr	r3, [r4, #24]
  401900:	b913      	cbnz	r3, 401908 <iprintf+0x14>
  401902:	4620      	mov	r0, r4
  401904:	f000 fa86 	bl	401e14 <__sinit>
  401908:	ab05      	add	r3, sp, #20
  40190a:	9a04      	ldr	r2, [sp, #16]
  40190c:	68a1      	ldr	r1, [r4, #8]
  40190e:	9301      	str	r3, [sp, #4]
  401910:	4620      	mov	r0, r4
  401912:	f000 fb97 	bl	402044 <_vfiprintf_r>
  401916:	b002      	add	sp, #8
  401918:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  40191c:	b004      	add	sp, #16
  40191e:	4770      	bx	lr
  401920:	20400000 	.word	0x20400000

00401924 <_sbrk_r>:
  401924:	b538      	push	{r3, r4, r5, lr}
  401926:	4c06      	ldr	r4, [pc, #24]	; (401940 <_sbrk_r+0x1c>)
  401928:	2300      	movs	r3, #0
  40192a:	4605      	mov	r5, r0
  40192c:	4608      	mov	r0, r1
  40192e:	6023      	str	r3, [r4, #0]
  401930:	f7ff f830 	bl	400994 <_sbrk>
  401934:	1c43      	adds	r3, r0, #1
  401936:	d102      	bne.n	40193e <_sbrk_r+0x1a>
  401938:	6823      	ldr	r3, [r4, #0]
  40193a:	b103      	cbz	r3, 40193e <_sbrk_r+0x1a>
  40193c:	602b      	str	r3, [r5, #0]
  40193e:	bd38      	pop	{r3, r4, r5, pc}
  401940:	204000f0 	.word	0x204000f0

00401944 <setbuf>:
  401944:	2900      	cmp	r1, #0
  401946:	f44f 6380 	mov.w	r3, #1024	; 0x400
  40194a:	bf0c      	ite	eq
  40194c:	2202      	moveq	r2, #2
  40194e:	2200      	movne	r2, #0
  401950:	f000 b800 	b.w	401954 <setvbuf>

00401954 <setvbuf>:
  401954:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  401958:	461d      	mov	r5, r3
  40195a:	4b51      	ldr	r3, [pc, #324]	; (401aa0 <setvbuf+0x14c>)
  40195c:	681e      	ldr	r6, [r3, #0]
  40195e:	4604      	mov	r4, r0
  401960:	460f      	mov	r7, r1
  401962:	4690      	mov	r8, r2
  401964:	b126      	cbz	r6, 401970 <setvbuf+0x1c>
  401966:	69b3      	ldr	r3, [r6, #24]
  401968:	b913      	cbnz	r3, 401970 <setvbuf+0x1c>
  40196a:	4630      	mov	r0, r6
  40196c:	f000 fa52 	bl	401e14 <__sinit>
  401970:	4b4c      	ldr	r3, [pc, #304]	; (401aa4 <setvbuf+0x150>)
  401972:	429c      	cmp	r4, r3
  401974:	d152      	bne.n	401a1c <setvbuf+0xc8>
  401976:	6874      	ldr	r4, [r6, #4]
  401978:	f1b8 0f02 	cmp.w	r8, #2
  40197c:	d006      	beq.n	40198c <setvbuf+0x38>
  40197e:	f1b8 0f01 	cmp.w	r8, #1
  401982:	f200 8089 	bhi.w	401a98 <setvbuf+0x144>
  401986:	2d00      	cmp	r5, #0
  401988:	f2c0 8086 	blt.w	401a98 <setvbuf+0x144>
  40198c:	4621      	mov	r1, r4
  40198e:	4630      	mov	r0, r6
  401990:	f000 f9d6 	bl	401d40 <_fflush_r>
  401994:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401996:	b141      	cbz	r1, 4019aa <setvbuf+0x56>
  401998:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40199c:	4299      	cmp	r1, r3
  40199e:	d002      	beq.n	4019a6 <setvbuf+0x52>
  4019a0:	4630      	mov	r0, r6
  4019a2:	f7ff fefb 	bl	40179c <_free_r>
  4019a6:	2300      	movs	r3, #0
  4019a8:	6363      	str	r3, [r4, #52]	; 0x34
  4019aa:	2300      	movs	r3, #0
  4019ac:	61a3      	str	r3, [r4, #24]
  4019ae:	6063      	str	r3, [r4, #4]
  4019b0:	89a3      	ldrh	r3, [r4, #12]
  4019b2:	061b      	lsls	r3, r3, #24
  4019b4:	d503      	bpl.n	4019be <setvbuf+0x6a>
  4019b6:	6921      	ldr	r1, [r4, #16]
  4019b8:	4630      	mov	r0, r6
  4019ba:	f7ff feef 	bl	40179c <_free_r>
  4019be:	89a3      	ldrh	r3, [r4, #12]
  4019c0:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  4019c4:	f023 0303 	bic.w	r3, r3, #3
  4019c8:	f1b8 0f02 	cmp.w	r8, #2
  4019cc:	81a3      	strh	r3, [r4, #12]
  4019ce:	d05d      	beq.n	401a8c <setvbuf+0x138>
  4019d0:	ab01      	add	r3, sp, #4
  4019d2:	466a      	mov	r2, sp
  4019d4:	4621      	mov	r1, r4
  4019d6:	4630      	mov	r0, r6
  4019d8:	f000 faa6 	bl	401f28 <__swhatbuf_r>
  4019dc:	89a3      	ldrh	r3, [r4, #12]
  4019de:	4318      	orrs	r0, r3
  4019e0:	81a0      	strh	r0, [r4, #12]
  4019e2:	bb2d      	cbnz	r5, 401a30 <setvbuf+0xdc>
  4019e4:	9d00      	ldr	r5, [sp, #0]
  4019e6:	4628      	mov	r0, r5
  4019e8:	f7ff fec8 	bl	40177c <malloc>
  4019ec:	4607      	mov	r7, r0
  4019ee:	2800      	cmp	r0, #0
  4019f0:	d14e      	bne.n	401a90 <setvbuf+0x13c>
  4019f2:	f8dd 9000 	ldr.w	r9, [sp]
  4019f6:	45a9      	cmp	r9, r5
  4019f8:	d13c      	bne.n	401a74 <setvbuf+0x120>
  4019fa:	f04f 30ff 	mov.w	r0, #4294967295
  4019fe:	89a3      	ldrh	r3, [r4, #12]
  401a00:	f043 0302 	orr.w	r3, r3, #2
  401a04:	81a3      	strh	r3, [r4, #12]
  401a06:	2300      	movs	r3, #0
  401a08:	60a3      	str	r3, [r4, #8]
  401a0a:	f104 0347 	add.w	r3, r4, #71	; 0x47
  401a0e:	6023      	str	r3, [r4, #0]
  401a10:	6123      	str	r3, [r4, #16]
  401a12:	2301      	movs	r3, #1
  401a14:	6163      	str	r3, [r4, #20]
  401a16:	b003      	add	sp, #12
  401a18:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401a1c:	4b22      	ldr	r3, [pc, #136]	; (401aa8 <setvbuf+0x154>)
  401a1e:	429c      	cmp	r4, r3
  401a20:	d101      	bne.n	401a26 <setvbuf+0xd2>
  401a22:	68b4      	ldr	r4, [r6, #8]
  401a24:	e7a8      	b.n	401978 <setvbuf+0x24>
  401a26:	4b21      	ldr	r3, [pc, #132]	; (401aac <setvbuf+0x158>)
  401a28:	429c      	cmp	r4, r3
  401a2a:	bf08      	it	eq
  401a2c:	68f4      	ldreq	r4, [r6, #12]
  401a2e:	e7a3      	b.n	401978 <setvbuf+0x24>
  401a30:	2f00      	cmp	r7, #0
  401a32:	d0d8      	beq.n	4019e6 <setvbuf+0x92>
  401a34:	69b3      	ldr	r3, [r6, #24]
  401a36:	b913      	cbnz	r3, 401a3e <setvbuf+0xea>
  401a38:	4630      	mov	r0, r6
  401a3a:	f000 f9eb 	bl	401e14 <__sinit>
  401a3e:	f1b8 0f01 	cmp.w	r8, #1
  401a42:	bf08      	it	eq
  401a44:	89a3      	ldrheq	r3, [r4, #12]
  401a46:	6027      	str	r7, [r4, #0]
  401a48:	bf04      	itt	eq
  401a4a:	f043 0301 	orreq.w	r3, r3, #1
  401a4e:	81a3      	strheq	r3, [r4, #12]
  401a50:	89a3      	ldrh	r3, [r4, #12]
  401a52:	6127      	str	r7, [r4, #16]
  401a54:	f013 0008 	ands.w	r0, r3, #8
  401a58:	6165      	str	r5, [r4, #20]
  401a5a:	d01b      	beq.n	401a94 <setvbuf+0x140>
  401a5c:	f013 0001 	ands.w	r0, r3, #1
  401a60:	bf18      	it	ne
  401a62:	426d      	negne	r5, r5
  401a64:	f04f 0300 	mov.w	r3, #0
  401a68:	bf1d      	ittte	ne
  401a6a:	60a3      	strne	r3, [r4, #8]
  401a6c:	61a5      	strne	r5, [r4, #24]
  401a6e:	4618      	movne	r0, r3
  401a70:	60a5      	streq	r5, [r4, #8]
  401a72:	e7d0      	b.n	401a16 <setvbuf+0xc2>
  401a74:	4648      	mov	r0, r9
  401a76:	f7ff fe81 	bl	40177c <malloc>
  401a7a:	4607      	mov	r7, r0
  401a7c:	2800      	cmp	r0, #0
  401a7e:	d0bc      	beq.n	4019fa <setvbuf+0xa6>
  401a80:	89a3      	ldrh	r3, [r4, #12]
  401a82:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  401a86:	81a3      	strh	r3, [r4, #12]
  401a88:	464d      	mov	r5, r9
  401a8a:	e7d3      	b.n	401a34 <setvbuf+0xe0>
  401a8c:	2000      	movs	r0, #0
  401a8e:	e7b6      	b.n	4019fe <setvbuf+0xaa>
  401a90:	46a9      	mov	r9, r5
  401a92:	e7f5      	b.n	401a80 <setvbuf+0x12c>
  401a94:	60a0      	str	r0, [r4, #8]
  401a96:	e7be      	b.n	401a16 <setvbuf+0xc2>
  401a98:	f04f 30ff 	mov.w	r0, #4294967295
  401a9c:	e7bb      	b.n	401a16 <setvbuf+0xc2>
  401a9e:	bf00      	nop
  401aa0:	20400000 	.word	0x20400000
  401aa4:	00402914 	.word	0x00402914
  401aa8:	00402934 	.word	0x00402934
  401aac:	004028f4 	.word	0x004028f4

00401ab0 <__swbuf_r>:
  401ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401ab2:	460e      	mov	r6, r1
  401ab4:	4614      	mov	r4, r2
  401ab6:	4605      	mov	r5, r0
  401ab8:	b118      	cbz	r0, 401ac2 <__swbuf_r+0x12>
  401aba:	6983      	ldr	r3, [r0, #24]
  401abc:	b90b      	cbnz	r3, 401ac2 <__swbuf_r+0x12>
  401abe:	f000 f9a9 	bl	401e14 <__sinit>
  401ac2:	4b21      	ldr	r3, [pc, #132]	; (401b48 <__swbuf_r+0x98>)
  401ac4:	429c      	cmp	r4, r3
  401ac6:	d12a      	bne.n	401b1e <__swbuf_r+0x6e>
  401ac8:	686c      	ldr	r4, [r5, #4]
  401aca:	69a3      	ldr	r3, [r4, #24]
  401acc:	60a3      	str	r3, [r4, #8]
  401ace:	89a3      	ldrh	r3, [r4, #12]
  401ad0:	071a      	lsls	r2, r3, #28
  401ad2:	d52e      	bpl.n	401b32 <__swbuf_r+0x82>
  401ad4:	6923      	ldr	r3, [r4, #16]
  401ad6:	b363      	cbz	r3, 401b32 <__swbuf_r+0x82>
  401ad8:	6923      	ldr	r3, [r4, #16]
  401ada:	6820      	ldr	r0, [r4, #0]
  401adc:	1ac0      	subs	r0, r0, r3
  401ade:	6963      	ldr	r3, [r4, #20]
  401ae0:	b2f6      	uxtb	r6, r6
  401ae2:	4298      	cmp	r0, r3
  401ae4:	4637      	mov	r7, r6
  401ae6:	db04      	blt.n	401af2 <__swbuf_r+0x42>
  401ae8:	4621      	mov	r1, r4
  401aea:	4628      	mov	r0, r5
  401aec:	f000 f928 	bl	401d40 <_fflush_r>
  401af0:	bb28      	cbnz	r0, 401b3e <__swbuf_r+0x8e>
  401af2:	68a3      	ldr	r3, [r4, #8]
  401af4:	3b01      	subs	r3, #1
  401af6:	60a3      	str	r3, [r4, #8]
  401af8:	6823      	ldr	r3, [r4, #0]
  401afa:	1c5a      	adds	r2, r3, #1
  401afc:	6022      	str	r2, [r4, #0]
  401afe:	701e      	strb	r6, [r3, #0]
  401b00:	6963      	ldr	r3, [r4, #20]
  401b02:	3001      	adds	r0, #1
  401b04:	4298      	cmp	r0, r3
  401b06:	d004      	beq.n	401b12 <__swbuf_r+0x62>
  401b08:	89a3      	ldrh	r3, [r4, #12]
  401b0a:	07db      	lsls	r3, r3, #31
  401b0c:	d519      	bpl.n	401b42 <__swbuf_r+0x92>
  401b0e:	2e0a      	cmp	r6, #10
  401b10:	d117      	bne.n	401b42 <__swbuf_r+0x92>
  401b12:	4621      	mov	r1, r4
  401b14:	4628      	mov	r0, r5
  401b16:	f000 f913 	bl	401d40 <_fflush_r>
  401b1a:	b190      	cbz	r0, 401b42 <__swbuf_r+0x92>
  401b1c:	e00f      	b.n	401b3e <__swbuf_r+0x8e>
  401b1e:	4b0b      	ldr	r3, [pc, #44]	; (401b4c <__swbuf_r+0x9c>)
  401b20:	429c      	cmp	r4, r3
  401b22:	d101      	bne.n	401b28 <__swbuf_r+0x78>
  401b24:	68ac      	ldr	r4, [r5, #8]
  401b26:	e7d0      	b.n	401aca <__swbuf_r+0x1a>
  401b28:	4b09      	ldr	r3, [pc, #36]	; (401b50 <__swbuf_r+0xa0>)
  401b2a:	429c      	cmp	r4, r3
  401b2c:	bf08      	it	eq
  401b2e:	68ec      	ldreq	r4, [r5, #12]
  401b30:	e7cb      	b.n	401aca <__swbuf_r+0x1a>
  401b32:	4621      	mov	r1, r4
  401b34:	4628      	mov	r0, r5
  401b36:	f000 f80d 	bl	401b54 <__swsetup_r>
  401b3a:	2800      	cmp	r0, #0
  401b3c:	d0cc      	beq.n	401ad8 <__swbuf_r+0x28>
  401b3e:	f04f 37ff 	mov.w	r7, #4294967295
  401b42:	4638      	mov	r0, r7
  401b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401b46:	bf00      	nop
  401b48:	00402914 	.word	0x00402914
  401b4c:	00402934 	.word	0x00402934
  401b50:	004028f4 	.word	0x004028f4

00401b54 <__swsetup_r>:
  401b54:	4b32      	ldr	r3, [pc, #200]	; (401c20 <__swsetup_r+0xcc>)
  401b56:	b570      	push	{r4, r5, r6, lr}
  401b58:	681d      	ldr	r5, [r3, #0]
  401b5a:	4606      	mov	r6, r0
  401b5c:	460c      	mov	r4, r1
  401b5e:	b125      	cbz	r5, 401b6a <__swsetup_r+0x16>
  401b60:	69ab      	ldr	r3, [r5, #24]
  401b62:	b913      	cbnz	r3, 401b6a <__swsetup_r+0x16>
  401b64:	4628      	mov	r0, r5
  401b66:	f000 f955 	bl	401e14 <__sinit>
  401b6a:	4b2e      	ldr	r3, [pc, #184]	; (401c24 <__swsetup_r+0xd0>)
  401b6c:	429c      	cmp	r4, r3
  401b6e:	d10f      	bne.n	401b90 <__swsetup_r+0x3c>
  401b70:	686c      	ldr	r4, [r5, #4]
  401b72:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401b76:	b29a      	uxth	r2, r3
  401b78:	0715      	lsls	r5, r2, #28
  401b7a:	d42c      	bmi.n	401bd6 <__swsetup_r+0x82>
  401b7c:	06d0      	lsls	r0, r2, #27
  401b7e:	d411      	bmi.n	401ba4 <__swsetup_r+0x50>
  401b80:	2209      	movs	r2, #9
  401b82:	6032      	str	r2, [r6, #0]
  401b84:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401b88:	81a3      	strh	r3, [r4, #12]
  401b8a:	f04f 30ff 	mov.w	r0, #4294967295
  401b8e:	bd70      	pop	{r4, r5, r6, pc}
  401b90:	4b25      	ldr	r3, [pc, #148]	; (401c28 <__swsetup_r+0xd4>)
  401b92:	429c      	cmp	r4, r3
  401b94:	d101      	bne.n	401b9a <__swsetup_r+0x46>
  401b96:	68ac      	ldr	r4, [r5, #8]
  401b98:	e7eb      	b.n	401b72 <__swsetup_r+0x1e>
  401b9a:	4b24      	ldr	r3, [pc, #144]	; (401c2c <__swsetup_r+0xd8>)
  401b9c:	429c      	cmp	r4, r3
  401b9e:	bf08      	it	eq
  401ba0:	68ec      	ldreq	r4, [r5, #12]
  401ba2:	e7e6      	b.n	401b72 <__swsetup_r+0x1e>
  401ba4:	0751      	lsls	r1, r2, #29
  401ba6:	d512      	bpl.n	401bce <__swsetup_r+0x7a>
  401ba8:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401baa:	b141      	cbz	r1, 401bbe <__swsetup_r+0x6a>
  401bac:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401bb0:	4299      	cmp	r1, r3
  401bb2:	d002      	beq.n	401bba <__swsetup_r+0x66>
  401bb4:	4630      	mov	r0, r6
  401bb6:	f7ff fdf1 	bl	40179c <_free_r>
  401bba:	2300      	movs	r3, #0
  401bbc:	6363      	str	r3, [r4, #52]	; 0x34
  401bbe:	89a3      	ldrh	r3, [r4, #12]
  401bc0:	f023 0324 	bic.w	r3, r3, #36	; 0x24
  401bc4:	81a3      	strh	r3, [r4, #12]
  401bc6:	2300      	movs	r3, #0
  401bc8:	6063      	str	r3, [r4, #4]
  401bca:	6923      	ldr	r3, [r4, #16]
  401bcc:	6023      	str	r3, [r4, #0]
  401bce:	89a3      	ldrh	r3, [r4, #12]
  401bd0:	f043 0308 	orr.w	r3, r3, #8
  401bd4:	81a3      	strh	r3, [r4, #12]
  401bd6:	6923      	ldr	r3, [r4, #16]
  401bd8:	b94b      	cbnz	r3, 401bee <__swsetup_r+0x9a>
  401bda:	89a3      	ldrh	r3, [r4, #12]
  401bdc:	f403 7320 	and.w	r3, r3, #640	; 0x280
  401be0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  401be4:	d003      	beq.n	401bee <__swsetup_r+0x9a>
  401be6:	4621      	mov	r1, r4
  401be8:	4630      	mov	r0, r6
  401bea:	f000 f9c1 	bl	401f70 <__smakebuf_r>
  401bee:	89a2      	ldrh	r2, [r4, #12]
  401bf0:	f012 0301 	ands.w	r3, r2, #1
  401bf4:	d00c      	beq.n	401c10 <__swsetup_r+0xbc>
  401bf6:	2300      	movs	r3, #0
  401bf8:	60a3      	str	r3, [r4, #8]
  401bfa:	6963      	ldr	r3, [r4, #20]
  401bfc:	425b      	negs	r3, r3
  401bfe:	61a3      	str	r3, [r4, #24]
  401c00:	6923      	ldr	r3, [r4, #16]
  401c02:	b953      	cbnz	r3, 401c1a <__swsetup_r+0xc6>
  401c04:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401c08:	f013 0080 	ands.w	r0, r3, #128	; 0x80
  401c0c:	d1ba      	bne.n	401b84 <__swsetup_r+0x30>
  401c0e:	bd70      	pop	{r4, r5, r6, pc}
  401c10:	0792      	lsls	r2, r2, #30
  401c12:	bf58      	it	pl
  401c14:	6963      	ldrpl	r3, [r4, #20]
  401c16:	60a3      	str	r3, [r4, #8]
  401c18:	e7f2      	b.n	401c00 <__swsetup_r+0xac>
  401c1a:	2000      	movs	r0, #0
  401c1c:	e7f7      	b.n	401c0e <__swsetup_r+0xba>
  401c1e:	bf00      	nop
  401c20:	20400000 	.word	0x20400000
  401c24:	00402914 	.word	0x00402914
  401c28:	00402934 	.word	0x00402934
  401c2c:	004028f4 	.word	0x004028f4

00401c30 <__sflush_r>:
  401c30:	898a      	ldrh	r2, [r1, #12]
  401c32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401c36:	4605      	mov	r5, r0
  401c38:	0710      	lsls	r0, r2, #28
  401c3a:	460c      	mov	r4, r1
  401c3c:	d45a      	bmi.n	401cf4 <__sflush_r+0xc4>
  401c3e:	684b      	ldr	r3, [r1, #4]
  401c40:	2b00      	cmp	r3, #0
  401c42:	dc05      	bgt.n	401c50 <__sflush_r+0x20>
  401c44:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  401c46:	2b00      	cmp	r3, #0
  401c48:	dc02      	bgt.n	401c50 <__sflush_r+0x20>
  401c4a:	2000      	movs	r0, #0
  401c4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401c50:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  401c52:	2e00      	cmp	r6, #0
  401c54:	d0f9      	beq.n	401c4a <__sflush_r+0x1a>
  401c56:	2300      	movs	r3, #0
  401c58:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  401c5c:	682f      	ldr	r7, [r5, #0]
  401c5e:	602b      	str	r3, [r5, #0]
  401c60:	d033      	beq.n	401cca <__sflush_r+0x9a>
  401c62:	6d60      	ldr	r0, [r4, #84]	; 0x54
  401c64:	89a3      	ldrh	r3, [r4, #12]
  401c66:	075a      	lsls	r2, r3, #29
  401c68:	d505      	bpl.n	401c76 <__sflush_r+0x46>
  401c6a:	6863      	ldr	r3, [r4, #4]
  401c6c:	1ac0      	subs	r0, r0, r3
  401c6e:	6b63      	ldr	r3, [r4, #52]	; 0x34
  401c70:	b10b      	cbz	r3, 401c76 <__sflush_r+0x46>
  401c72:	6c23      	ldr	r3, [r4, #64]	; 0x40
  401c74:	1ac0      	subs	r0, r0, r3
  401c76:	2300      	movs	r3, #0
  401c78:	4602      	mov	r2, r0
  401c7a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  401c7c:	6a21      	ldr	r1, [r4, #32]
  401c7e:	4628      	mov	r0, r5
  401c80:	47b0      	blx	r6
  401c82:	1c43      	adds	r3, r0, #1
  401c84:	89a3      	ldrh	r3, [r4, #12]
  401c86:	d106      	bne.n	401c96 <__sflush_r+0x66>
  401c88:	6829      	ldr	r1, [r5, #0]
  401c8a:	291d      	cmp	r1, #29
  401c8c:	d84b      	bhi.n	401d26 <__sflush_r+0xf6>
  401c8e:	4a2b      	ldr	r2, [pc, #172]	; (401d3c <__sflush_r+0x10c>)
  401c90:	40ca      	lsrs	r2, r1
  401c92:	07d6      	lsls	r6, r2, #31
  401c94:	d547      	bpl.n	401d26 <__sflush_r+0xf6>
  401c96:	2200      	movs	r2, #0
  401c98:	6062      	str	r2, [r4, #4]
  401c9a:	04d9      	lsls	r1, r3, #19
  401c9c:	6922      	ldr	r2, [r4, #16]
  401c9e:	6022      	str	r2, [r4, #0]
  401ca0:	d504      	bpl.n	401cac <__sflush_r+0x7c>
  401ca2:	1c42      	adds	r2, r0, #1
  401ca4:	d101      	bne.n	401caa <__sflush_r+0x7a>
  401ca6:	682b      	ldr	r3, [r5, #0]
  401ca8:	b903      	cbnz	r3, 401cac <__sflush_r+0x7c>
  401caa:	6560      	str	r0, [r4, #84]	; 0x54
  401cac:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401cae:	602f      	str	r7, [r5, #0]
  401cb0:	2900      	cmp	r1, #0
  401cb2:	d0ca      	beq.n	401c4a <__sflush_r+0x1a>
  401cb4:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401cb8:	4299      	cmp	r1, r3
  401cba:	d002      	beq.n	401cc2 <__sflush_r+0x92>
  401cbc:	4628      	mov	r0, r5
  401cbe:	f7ff fd6d 	bl	40179c <_free_r>
  401cc2:	2000      	movs	r0, #0
  401cc4:	6360      	str	r0, [r4, #52]	; 0x34
  401cc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401cca:	6a21      	ldr	r1, [r4, #32]
  401ccc:	2301      	movs	r3, #1
  401cce:	4628      	mov	r0, r5
  401cd0:	47b0      	blx	r6
  401cd2:	1c41      	adds	r1, r0, #1
  401cd4:	d1c6      	bne.n	401c64 <__sflush_r+0x34>
  401cd6:	682b      	ldr	r3, [r5, #0]
  401cd8:	2b00      	cmp	r3, #0
  401cda:	d0c3      	beq.n	401c64 <__sflush_r+0x34>
  401cdc:	2b1d      	cmp	r3, #29
  401cde:	d001      	beq.n	401ce4 <__sflush_r+0xb4>
  401ce0:	2b16      	cmp	r3, #22
  401ce2:	d101      	bne.n	401ce8 <__sflush_r+0xb8>
  401ce4:	602f      	str	r7, [r5, #0]
  401ce6:	e7b0      	b.n	401c4a <__sflush_r+0x1a>
  401ce8:	89a3      	ldrh	r3, [r4, #12]
  401cea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401cee:	81a3      	strh	r3, [r4, #12]
  401cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401cf4:	690f      	ldr	r7, [r1, #16]
  401cf6:	2f00      	cmp	r7, #0
  401cf8:	d0a7      	beq.n	401c4a <__sflush_r+0x1a>
  401cfa:	0793      	lsls	r3, r2, #30
  401cfc:	680e      	ldr	r6, [r1, #0]
  401cfe:	bf08      	it	eq
  401d00:	694b      	ldreq	r3, [r1, #20]
  401d02:	600f      	str	r7, [r1, #0]
  401d04:	bf18      	it	ne
  401d06:	2300      	movne	r3, #0
  401d08:	eba6 0807 	sub.w	r8, r6, r7
  401d0c:	608b      	str	r3, [r1, #8]
  401d0e:	f1b8 0f00 	cmp.w	r8, #0
  401d12:	dd9a      	ble.n	401c4a <__sflush_r+0x1a>
  401d14:	4643      	mov	r3, r8
  401d16:	463a      	mov	r2, r7
  401d18:	6a21      	ldr	r1, [r4, #32]
  401d1a:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  401d1c:	4628      	mov	r0, r5
  401d1e:	47b0      	blx	r6
  401d20:	2800      	cmp	r0, #0
  401d22:	dc07      	bgt.n	401d34 <__sflush_r+0x104>
  401d24:	89a3      	ldrh	r3, [r4, #12]
  401d26:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401d2a:	81a3      	strh	r3, [r4, #12]
  401d2c:	f04f 30ff 	mov.w	r0, #4294967295
  401d30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401d34:	4407      	add	r7, r0
  401d36:	eba8 0800 	sub.w	r8, r8, r0
  401d3a:	e7e8      	b.n	401d0e <__sflush_r+0xde>
  401d3c:	20400001 	.word	0x20400001

00401d40 <_fflush_r>:
  401d40:	b538      	push	{r3, r4, r5, lr}
  401d42:	690b      	ldr	r3, [r1, #16]
  401d44:	4605      	mov	r5, r0
  401d46:	460c      	mov	r4, r1
  401d48:	b1db      	cbz	r3, 401d82 <_fflush_r+0x42>
  401d4a:	b118      	cbz	r0, 401d54 <_fflush_r+0x14>
  401d4c:	6983      	ldr	r3, [r0, #24]
  401d4e:	b90b      	cbnz	r3, 401d54 <_fflush_r+0x14>
  401d50:	f000 f860 	bl	401e14 <__sinit>
  401d54:	4b0c      	ldr	r3, [pc, #48]	; (401d88 <_fflush_r+0x48>)
  401d56:	429c      	cmp	r4, r3
  401d58:	d109      	bne.n	401d6e <_fflush_r+0x2e>
  401d5a:	686c      	ldr	r4, [r5, #4]
  401d5c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401d60:	b17b      	cbz	r3, 401d82 <_fflush_r+0x42>
  401d62:	4621      	mov	r1, r4
  401d64:	4628      	mov	r0, r5
  401d66:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  401d6a:	f7ff bf61 	b.w	401c30 <__sflush_r>
  401d6e:	4b07      	ldr	r3, [pc, #28]	; (401d8c <_fflush_r+0x4c>)
  401d70:	429c      	cmp	r4, r3
  401d72:	d101      	bne.n	401d78 <_fflush_r+0x38>
  401d74:	68ac      	ldr	r4, [r5, #8]
  401d76:	e7f1      	b.n	401d5c <_fflush_r+0x1c>
  401d78:	4b05      	ldr	r3, [pc, #20]	; (401d90 <_fflush_r+0x50>)
  401d7a:	429c      	cmp	r4, r3
  401d7c:	bf08      	it	eq
  401d7e:	68ec      	ldreq	r4, [r5, #12]
  401d80:	e7ec      	b.n	401d5c <_fflush_r+0x1c>
  401d82:	2000      	movs	r0, #0
  401d84:	bd38      	pop	{r3, r4, r5, pc}
  401d86:	bf00      	nop
  401d88:	00402914 	.word	0x00402914
  401d8c:	00402934 	.word	0x00402934
  401d90:	004028f4 	.word	0x004028f4

00401d94 <_cleanup_r>:
  401d94:	4901      	ldr	r1, [pc, #4]	; (401d9c <_cleanup_r+0x8>)
  401d96:	f000 b8a9 	b.w	401eec <_fwalk_reent>
  401d9a:	bf00      	nop
  401d9c:	00401d41 	.word	0x00401d41

00401da0 <std.isra.0>:
  401da0:	2300      	movs	r3, #0
  401da2:	b510      	push	{r4, lr}
  401da4:	4604      	mov	r4, r0
  401da6:	6003      	str	r3, [r0, #0]
  401da8:	6043      	str	r3, [r0, #4]
  401daa:	6083      	str	r3, [r0, #8]
  401dac:	8181      	strh	r1, [r0, #12]
  401dae:	6643      	str	r3, [r0, #100]	; 0x64
  401db0:	81c2      	strh	r2, [r0, #14]
  401db2:	6103      	str	r3, [r0, #16]
  401db4:	6143      	str	r3, [r0, #20]
  401db6:	6183      	str	r3, [r0, #24]
  401db8:	4619      	mov	r1, r3
  401dba:	2208      	movs	r2, #8
  401dbc:	305c      	adds	r0, #92	; 0x5c
  401dbe:	f7ff fce5 	bl	40178c <memset>
  401dc2:	4b05      	ldr	r3, [pc, #20]	; (401dd8 <std.isra.0+0x38>)
  401dc4:	6263      	str	r3, [r4, #36]	; 0x24
  401dc6:	4b05      	ldr	r3, [pc, #20]	; (401ddc <std.isra.0+0x3c>)
  401dc8:	62a3      	str	r3, [r4, #40]	; 0x28
  401dca:	4b05      	ldr	r3, [pc, #20]	; (401de0 <std.isra.0+0x40>)
  401dcc:	62e3      	str	r3, [r4, #44]	; 0x2c
  401dce:	4b05      	ldr	r3, [pc, #20]	; (401de4 <std.isra.0+0x44>)
  401dd0:	6224      	str	r4, [r4, #32]
  401dd2:	6323      	str	r3, [r4, #48]	; 0x30
  401dd4:	bd10      	pop	{r4, pc}
  401dd6:	bf00      	nop
  401dd8:	0040259d 	.word	0x0040259d
  401ddc:	004025bf 	.word	0x004025bf
  401de0:	004025f7 	.word	0x004025f7
  401de4:	0040261b 	.word	0x0040261b

00401de8 <__sfmoreglue>:
  401de8:	b570      	push	{r4, r5, r6, lr}
  401dea:	1e4a      	subs	r2, r1, #1
  401dec:	2568      	movs	r5, #104	; 0x68
  401dee:	4355      	muls	r5, r2
  401df0:	460e      	mov	r6, r1
  401df2:	f105 0174 	add.w	r1, r5, #116	; 0x74
  401df6:	f7ff fd1f 	bl	401838 <_malloc_r>
  401dfa:	4604      	mov	r4, r0
  401dfc:	b140      	cbz	r0, 401e10 <__sfmoreglue+0x28>
  401dfe:	2100      	movs	r1, #0
  401e00:	e880 0042 	stmia.w	r0, {r1, r6}
  401e04:	300c      	adds	r0, #12
  401e06:	60a0      	str	r0, [r4, #8]
  401e08:	f105 0268 	add.w	r2, r5, #104	; 0x68
  401e0c:	f7ff fcbe 	bl	40178c <memset>
  401e10:	4620      	mov	r0, r4
  401e12:	bd70      	pop	{r4, r5, r6, pc}

00401e14 <__sinit>:
  401e14:	6983      	ldr	r3, [r0, #24]
  401e16:	b510      	push	{r4, lr}
  401e18:	4604      	mov	r4, r0
  401e1a:	bb33      	cbnz	r3, 401e6a <__sinit+0x56>
  401e1c:	6483      	str	r3, [r0, #72]	; 0x48
  401e1e:	64c3      	str	r3, [r0, #76]	; 0x4c
  401e20:	6503      	str	r3, [r0, #80]	; 0x50
  401e22:	4b12      	ldr	r3, [pc, #72]	; (401e6c <__sinit+0x58>)
  401e24:	4a12      	ldr	r2, [pc, #72]	; (401e70 <__sinit+0x5c>)
  401e26:	681b      	ldr	r3, [r3, #0]
  401e28:	6282      	str	r2, [r0, #40]	; 0x28
  401e2a:	4298      	cmp	r0, r3
  401e2c:	bf04      	itt	eq
  401e2e:	2301      	moveq	r3, #1
  401e30:	6183      	streq	r3, [r0, #24]
  401e32:	f000 f81f 	bl	401e74 <__sfp>
  401e36:	6060      	str	r0, [r4, #4]
  401e38:	4620      	mov	r0, r4
  401e3a:	f000 f81b 	bl	401e74 <__sfp>
  401e3e:	60a0      	str	r0, [r4, #8]
  401e40:	4620      	mov	r0, r4
  401e42:	f000 f817 	bl	401e74 <__sfp>
  401e46:	2200      	movs	r2, #0
  401e48:	60e0      	str	r0, [r4, #12]
  401e4a:	2104      	movs	r1, #4
  401e4c:	6860      	ldr	r0, [r4, #4]
  401e4e:	f7ff ffa7 	bl	401da0 <std.isra.0>
  401e52:	2201      	movs	r2, #1
  401e54:	2109      	movs	r1, #9
  401e56:	68a0      	ldr	r0, [r4, #8]
  401e58:	f7ff ffa2 	bl	401da0 <std.isra.0>
  401e5c:	2202      	movs	r2, #2
  401e5e:	2112      	movs	r1, #18
  401e60:	68e0      	ldr	r0, [r4, #12]
  401e62:	f7ff ff9d 	bl	401da0 <std.isra.0>
  401e66:	2301      	movs	r3, #1
  401e68:	61a3      	str	r3, [r4, #24]
  401e6a:	bd10      	pop	{r4, pc}
  401e6c:	004028f0 	.word	0x004028f0
  401e70:	00401d95 	.word	0x00401d95

00401e74 <__sfp>:
  401e74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401e76:	4b1c      	ldr	r3, [pc, #112]	; (401ee8 <__sfp+0x74>)
  401e78:	681e      	ldr	r6, [r3, #0]
  401e7a:	69b3      	ldr	r3, [r6, #24]
  401e7c:	4607      	mov	r7, r0
  401e7e:	b913      	cbnz	r3, 401e86 <__sfp+0x12>
  401e80:	4630      	mov	r0, r6
  401e82:	f7ff ffc7 	bl	401e14 <__sinit>
  401e86:	3648      	adds	r6, #72	; 0x48
  401e88:	68b4      	ldr	r4, [r6, #8]
  401e8a:	6873      	ldr	r3, [r6, #4]
  401e8c:	3b01      	subs	r3, #1
  401e8e:	d503      	bpl.n	401e98 <__sfp+0x24>
  401e90:	6833      	ldr	r3, [r6, #0]
  401e92:	b133      	cbz	r3, 401ea2 <__sfp+0x2e>
  401e94:	6836      	ldr	r6, [r6, #0]
  401e96:	e7f7      	b.n	401e88 <__sfp+0x14>
  401e98:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  401e9c:	b16d      	cbz	r5, 401eba <__sfp+0x46>
  401e9e:	3468      	adds	r4, #104	; 0x68
  401ea0:	e7f4      	b.n	401e8c <__sfp+0x18>
  401ea2:	2104      	movs	r1, #4
  401ea4:	4638      	mov	r0, r7
  401ea6:	f7ff ff9f 	bl	401de8 <__sfmoreglue>
  401eaa:	6030      	str	r0, [r6, #0]
  401eac:	2800      	cmp	r0, #0
  401eae:	d1f1      	bne.n	401e94 <__sfp+0x20>
  401eb0:	230c      	movs	r3, #12
  401eb2:	603b      	str	r3, [r7, #0]
  401eb4:	4604      	mov	r4, r0
  401eb6:	4620      	mov	r0, r4
  401eb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401eba:	f64f 73ff 	movw	r3, #65535	; 0xffff
  401ebe:	81e3      	strh	r3, [r4, #14]
  401ec0:	2301      	movs	r3, #1
  401ec2:	81a3      	strh	r3, [r4, #12]
  401ec4:	6665      	str	r5, [r4, #100]	; 0x64
  401ec6:	6025      	str	r5, [r4, #0]
  401ec8:	60a5      	str	r5, [r4, #8]
  401eca:	6065      	str	r5, [r4, #4]
  401ecc:	6125      	str	r5, [r4, #16]
  401ece:	6165      	str	r5, [r4, #20]
  401ed0:	61a5      	str	r5, [r4, #24]
  401ed2:	2208      	movs	r2, #8
  401ed4:	4629      	mov	r1, r5
  401ed6:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  401eda:	f7ff fc57 	bl	40178c <memset>
  401ede:	6365      	str	r5, [r4, #52]	; 0x34
  401ee0:	63a5      	str	r5, [r4, #56]	; 0x38
  401ee2:	64a5      	str	r5, [r4, #72]	; 0x48
  401ee4:	64e5      	str	r5, [r4, #76]	; 0x4c
  401ee6:	e7e6      	b.n	401eb6 <__sfp+0x42>
  401ee8:	004028f0 	.word	0x004028f0

00401eec <_fwalk_reent>:
  401eec:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  401ef0:	4680      	mov	r8, r0
  401ef2:	4689      	mov	r9, r1
  401ef4:	f100 0448 	add.w	r4, r0, #72	; 0x48
  401ef8:	2600      	movs	r6, #0
  401efa:	b914      	cbnz	r4, 401f02 <_fwalk_reent+0x16>
  401efc:	4630      	mov	r0, r6
  401efe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401f02:	68a5      	ldr	r5, [r4, #8]
  401f04:	6867      	ldr	r7, [r4, #4]
  401f06:	3f01      	subs	r7, #1
  401f08:	d501      	bpl.n	401f0e <_fwalk_reent+0x22>
  401f0a:	6824      	ldr	r4, [r4, #0]
  401f0c:	e7f5      	b.n	401efa <_fwalk_reent+0xe>
  401f0e:	89ab      	ldrh	r3, [r5, #12]
  401f10:	2b01      	cmp	r3, #1
  401f12:	d907      	bls.n	401f24 <_fwalk_reent+0x38>
  401f14:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  401f18:	3301      	adds	r3, #1
  401f1a:	d003      	beq.n	401f24 <_fwalk_reent+0x38>
  401f1c:	4629      	mov	r1, r5
  401f1e:	4640      	mov	r0, r8
  401f20:	47c8      	blx	r9
  401f22:	4306      	orrs	r6, r0
  401f24:	3568      	adds	r5, #104	; 0x68
  401f26:	e7ee      	b.n	401f06 <_fwalk_reent+0x1a>

00401f28 <__swhatbuf_r>:
  401f28:	b570      	push	{r4, r5, r6, lr}
  401f2a:	460e      	mov	r6, r1
  401f2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  401f30:	2900      	cmp	r1, #0
  401f32:	b090      	sub	sp, #64	; 0x40
  401f34:	4614      	mov	r4, r2
  401f36:	461d      	mov	r5, r3
  401f38:	da07      	bge.n	401f4a <__swhatbuf_r+0x22>
  401f3a:	2300      	movs	r3, #0
  401f3c:	602b      	str	r3, [r5, #0]
  401f3e:	89b3      	ldrh	r3, [r6, #12]
  401f40:	061a      	lsls	r2, r3, #24
  401f42:	d410      	bmi.n	401f66 <__swhatbuf_r+0x3e>
  401f44:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401f48:	e00e      	b.n	401f68 <__swhatbuf_r+0x40>
  401f4a:	aa01      	add	r2, sp, #4
  401f4c:	f000 fb8c 	bl	402668 <_fstat_r>
  401f50:	2800      	cmp	r0, #0
  401f52:	dbf2      	blt.n	401f3a <__swhatbuf_r+0x12>
  401f54:	9a02      	ldr	r2, [sp, #8]
  401f56:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  401f5a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  401f5e:	425a      	negs	r2, r3
  401f60:	415a      	adcs	r2, r3
  401f62:	602a      	str	r2, [r5, #0]
  401f64:	e7ee      	b.n	401f44 <__swhatbuf_r+0x1c>
  401f66:	2340      	movs	r3, #64	; 0x40
  401f68:	2000      	movs	r0, #0
  401f6a:	6023      	str	r3, [r4, #0]
  401f6c:	b010      	add	sp, #64	; 0x40
  401f6e:	bd70      	pop	{r4, r5, r6, pc}

00401f70 <__smakebuf_r>:
  401f70:	898b      	ldrh	r3, [r1, #12]
  401f72:	b573      	push	{r0, r1, r4, r5, r6, lr}
  401f74:	079d      	lsls	r5, r3, #30
  401f76:	4606      	mov	r6, r0
  401f78:	460c      	mov	r4, r1
  401f7a:	d507      	bpl.n	401f8c <__smakebuf_r+0x1c>
  401f7c:	f104 0347 	add.w	r3, r4, #71	; 0x47
  401f80:	6023      	str	r3, [r4, #0]
  401f82:	6123      	str	r3, [r4, #16]
  401f84:	2301      	movs	r3, #1
  401f86:	6163      	str	r3, [r4, #20]
  401f88:	b002      	add	sp, #8
  401f8a:	bd70      	pop	{r4, r5, r6, pc}
  401f8c:	ab01      	add	r3, sp, #4
  401f8e:	466a      	mov	r2, sp
  401f90:	f7ff ffca 	bl	401f28 <__swhatbuf_r>
  401f94:	9900      	ldr	r1, [sp, #0]
  401f96:	4605      	mov	r5, r0
  401f98:	4630      	mov	r0, r6
  401f9a:	f7ff fc4d 	bl	401838 <_malloc_r>
  401f9e:	b948      	cbnz	r0, 401fb4 <__smakebuf_r+0x44>
  401fa0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401fa4:	059a      	lsls	r2, r3, #22
  401fa6:	d4ef      	bmi.n	401f88 <__smakebuf_r+0x18>
  401fa8:	f023 0303 	bic.w	r3, r3, #3
  401fac:	f043 0302 	orr.w	r3, r3, #2
  401fb0:	81a3      	strh	r3, [r4, #12]
  401fb2:	e7e3      	b.n	401f7c <__smakebuf_r+0xc>
  401fb4:	4b0d      	ldr	r3, [pc, #52]	; (401fec <__smakebuf_r+0x7c>)
  401fb6:	62b3      	str	r3, [r6, #40]	; 0x28
  401fb8:	89a3      	ldrh	r3, [r4, #12]
  401fba:	6020      	str	r0, [r4, #0]
  401fbc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  401fc0:	81a3      	strh	r3, [r4, #12]
  401fc2:	9b00      	ldr	r3, [sp, #0]
  401fc4:	6163      	str	r3, [r4, #20]
  401fc6:	9b01      	ldr	r3, [sp, #4]
  401fc8:	6120      	str	r0, [r4, #16]
  401fca:	b15b      	cbz	r3, 401fe4 <__smakebuf_r+0x74>
  401fcc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  401fd0:	4630      	mov	r0, r6
  401fd2:	f000 fb5b 	bl	40268c <_isatty_r>
  401fd6:	b128      	cbz	r0, 401fe4 <__smakebuf_r+0x74>
  401fd8:	89a3      	ldrh	r3, [r4, #12]
  401fda:	f023 0303 	bic.w	r3, r3, #3
  401fde:	f043 0301 	orr.w	r3, r3, #1
  401fe2:	81a3      	strh	r3, [r4, #12]
  401fe4:	89a3      	ldrh	r3, [r4, #12]
  401fe6:	431d      	orrs	r5, r3
  401fe8:	81a5      	strh	r5, [r4, #12]
  401fea:	e7cd      	b.n	401f88 <__smakebuf_r+0x18>
  401fec:	00401d95 	.word	0x00401d95

00401ff0 <__malloc_lock>:
  401ff0:	4770      	bx	lr

00401ff2 <__malloc_unlock>:
  401ff2:	4770      	bx	lr

00401ff4 <__sfputc_r>:
  401ff4:	6893      	ldr	r3, [r2, #8]
  401ff6:	3b01      	subs	r3, #1
  401ff8:	2b00      	cmp	r3, #0
  401ffa:	b410      	push	{r4}
  401ffc:	6093      	str	r3, [r2, #8]
  401ffe:	da08      	bge.n	402012 <__sfputc_r+0x1e>
  402000:	6994      	ldr	r4, [r2, #24]
  402002:	42a3      	cmp	r3, r4
  402004:	db02      	blt.n	40200c <__sfputc_r+0x18>
  402006:	b2cb      	uxtb	r3, r1
  402008:	2b0a      	cmp	r3, #10
  40200a:	d102      	bne.n	402012 <__sfputc_r+0x1e>
  40200c:	bc10      	pop	{r4}
  40200e:	f7ff bd4f 	b.w	401ab0 <__swbuf_r>
  402012:	6813      	ldr	r3, [r2, #0]
  402014:	1c58      	adds	r0, r3, #1
  402016:	6010      	str	r0, [r2, #0]
  402018:	7019      	strb	r1, [r3, #0]
  40201a:	b2c8      	uxtb	r0, r1
  40201c:	bc10      	pop	{r4}
  40201e:	4770      	bx	lr

00402020 <__sfputs_r>:
  402020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402022:	4606      	mov	r6, r0
  402024:	460f      	mov	r7, r1
  402026:	4614      	mov	r4, r2
  402028:	18d5      	adds	r5, r2, r3
  40202a:	42ac      	cmp	r4, r5
  40202c:	d101      	bne.n	402032 <__sfputs_r+0x12>
  40202e:	2000      	movs	r0, #0
  402030:	e007      	b.n	402042 <__sfputs_r+0x22>
  402032:	463a      	mov	r2, r7
  402034:	f814 1b01 	ldrb.w	r1, [r4], #1
  402038:	4630      	mov	r0, r6
  40203a:	f7ff ffdb 	bl	401ff4 <__sfputc_r>
  40203e:	1c43      	adds	r3, r0, #1
  402040:	d1f3      	bne.n	40202a <__sfputs_r+0xa>
  402042:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00402044 <_vfiprintf_r>:
  402044:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402048:	b09d      	sub	sp, #116	; 0x74
  40204a:	460c      	mov	r4, r1
  40204c:	4617      	mov	r7, r2
  40204e:	9303      	str	r3, [sp, #12]
  402050:	4606      	mov	r6, r0
  402052:	b118      	cbz	r0, 40205c <_vfiprintf_r+0x18>
  402054:	6983      	ldr	r3, [r0, #24]
  402056:	b90b      	cbnz	r3, 40205c <_vfiprintf_r+0x18>
  402058:	f7ff fedc 	bl	401e14 <__sinit>
  40205c:	4b7c      	ldr	r3, [pc, #496]	; (402250 <_vfiprintf_r+0x20c>)
  40205e:	429c      	cmp	r4, r3
  402060:	d157      	bne.n	402112 <_vfiprintf_r+0xce>
  402062:	6874      	ldr	r4, [r6, #4]
  402064:	89a3      	ldrh	r3, [r4, #12]
  402066:	0718      	lsls	r0, r3, #28
  402068:	d55d      	bpl.n	402126 <_vfiprintf_r+0xe2>
  40206a:	6923      	ldr	r3, [r4, #16]
  40206c:	2b00      	cmp	r3, #0
  40206e:	d05a      	beq.n	402126 <_vfiprintf_r+0xe2>
  402070:	2300      	movs	r3, #0
  402072:	9309      	str	r3, [sp, #36]	; 0x24
  402074:	2320      	movs	r3, #32
  402076:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  40207a:	2330      	movs	r3, #48	; 0x30
  40207c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  402080:	f04f 0b01 	mov.w	fp, #1
  402084:	46b8      	mov	r8, r7
  402086:	4645      	mov	r5, r8
  402088:	f815 3b01 	ldrb.w	r3, [r5], #1
  40208c:	2b00      	cmp	r3, #0
  40208e:	d155      	bne.n	40213c <_vfiprintf_r+0xf8>
  402090:	ebb8 0a07 	subs.w	sl, r8, r7
  402094:	d00b      	beq.n	4020ae <_vfiprintf_r+0x6a>
  402096:	4653      	mov	r3, sl
  402098:	463a      	mov	r2, r7
  40209a:	4621      	mov	r1, r4
  40209c:	4630      	mov	r0, r6
  40209e:	f7ff ffbf 	bl	402020 <__sfputs_r>
  4020a2:	3001      	adds	r0, #1
  4020a4:	f000 80c4 	beq.w	402230 <_vfiprintf_r+0x1ec>
  4020a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4020aa:	4453      	add	r3, sl
  4020ac:	9309      	str	r3, [sp, #36]	; 0x24
  4020ae:	f898 3000 	ldrb.w	r3, [r8]
  4020b2:	2b00      	cmp	r3, #0
  4020b4:	f000 80bc 	beq.w	402230 <_vfiprintf_r+0x1ec>
  4020b8:	2300      	movs	r3, #0
  4020ba:	f04f 32ff 	mov.w	r2, #4294967295
  4020be:	9304      	str	r3, [sp, #16]
  4020c0:	9307      	str	r3, [sp, #28]
  4020c2:	9205      	str	r2, [sp, #20]
  4020c4:	9306      	str	r3, [sp, #24]
  4020c6:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  4020ca:	931a      	str	r3, [sp, #104]	; 0x68
  4020cc:	2205      	movs	r2, #5
  4020ce:	7829      	ldrb	r1, [r5, #0]
  4020d0:	4860      	ldr	r0, [pc, #384]	; (402254 <_vfiprintf_r+0x210>)
  4020d2:	f000 fafd 	bl	4026d0 <memchr>
  4020d6:	f105 0801 	add.w	r8, r5, #1
  4020da:	9b04      	ldr	r3, [sp, #16]
  4020dc:	2800      	cmp	r0, #0
  4020de:	d131      	bne.n	402144 <_vfiprintf_r+0x100>
  4020e0:	06d9      	lsls	r1, r3, #27
  4020e2:	bf44      	itt	mi
  4020e4:	2220      	movmi	r2, #32
  4020e6:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  4020ea:	071a      	lsls	r2, r3, #28
  4020ec:	bf44      	itt	mi
  4020ee:	222b      	movmi	r2, #43	; 0x2b
  4020f0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  4020f4:	782a      	ldrb	r2, [r5, #0]
  4020f6:	2a2a      	cmp	r2, #42	; 0x2a
  4020f8:	d02c      	beq.n	402154 <_vfiprintf_r+0x110>
  4020fa:	9a07      	ldr	r2, [sp, #28]
  4020fc:	2100      	movs	r1, #0
  4020fe:	200a      	movs	r0, #10
  402100:	46a8      	mov	r8, r5
  402102:	3501      	adds	r5, #1
  402104:	f898 3000 	ldrb.w	r3, [r8]
  402108:	3b30      	subs	r3, #48	; 0x30
  40210a:	2b09      	cmp	r3, #9
  40210c:	d96d      	bls.n	4021ea <_vfiprintf_r+0x1a6>
  40210e:	b371      	cbz	r1, 40216e <_vfiprintf_r+0x12a>
  402110:	e026      	b.n	402160 <_vfiprintf_r+0x11c>
  402112:	4b51      	ldr	r3, [pc, #324]	; (402258 <_vfiprintf_r+0x214>)
  402114:	429c      	cmp	r4, r3
  402116:	d101      	bne.n	40211c <_vfiprintf_r+0xd8>
  402118:	68b4      	ldr	r4, [r6, #8]
  40211a:	e7a3      	b.n	402064 <_vfiprintf_r+0x20>
  40211c:	4b4f      	ldr	r3, [pc, #316]	; (40225c <_vfiprintf_r+0x218>)
  40211e:	429c      	cmp	r4, r3
  402120:	bf08      	it	eq
  402122:	68f4      	ldreq	r4, [r6, #12]
  402124:	e79e      	b.n	402064 <_vfiprintf_r+0x20>
  402126:	4621      	mov	r1, r4
  402128:	4630      	mov	r0, r6
  40212a:	f7ff fd13 	bl	401b54 <__swsetup_r>
  40212e:	2800      	cmp	r0, #0
  402130:	d09e      	beq.n	402070 <_vfiprintf_r+0x2c>
  402132:	f04f 30ff 	mov.w	r0, #4294967295
  402136:	b01d      	add	sp, #116	; 0x74
  402138:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40213c:	2b25      	cmp	r3, #37	; 0x25
  40213e:	d0a7      	beq.n	402090 <_vfiprintf_r+0x4c>
  402140:	46a8      	mov	r8, r5
  402142:	e7a0      	b.n	402086 <_vfiprintf_r+0x42>
  402144:	4a43      	ldr	r2, [pc, #268]	; (402254 <_vfiprintf_r+0x210>)
  402146:	1a80      	subs	r0, r0, r2
  402148:	fa0b f000 	lsl.w	r0, fp, r0
  40214c:	4318      	orrs	r0, r3
  40214e:	9004      	str	r0, [sp, #16]
  402150:	4645      	mov	r5, r8
  402152:	e7bb      	b.n	4020cc <_vfiprintf_r+0x88>
  402154:	9a03      	ldr	r2, [sp, #12]
  402156:	1d11      	adds	r1, r2, #4
  402158:	6812      	ldr	r2, [r2, #0]
  40215a:	9103      	str	r1, [sp, #12]
  40215c:	2a00      	cmp	r2, #0
  40215e:	db01      	blt.n	402164 <_vfiprintf_r+0x120>
  402160:	9207      	str	r2, [sp, #28]
  402162:	e004      	b.n	40216e <_vfiprintf_r+0x12a>
  402164:	4252      	negs	r2, r2
  402166:	f043 0302 	orr.w	r3, r3, #2
  40216a:	9207      	str	r2, [sp, #28]
  40216c:	9304      	str	r3, [sp, #16]
  40216e:	f898 3000 	ldrb.w	r3, [r8]
  402172:	2b2e      	cmp	r3, #46	; 0x2e
  402174:	d110      	bne.n	402198 <_vfiprintf_r+0x154>
  402176:	f898 3001 	ldrb.w	r3, [r8, #1]
  40217a:	2b2a      	cmp	r3, #42	; 0x2a
  40217c:	f108 0101 	add.w	r1, r8, #1
  402180:	d137      	bne.n	4021f2 <_vfiprintf_r+0x1ae>
  402182:	9b03      	ldr	r3, [sp, #12]
  402184:	1d1a      	adds	r2, r3, #4
  402186:	681b      	ldr	r3, [r3, #0]
  402188:	9203      	str	r2, [sp, #12]
  40218a:	2b00      	cmp	r3, #0
  40218c:	bfb8      	it	lt
  40218e:	f04f 33ff 	movlt.w	r3, #4294967295
  402192:	f108 0802 	add.w	r8, r8, #2
  402196:	9305      	str	r3, [sp, #20]
  402198:	4d31      	ldr	r5, [pc, #196]	; (402260 <_vfiprintf_r+0x21c>)
  40219a:	f898 1000 	ldrb.w	r1, [r8]
  40219e:	2203      	movs	r2, #3
  4021a0:	4628      	mov	r0, r5
  4021a2:	f000 fa95 	bl	4026d0 <memchr>
  4021a6:	b140      	cbz	r0, 4021ba <_vfiprintf_r+0x176>
  4021a8:	2340      	movs	r3, #64	; 0x40
  4021aa:	1b40      	subs	r0, r0, r5
  4021ac:	fa03 f000 	lsl.w	r0, r3, r0
  4021b0:	9b04      	ldr	r3, [sp, #16]
  4021b2:	4303      	orrs	r3, r0
  4021b4:	9304      	str	r3, [sp, #16]
  4021b6:	f108 0801 	add.w	r8, r8, #1
  4021ba:	f898 1000 	ldrb.w	r1, [r8]
  4021be:	4829      	ldr	r0, [pc, #164]	; (402264 <_vfiprintf_r+0x220>)
  4021c0:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  4021c4:	2206      	movs	r2, #6
  4021c6:	f108 0701 	add.w	r7, r8, #1
  4021ca:	f000 fa81 	bl	4026d0 <memchr>
  4021ce:	2800      	cmp	r0, #0
  4021d0:	d034      	beq.n	40223c <_vfiprintf_r+0x1f8>
  4021d2:	4b25      	ldr	r3, [pc, #148]	; (402268 <_vfiprintf_r+0x224>)
  4021d4:	bb03      	cbnz	r3, 402218 <_vfiprintf_r+0x1d4>
  4021d6:	9b03      	ldr	r3, [sp, #12]
  4021d8:	3307      	adds	r3, #7
  4021da:	f023 0307 	bic.w	r3, r3, #7
  4021de:	3308      	adds	r3, #8
  4021e0:	9303      	str	r3, [sp, #12]
  4021e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
  4021e4:	444b      	add	r3, r9
  4021e6:	9309      	str	r3, [sp, #36]	; 0x24
  4021e8:	e74c      	b.n	402084 <_vfiprintf_r+0x40>
  4021ea:	fb00 3202 	mla	r2, r0, r2, r3
  4021ee:	2101      	movs	r1, #1
  4021f0:	e786      	b.n	402100 <_vfiprintf_r+0xbc>
  4021f2:	2300      	movs	r3, #0
  4021f4:	9305      	str	r3, [sp, #20]
  4021f6:	4618      	mov	r0, r3
  4021f8:	250a      	movs	r5, #10
  4021fa:	4688      	mov	r8, r1
  4021fc:	3101      	adds	r1, #1
  4021fe:	f898 2000 	ldrb.w	r2, [r8]
  402202:	3a30      	subs	r2, #48	; 0x30
  402204:	2a09      	cmp	r2, #9
  402206:	d903      	bls.n	402210 <_vfiprintf_r+0x1cc>
  402208:	2b00      	cmp	r3, #0
  40220a:	d0c5      	beq.n	402198 <_vfiprintf_r+0x154>
  40220c:	9005      	str	r0, [sp, #20]
  40220e:	e7c3      	b.n	402198 <_vfiprintf_r+0x154>
  402210:	fb05 2000 	mla	r0, r5, r0, r2
  402214:	2301      	movs	r3, #1
  402216:	e7f0      	b.n	4021fa <_vfiprintf_r+0x1b6>
  402218:	ab03      	add	r3, sp, #12
  40221a:	9300      	str	r3, [sp, #0]
  40221c:	4622      	mov	r2, r4
  40221e:	4b13      	ldr	r3, [pc, #76]	; (40226c <_vfiprintf_r+0x228>)
  402220:	a904      	add	r1, sp, #16
  402222:	4630      	mov	r0, r6
  402224:	f3af 8000 	nop.w
  402228:	f1b0 3fff 	cmp.w	r0, #4294967295
  40222c:	4681      	mov	r9, r0
  40222e:	d1d8      	bne.n	4021e2 <_vfiprintf_r+0x19e>
  402230:	89a3      	ldrh	r3, [r4, #12]
  402232:	065b      	lsls	r3, r3, #25
  402234:	f53f af7d 	bmi.w	402132 <_vfiprintf_r+0xee>
  402238:	9809      	ldr	r0, [sp, #36]	; 0x24
  40223a:	e77c      	b.n	402136 <_vfiprintf_r+0xf2>
  40223c:	ab03      	add	r3, sp, #12
  40223e:	9300      	str	r3, [sp, #0]
  402240:	4622      	mov	r2, r4
  402242:	4b0a      	ldr	r3, [pc, #40]	; (40226c <_vfiprintf_r+0x228>)
  402244:	a904      	add	r1, sp, #16
  402246:	4630      	mov	r0, r6
  402248:	f000 f888 	bl	40235c <_printf_i>
  40224c:	e7ec      	b.n	402228 <_vfiprintf_r+0x1e4>
  40224e:	bf00      	nop
  402250:	00402914 	.word	0x00402914
  402254:	00402954 	.word	0x00402954
  402258:	00402934 	.word	0x00402934
  40225c:	004028f4 	.word	0x004028f4
  402260:	0040295a 	.word	0x0040295a
  402264:	0040295e 	.word	0x0040295e
  402268:	00000000 	.word	0x00000000
  40226c:	00402021 	.word	0x00402021

00402270 <_printf_common>:
  402270:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402274:	4691      	mov	r9, r2
  402276:	461f      	mov	r7, r3
  402278:	688a      	ldr	r2, [r1, #8]
  40227a:	690b      	ldr	r3, [r1, #16]
  40227c:	f8dd 8020 	ldr.w	r8, [sp, #32]
  402280:	4293      	cmp	r3, r2
  402282:	bfb8      	it	lt
  402284:	4613      	movlt	r3, r2
  402286:	f8c9 3000 	str.w	r3, [r9]
  40228a:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  40228e:	4606      	mov	r6, r0
  402290:	460c      	mov	r4, r1
  402292:	b112      	cbz	r2, 40229a <_printf_common+0x2a>
  402294:	3301      	adds	r3, #1
  402296:	f8c9 3000 	str.w	r3, [r9]
  40229a:	6823      	ldr	r3, [r4, #0]
  40229c:	0699      	lsls	r1, r3, #26
  40229e:	bf42      	ittt	mi
  4022a0:	f8d9 3000 	ldrmi.w	r3, [r9]
  4022a4:	3302      	addmi	r3, #2
  4022a6:	f8c9 3000 	strmi.w	r3, [r9]
  4022aa:	6825      	ldr	r5, [r4, #0]
  4022ac:	f015 0506 	ands.w	r5, r5, #6
  4022b0:	d107      	bne.n	4022c2 <_printf_common+0x52>
  4022b2:	f104 0a19 	add.w	sl, r4, #25
  4022b6:	68e3      	ldr	r3, [r4, #12]
  4022b8:	f8d9 2000 	ldr.w	r2, [r9]
  4022bc:	1a9b      	subs	r3, r3, r2
  4022be:	429d      	cmp	r5, r3
  4022c0:	db29      	blt.n	402316 <_printf_common+0xa6>
  4022c2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  4022c6:	6822      	ldr	r2, [r4, #0]
  4022c8:	3300      	adds	r3, #0
  4022ca:	bf18      	it	ne
  4022cc:	2301      	movne	r3, #1
  4022ce:	0692      	lsls	r2, r2, #26
  4022d0:	d42e      	bmi.n	402330 <_printf_common+0xc0>
  4022d2:	f104 0243 	add.w	r2, r4, #67	; 0x43
  4022d6:	4639      	mov	r1, r7
  4022d8:	4630      	mov	r0, r6
  4022da:	47c0      	blx	r8
  4022dc:	3001      	adds	r0, #1
  4022de:	d021      	beq.n	402324 <_printf_common+0xb4>
  4022e0:	6823      	ldr	r3, [r4, #0]
  4022e2:	68e5      	ldr	r5, [r4, #12]
  4022e4:	f8d9 2000 	ldr.w	r2, [r9]
  4022e8:	f003 0306 	and.w	r3, r3, #6
  4022ec:	2b04      	cmp	r3, #4
  4022ee:	bf08      	it	eq
  4022f0:	1aad      	subeq	r5, r5, r2
  4022f2:	68a3      	ldr	r3, [r4, #8]
  4022f4:	6922      	ldr	r2, [r4, #16]
  4022f6:	bf0c      	ite	eq
  4022f8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  4022fc:	2500      	movne	r5, #0
  4022fe:	4293      	cmp	r3, r2
  402300:	bfc4      	itt	gt
  402302:	1a9b      	subgt	r3, r3, r2
  402304:	18ed      	addgt	r5, r5, r3
  402306:	f04f 0900 	mov.w	r9, #0
  40230a:	341a      	adds	r4, #26
  40230c:	454d      	cmp	r5, r9
  40230e:	d11b      	bne.n	402348 <_printf_common+0xd8>
  402310:	2000      	movs	r0, #0
  402312:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402316:	2301      	movs	r3, #1
  402318:	4652      	mov	r2, sl
  40231a:	4639      	mov	r1, r7
  40231c:	4630      	mov	r0, r6
  40231e:	47c0      	blx	r8
  402320:	3001      	adds	r0, #1
  402322:	d103      	bne.n	40232c <_printf_common+0xbc>
  402324:	f04f 30ff 	mov.w	r0, #4294967295
  402328:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40232c:	3501      	adds	r5, #1
  40232e:	e7c2      	b.n	4022b6 <_printf_common+0x46>
  402330:	18e1      	adds	r1, r4, r3
  402332:	1c5a      	adds	r2, r3, #1
  402334:	2030      	movs	r0, #48	; 0x30
  402336:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  40233a:	4422      	add	r2, r4
  40233c:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  402340:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  402344:	3302      	adds	r3, #2
  402346:	e7c4      	b.n	4022d2 <_printf_common+0x62>
  402348:	2301      	movs	r3, #1
  40234a:	4622      	mov	r2, r4
  40234c:	4639      	mov	r1, r7
  40234e:	4630      	mov	r0, r6
  402350:	47c0      	blx	r8
  402352:	3001      	adds	r0, #1
  402354:	d0e6      	beq.n	402324 <_printf_common+0xb4>
  402356:	f109 0901 	add.w	r9, r9, #1
  40235a:	e7d7      	b.n	40230c <_printf_common+0x9c>

0040235c <_printf_i>:
  40235c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  402360:	4617      	mov	r7, r2
  402362:	7e0a      	ldrb	r2, [r1, #24]
  402364:	b085      	sub	sp, #20
  402366:	2a6e      	cmp	r2, #110	; 0x6e
  402368:	4698      	mov	r8, r3
  40236a:	4606      	mov	r6, r0
  40236c:	460c      	mov	r4, r1
  40236e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  402370:	f101 0e43 	add.w	lr, r1, #67	; 0x43
  402374:	f000 80bc 	beq.w	4024f0 <_printf_i+0x194>
  402378:	d81a      	bhi.n	4023b0 <_printf_i+0x54>
  40237a:	2a63      	cmp	r2, #99	; 0x63
  40237c:	d02e      	beq.n	4023dc <_printf_i+0x80>
  40237e:	d80a      	bhi.n	402396 <_printf_i+0x3a>
  402380:	2a00      	cmp	r2, #0
  402382:	f000 80c8 	beq.w	402516 <_printf_i+0x1ba>
  402386:	2a58      	cmp	r2, #88	; 0x58
  402388:	f000 808a 	beq.w	4024a0 <_printf_i+0x144>
  40238c:	f104 0542 	add.w	r5, r4, #66	; 0x42
  402390:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  402394:	e02a      	b.n	4023ec <_printf_i+0x90>
  402396:	2a64      	cmp	r2, #100	; 0x64
  402398:	d001      	beq.n	40239e <_printf_i+0x42>
  40239a:	2a69      	cmp	r2, #105	; 0x69
  40239c:	d1f6      	bne.n	40238c <_printf_i+0x30>
  40239e:	6821      	ldr	r1, [r4, #0]
  4023a0:	681a      	ldr	r2, [r3, #0]
  4023a2:	f011 0f80 	tst.w	r1, #128	; 0x80
  4023a6:	d023      	beq.n	4023f0 <_printf_i+0x94>
  4023a8:	1d11      	adds	r1, r2, #4
  4023aa:	6019      	str	r1, [r3, #0]
  4023ac:	6813      	ldr	r3, [r2, #0]
  4023ae:	e027      	b.n	402400 <_printf_i+0xa4>
  4023b0:	2a73      	cmp	r2, #115	; 0x73
  4023b2:	f000 80b4 	beq.w	40251e <_printf_i+0x1c2>
  4023b6:	d808      	bhi.n	4023ca <_printf_i+0x6e>
  4023b8:	2a6f      	cmp	r2, #111	; 0x6f
  4023ba:	d02a      	beq.n	402412 <_printf_i+0xb6>
  4023bc:	2a70      	cmp	r2, #112	; 0x70
  4023be:	d1e5      	bne.n	40238c <_printf_i+0x30>
  4023c0:	680a      	ldr	r2, [r1, #0]
  4023c2:	f042 0220 	orr.w	r2, r2, #32
  4023c6:	600a      	str	r2, [r1, #0]
  4023c8:	e003      	b.n	4023d2 <_printf_i+0x76>
  4023ca:	2a75      	cmp	r2, #117	; 0x75
  4023cc:	d021      	beq.n	402412 <_printf_i+0xb6>
  4023ce:	2a78      	cmp	r2, #120	; 0x78
  4023d0:	d1dc      	bne.n	40238c <_printf_i+0x30>
  4023d2:	2278      	movs	r2, #120	; 0x78
  4023d4:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
  4023d8:	496e      	ldr	r1, [pc, #440]	; (402594 <_printf_i+0x238>)
  4023da:	e064      	b.n	4024a6 <_printf_i+0x14a>
  4023dc:	681a      	ldr	r2, [r3, #0]
  4023de:	f101 0542 	add.w	r5, r1, #66	; 0x42
  4023e2:	1d11      	adds	r1, r2, #4
  4023e4:	6019      	str	r1, [r3, #0]
  4023e6:	6813      	ldr	r3, [r2, #0]
  4023e8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  4023ec:	2301      	movs	r3, #1
  4023ee:	e0a3      	b.n	402538 <_printf_i+0x1dc>
  4023f0:	f011 0f40 	tst.w	r1, #64	; 0x40
  4023f4:	f102 0104 	add.w	r1, r2, #4
  4023f8:	6019      	str	r1, [r3, #0]
  4023fa:	d0d7      	beq.n	4023ac <_printf_i+0x50>
  4023fc:	f9b2 3000 	ldrsh.w	r3, [r2]
  402400:	2b00      	cmp	r3, #0
  402402:	da03      	bge.n	40240c <_printf_i+0xb0>
  402404:	222d      	movs	r2, #45	; 0x2d
  402406:	425b      	negs	r3, r3
  402408:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
  40240c:	4962      	ldr	r1, [pc, #392]	; (402598 <_printf_i+0x23c>)
  40240e:	220a      	movs	r2, #10
  402410:	e017      	b.n	402442 <_printf_i+0xe6>
  402412:	6820      	ldr	r0, [r4, #0]
  402414:	6819      	ldr	r1, [r3, #0]
  402416:	f010 0f80 	tst.w	r0, #128	; 0x80
  40241a:	d003      	beq.n	402424 <_printf_i+0xc8>
  40241c:	1d08      	adds	r0, r1, #4
  40241e:	6018      	str	r0, [r3, #0]
  402420:	680b      	ldr	r3, [r1, #0]
  402422:	e006      	b.n	402432 <_printf_i+0xd6>
  402424:	f010 0f40 	tst.w	r0, #64	; 0x40
  402428:	f101 0004 	add.w	r0, r1, #4
  40242c:	6018      	str	r0, [r3, #0]
  40242e:	d0f7      	beq.n	402420 <_printf_i+0xc4>
  402430:	880b      	ldrh	r3, [r1, #0]
  402432:	4959      	ldr	r1, [pc, #356]	; (402598 <_printf_i+0x23c>)
  402434:	2a6f      	cmp	r2, #111	; 0x6f
  402436:	bf14      	ite	ne
  402438:	220a      	movne	r2, #10
  40243a:	2208      	moveq	r2, #8
  40243c:	2000      	movs	r0, #0
  40243e:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  402442:	6865      	ldr	r5, [r4, #4]
  402444:	60a5      	str	r5, [r4, #8]
  402446:	2d00      	cmp	r5, #0
  402448:	f2c0 809c 	blt.w	402584 <_printf_i+0x228>
  40244c:	6820      	ldr	r0, [r4, #0]
  40244e:	f020 0004 	bic.w	r0, r0, #4
  402452:	6020      	str	r0, [r4, #0]
  402454:	2b00      	cmp	r3, #0
  402456:	d13f      	bne.n	4024d8 <_printf_i+0x17c>
  402458:	2d00      	cmp	r5, #0
  40245a:	f040 8095 	bne.w	402588 <_printf_i+0x22c>
  40245e:	4675      	mov	r5, lr
  402460:	2a08      	cmp	r2, #8
  402462:	d10b      	bne.n	40247c <_printf_i+0x120>
  402464:	6823      	ldr	r3, [r4, #0]
  402466:	07da      	lsls	r2, r3, #31
  402468:	d508      	bpl.n	40247c <_printf_i+0x120>
  40246a:	6923      	ldr	r3, [r4, #16]
  40246c:	6862      	ldr	r2, [r4, #4]
  40246e:	429a      	cmp	r2, r3
  402470:	bfde      	ittt	le
  402472:	2330      	movle	r3, #48	; 0x30
  402474:	f805 3c01 	strble.w	r3, [r5, #-1]
  402478:	f105 35ff 	addle.w	r5, r5, #4294967295
  40247c:	ebae 0305 	sub.w	r3, lr, r5
  402480:	6123      	str	r3, [r4, #16]
  402482:	f8cd 8000 	str.w	r8, [sp]
  402486:	463b      	mov	r3, r7
  402488:	aa03      	add	r2, sp, #12
  40248a:	4621      	mov	r1, r4
  40248c:	4630      	mov	r0, r6
  40248e:	f7ff feef 	bl	402270 <_printf_common>
  402492:	3001      	adds	r0, #1
  402494:	d155      	bne.n	402542 <_printf_i+0x1e6>
  402496:	f04f 30ff 	mov.w	r0, #4294967295
  40249a:	b005      	add	sp, #20
  40249c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4024a0:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
  4024a4:	493c      	ldr	r1, [pc, #240]	; (402598 <_printf_i+0x23c>)
  4024a6:	6822      	ldr	r2, [r4, #0]
  4024a8:	6818      	ldr	r0, [r3, #0]
  4024aa:	f012 0f80 	tst.w	r2, #128	; 0x80
  4024ae:	f100 0504 	add.w	r5, r0, #4
  4024b2:	601d      	str	r5, [r3, #0]
  4024b4:	d001      	beq.n	4024ba <_printf_i+0x15e>
  4024b6:	6803      	ldr	r3, [r0, #0]
  4024b8:	e002      	b.n	4024c0 <_printf_i+0x164>
  4024ba:	0655      	lsls	r5, r2, #25
  4024bc:	d5fb      	bpl.n	4024b6 <_printf_i+0x15a>
  4024be:	8803      	ldrh	r3, [r0, #0]
  4024c0:	07d0      	lsls	r0, r2, #31
  4024c2:	bf44      	itt	mi
  4024c4:	f042 0220 	orrmi.w	r2, r2, #32
  4024c8:	6022      	strmi	r2, [r4, #0]
  4024ca:	b91b      	cbnz	r3, 4024d4 <_printf_i+0x178>
  4024cc:	6822      	ldr	r2, [r4, #0]
  4024ce:	f022 0220 	bic.w	r2, r2, #32
  4024d2:	6022      	str	r2, [r4, #0]
  4024d4:	2210      	movs	r2, #16
  4024d6:	e7b1      	b.n	40243c <_printf_i+0xe0>
  4024d8:	4675      	mov	r5, lr
  4024da:	fbb3 f0f2 	udiv	r0, r3, r2
  4024de:	fb02 3310 	mls	r3, r2, r0, r3
  4024e2:	5ccb      	ldrb	r3, [r1, r3]
  4024e4:	f805 3d01 	strb.w	r3, [r5, #-1]!
  4024e8:	4603      	mov	r3, r0
  4024ea:	2800      	cmp	r0, #0
  4024ec:	d1f5      	bne.n	4024da <_printf_i+0x17e>
  4024ee:	e7b7      	b.n	402460 <_printf_i+0x104>
  4024f0:	6808      	ldr	r0, [r1, #0]
  4024f2:	681a      	ldr	r2, [r3, #0]
  4024f4:	6949      	ldr	r1, [r1, #20]
  4024f6:	f010 0f80 	tst.w	r0, #128	; 0x80
  4024fa:	d004      	beq.n	402506 <_printf_i+0x1aa>
  4024fc:	1d10      	adds	r0, r2, #4
  4024fe:	6018      	str	r0, [r3, #0]
  402500:	6813      	ldr	r3, [r2, #0]
  402502:	6019      	str	r1, [r3, #0]
  402504:	e007      	b.n	402516 <_printf_i+0x1ba>
  402506:	f010 0f40 	tst.w	r0, #64	; 0x40
  40250a:	f102 0004 	add.w	r0, r2, #4
  40250e:	6018      	str	r0, [r3, #0]
  402510:	6813      	ldr	r3, [r2, #0]
  402512:	d0f6      	beq.n	402502 <_printf_i+0x1a6>
  402514:	8019      	strh	r1, [r3, #0]
  402516:	2300      	movs	r3, #0
  402518:	6123      	str	r3, [r4, #16]
  40251a:	4675      	mov	r5, lr
  40251c:	e7b1      	b.n	402482 <_printf_i+0x126>
  40251e:	681a      	ldr	r2, [r3, #0]
  402520:	1d11      	adds	r1, r2, #4
  402522:	6019      	str	r1, [r3, #0]
  402524:	6815      	ldr	r5, [r2, #0]
  402526:	6862      	ldr	r2, [r4, #4]
  402528:	2100      	movs	r1, #0
  40252a:	4628      	mov	r0, r5
  40252c:	f000 f8d0 	bl	4026d0 <memchr>
  402530:	b108      	cbz	r0, 402536 <_printf_i+0x1da>
  402532:	1b40      	subs	r0, r0, r5
  402534:	6060      	str	r0, [r4, #4]
  402536:	6863      	ldr	r3, [r4, #4]
  402538:	6123      	str	r3, [r4, #16]
  40253a:	2300      	movs	r3, #0
  40253c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  402540:	e79f      	b.n	402482 <_printf_i+0x126>
  402542:	6923      	ldr	r3, [r4, #16]
  402544:	462a      	mov	r2, r5
  402546:	4639      	mov	r1, r7
  402548:	4630      	mov	r0, r6
  40254a:	47c0      	blx	r8
  40254c:	3001      	adds	r0, #1
  40254e:	d0a2      	beq.n	402496 <_printf_i+0x13a>
  402550:	6823      	ldr	r3, [r4, #0]
  402552:	079b      	lsls	r3, r3, #30
  402554:	d507      	bpl.n	402566 <_printf_i+0x20a>
  402556:	2500      	movs	r5, #0
  402558:	f104 0919 	add.w	r9, r4, #25
  40255c:	68e3      	ldr	r3, [r4, #12]
  40255e:	9a03      	ldr	r2, [sp, #12]
  402560:	1a9b      	subs	r3, r3, r2
  402562:	429d      	cmp	r5, r3
  402564:	db05      	blt.n	402572 <_printf_i+0x216>
  402566:	68e0      	ldr	r0, [r4, #12]
  402568:	9b03      	ldr	r3, [sp, #12]
  40256a:	4298      	cmp	r0, r3
  40256c:	bfb8      	it	lt
  40256e:	4618      	movlt	r0, r3
  402570:	e793      	b.n	40249a <_printf_i+0x13e>
  402572:	2301      	movs	r3, #1
  402574:	464a      	mov	r2, r9
  402576:	4639      	mov	r1, r7
  402578:	4630      	mov	r0, r6
  40257a:	47c0      	blx	r8
  40257c:	3001      	adds	r0, #1
  40257e:	d08a      	beq.n	402496 <_printf_i+0x13a>
  402580:	3501      	adds	r5, #1
  402582:	e7eb      	b.n	40255c <_printf_i+0x200>
  402584:	2b00      	cmp	r3, #0
  402586:	d1a7      	bne.n	4024d8 <_printf_i+0x17c>
  402588:	780b      	ldrb	r3, [r1, #0]
  40258a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  40258e:	f104 0542 	add.w	r5, r4, #66	; 0x42
  402592:	e765      	b.n	402460 <_printf_i+0x104>
  402594:	00402976 	.word	0x00402976
  402598:	00402965 	.word	0x00402965

0040259c <__sread>:
  40259c:	b510      	push	{r4, lr}
  40259e:	460c      	mov	r4, r1
  4025a0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4025a4:	f000 f8e4 	bl	402770 <_read_r>
  4025a8:	2800      	cmp	r0, #0
  4025aa:	bfab      	itete	ge
  4025ac:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  4025ae:	89a3      	ldrhlt	r3, [r4, #12]
  4025b0:	181b      	addge	r3, r3, r0
  4025b2:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  4025b6:	bfac      	ite	ge
  4025b8:	6563      	strge	r3, [r4, #84]	; 0x54
  4025ba:	81a3      	strhlt	r3, [r4, #12]
  4025bc:	bd10      	pop	{r4, pc}

004025be <__swrite>:
  4025be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4025c2:	461f      	mov	r7, r3
  4025c4:	898b      	ldrh	r3, [r1, #12]
  4025c6:	05db      	lsls	r3, r3, #23
  4025c8:	4605      	mov	r5, r0
  4025ca:	460c      	mov	r4, r1
  4025cc:	4616      	mov	r6, r2
  4025ce:	d505      	bpl.n	4025dc <__swrite+0x1e>
  4025d0:	2302      	movs	r3, #2
  4025d2:	2200      	movs	r2, #0
  4025d4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4025d8:	f000 f868 	bl	4026ac <_lseek_r>
  4025dc:	89a3      	ldrh	r3, [r4, #12]
  4025de:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  4025e2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  4025e6:	81a3      	strh	r3, [r4, #12]
  4025e8:	4632      	mov	r2, r6
  4025ea:	463b      	mov	r3, r7
  4025ec:	4628      	mov	r0, r5
  4025ee:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4025f2:	f000 b817 	b.w	402624 <_write_r>

004025f6 <__sseek>:
  4025f6:	b510      	push	{r4, lr}
  4025f8:	460c      	mov	r4, r1
  4025fa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4025fe:	f000 f855 	bl	4026ac <_lseek_r>
  402602:	1c43      	adds	r3, r0, #1
  402604:	89a3      	ldrh	r3, [r4, #12]
  402606:	bf15      	itete	ne
  402608:	6560      	strne	r0, [r4, #84]	; 0x54
  40260a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40260e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  402612:	81a3      	strheq	r3, [r4, #12]
  402614:	bf18      	it	ne
  402616:	81a3      	strhne	r3, [r4, #12]
  402618:	bd10      	pop	{r4, pc}

0040261a <__sclose>:
  40261a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40261e:	f000 b813 	b.w	402648 <_close_r>
	...

00402624 <_write_r>:
  402624:	b538      	push	{r3, r4, r5, lr}
  402626:	4c07      	ldr	r4, [pc, #28]	; (402644 <_write_r+0x20>)
  402628:	4605      	mov	r5, r0
  40262a:	4608      	mov	r0, r1
  40262c:	4611      	mov	r1, r2
  40262e:	2200      	movs	r2, #0
  402630:	6022      	str	r2, [r4, #0]
  402632:	461a      	mov	r2, r3
  402634:	f7ff f820 	bl	401678 <_write>
  402638:	1c43      	adds	r3, r0, #1
  40263a:	d102      	bne.n	402642 <_write_r+0x1e>
  40263c:	6823      	ldr	r3, [r4, #0]
  40263e:	b103      	cbz	r3, 402642 <_write_r+0x1e>
  402640:	602b      	str	r3, [r5, #0]
  402642:	bd38      	pop	{r3, r4, r5, pc}
  402644:	204000f0 	.word	0x204000f0

00402648 <_close_r>:
  402648:	b538      	push	{r3, r4, r5, lr}
  40264a:	4c06      	ldr	r4, [pc, #24]	; (402664 <_close_r+0x1c>)
  40264c:	2300      	movs	r3, #0
  40264e:	4605      	mov	r5, r0
  402650:	4608      	mov	r0, r1
  402652:	6023      	str	r3, [r4, #0]
  402654:	f7fe f9b0 	bl	4009b8 <_close>
  402658:	1c43      	adds	r3, r0, #1
  40265a:	d102      	bne.n	402662 <_close_r+0x1a>
  40265c:	6823      	ldr	r3, [r4, #0]
  40265e:	b103      	cbz	r3, 402662 <_close_r+0x1a>
  402660:	602b      	str	r3, [r5, #0]
  402662:	bd38      	pop	{r3, r4, r5, pc}
  402664:	204000f0 	.word	0x204000f0

00402668 <_fstat_r>:
  402668:	b538      	push	{r3, r4, r5, lr}
  40266a:	4c07      	ldr	r4, [pc, #28]	; (402688 <_fstat_r+0x20>)
  40266c:	2300      	movs	r3, #0
  40266e:	4605      	mov	r5, r0
  402670:	4608      	mov	r0, r1
  402672:	4611      	mov	r1, r2
  402674:	6023      	str	r3, [r4, #0]
  402676:	f7fe f9a2 	bl	4009be <_fstat>
  40267a:	1c43      	adds	r3, r0, #1
  40267c:	d102      	bne.n	402684 <_fstat_r+0x1c>
  40267e:	6823      	ldr	r3, [r4, #0]
  402680:	b103      	cbz	r3, 402684 <_fstat_r+0x1c>
  402682:	602b      	str	r3, [r5, #0]
  402684:	bd38      	pop	{r3, r4, r5, pc}
  402686:	bf00      	nop
  402688:	204000f0 	.word	0x204000f0

0040268c <_isatty_r>:
  40268c:	b538      	push	{r3, r4, r5, lr}
  40268e:	4c06      	ldr	r4, [pc, #24]	; (4026a8 <_isatty_r+0x1c>)
  402690:	2300      	movs	r3, #0
  402692:	4605      	mov	r5, r0
  402694:	4608      	mov	r0, r1
  402696:	6023      	str	r3, [r4, #0]
  402698:	f7fe f996 	bl	4009c8 <_isatty>
  40269c:	1c43      	adds	r3, r0, #1
  40269e:	d102      	bne.n	4026a6 <_isatty_r+0x1a>
  4026a0:	6823      	ldr	r3, [r4, #0]
  4026a2:	b103      	cbz	r3, 4026a6 <_isatty_r+0x1a>
  4026a4:	602b      	str	r3, [r5, #0]
  4026a6:	bd38      	pop	{r3, r4, r5, pc}
  4026a8:	204000f0 	.word	0x204000f0

004026ac <_lseek_r>:
  4026ac:	b538      	push	{r3, r4, r5, lr}
  4026ae:	4c07      	ldr	r4, [pc, #28]	; (4026cc <_lseek_r+0x20>)
  4026b0:	4605      	mov	r5, r0
  4026b2:	4608      	mov	r0, r1
  4026b4:	4611      	mov	r1, r2
  4026b6:	2200      	movs	r2, #0
  4026b8:	6022      	str	r2, [r4, #0]
  4026ba:	461a      	mov	r2, r3
  4026bc:	f7fe f986 	bl	4009cc <_lseek>
  4026c0:	1c43      	adds	r3, r0, #1
  4026c2:	d102      	bne.n	4026ca <_lseek_r+0x1e>
  4026c4:	6823      	ldr	r3, [r4, #0]
  4026c6:	b103      	cbz	r3, 4026ca <_lseek_r+0x1e>
  4026c8:	602b      	str	r3, [r5, #0]
  4026ca:	bd38      	pop	{r3, r4, r5, pc}
  4026cc:	204000f0 	.word	0x204000f0

004026d0 <memchr>:
  4026d0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  4026d4:	2a10      	cmp	r2, #16
  4026d6:	db2b      	blt.n	402730 <memchr+0x60>
  4026d8:	f010 0f07 	tst.w	r0, #7
  4026dc:	d008      	beq.n	4026f0 <memchr+0x20>
  4026de:	f810 3b01 	ldrb.w	r3, [r0], #1
  4026e2:	3a01      	subs	r2, #1
  4026e4:	428b      	cmp	r3, r1
  4026e6:	d02d      	beq.n	402744 <memchr+0x74>
  4026e8:	f010 0f07 	tst.w	r0, #7
  4026ec:	b342      	cbz	r2, 402740 <memchr+0x70>
  4026ee:	d1f6      	bne.n	4026de <memchr+0xe>
  4026f0:	b4f0      	push	{r4, r5, r6, r7}
  4026f2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  4026f6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  4026fa:	f022 0407 	bic.w	r4, r2, #7
  4026fe:	f07f 0700 	mvns.w	r7, #0
  402702:	2300      	movs	r3, #0
  402704:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  402708:	3c08      	subs	r4, #8
  40270a:	ea85 0501 	eor.w	r5, r5, r1
  40270e:	ea86 0601 	eor.w	r6, r6, r1
  402712:	fa85 f547 	uadd8	r5, r5, r7
  402716:	faa3 f587 	sel	r5, r3, r7
  40271a:	fa86 f647 	uadd8	r6, r6, r7
  40271e:	faa5 f687 	sel	r6, r5, r7
  402722:	b98e      	cbnz	r6, 402748 <memchr+0x78>
  402724:	d1ee      	bne.n	402704 <memchr+0x34>
  402726:	bcf0      	pop	{r4, r5, r6, r7}
  402728:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  40272c:	f002 0207 	and.w	r2, r2, #7
  402730:	b132      	cbz	r2, 402740 <memchr+0x70>
  402732:	f810 3b01 	ldrb.w	r3, [r0], #1
  402736:	3a01      	subs	r2, #1
  402738:	ea83 0301 	eor.w	r3, r3, r1
  40273c:	b113      	cbz	r3, 402744 <memchr+0x74>
  40273e:	d1f8      	bne.n	402732 <memchr+0x62>
  402740:	2000      	movs	r0, #0
  402742:	4770      	bx	lr
  402744:	3801      	subs	r0, #1
  402746:	4770      	bx	lr
  402748:	2d00      	cmp	r5, #0
  40274a:	bf06      	itte	eq
  40274c:	4635      	moveq	r5, r6
  40274e:	3803      	subeq	r0, #3
  402750:	3807      	subne	r0, #7
  402752:	f015 0f01 	tst.w	r5, #1
  402756:	d107      	bne.n	402768 <memchr+0x98>
  402758:	3001      	adds	r0, #1
  40275a:	f415 7f80 	tst.w	r5, #256	; 0x100
  40275e:	bf02      	ittt	eq
  402760:	3001      	addeq	r0, #1
  402762:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  402766:	3001      	addeq	r0, #1
  402768:	bcf0      	pop	{r4, r5, r6, r7}
  40276a:	3801      	subs	r0, #1
  40276c:	4770      	bx	lr
  40276e:	bf00      	nop

00402770 <_read_r>:
  402770:	b538      	push	{r3, r4, r5, lr}
  402772:	4c07      	ldr	r4, [pc, #28]	; (402790 <_read_r+0x20>)
  402774:	4605      	mov	r5, r0
  402776:	4608      	mov	r0, r1
  402778:	4611      	mov	r1, r2
  40277a:	2200      	movs	r2, #0
  40277c:	6022      	str	r2, [r4, #0]
  40277e:	461a      	mov	r2, r3
  402780:	f7fe ff68 	bl	401654 <_read>
  402784:	1c43      	adds	r3, r0, #1
  402786:	d102      	bne.n	40278e <_read_r+0x1e>
  402788:	6823      	ldr	r3, [r4, #0]
  40278a:	b103      	cbz	r3, 40278e <_read_r+0x1e>
  40278c:	602b      	str	r3, [r5, #0]
  40278e:	bd38      	pop	{r3, r4, r5, pc}
  402790:	204000f0 	.word	0x204000f0
  402794:	682f2e2e 	.word	0x682f2e2e
  402798:	732f6c61 	.word	0x732f6c61
  40279c:	682f6372 	.word	0x682f6372
  4027a0:	695f6c61 	.word	0x695f6c61
  4027a4:	6d5f6332 	.word	0x6d5f6332
  4027a8:	6e79735f 	.word	0x6e79735f
  4027ac:	00632e63 	.word	0x00632e63
  4027b0:	682f2e2e 	.word	0x682f2e2e
  4027b4:	732f6c61 	.word	0x732f6c61
  4027b8:	682f6372 	.word	0x682f6372
  4027bc:	695f6c61 	.word	0x695f6c61
  4027c0:	00632e6f 	.word	0x00632e6f
  4027c4:	682f2e2e 	.word	0x682f2e2e
  4027c8:	732f6c61 	.word	0x732f6c61
  4027cc:	682f6372 	.word	0x682f6372
  4027d0:	735f6c61 	.word	0x735f6c61
  4027d4:	6d5f6970 	.word	0x6d5f6970
  4027d8:	6e79735f 	.word	0x6e79735f
  4027dc:	00632e63 	.word	0x00632e63
  4027e0:	682f2e2e 	.word	0x682f2e2e
  4027e4:	732f6c61 	.word	0x732f6c61
  4027e8:	682f6372 	.word	0x682f6372
  4027ec:	755f6c61 	.word	0x755f6c61
  4027f0:	74726173 	.word	0x74726173
  4027f4:	6e79735f 	.word	0x6e79735f
  4027f8:	00632e63 	.word	0x00632e63

004027fc <_ext_irq>:
  4027fc:	00000000 00000020 00000020 00000020     .... ... ... ...
	...
  402814:	00000020 00000001 00000002 00000002      ...............
  402824:	00000002 00000000 00000000 00000002     ................

00402834 <_pio_irq_n>:
  402834:	100c0b0a 00000011 682f2e2e 702f6c70     ........../hpl/p
  402844:	682f6f69 705f6c70 655f6f69 632e7478     io/hpl_pio_ext.c
  402854:	00000000                                ....

00402858 <spi_regs>:
  402858:	00000000 80000000 00000001 0496fa02     ................
  402868:	0000ffff 682f2e2e 732f6c70 682f6970     ....../hpl/spi/h
  402878:	735f6c70 632e6970 00000000              pl_spi.c....

00402884 <_i2cm_sync_cfgs>:
  402884:	40018000 00000020 00000000 00000000     ...@ ...........
  402894:	0002baba 000249f0 682f2e2e 742f6c70     .....I..../hpl/t
  4028a4:	73686977 6c70682f 6977745f 632e7368     wihs/hpl_twihs.c
  4028b4:	00000000                                ....

004028b8 <_usarts>:
  4028b8:	00000001 001008c0 000100f4 682f2e2e     ............../h
  4028c8:	752f6c70 74726173 6c70682f 6173755f     pl/usart/hpl_usa
  4028d8:	632e7472 00000000 0a0d7325 00000000     rt.c....%s......
  4028e8:	bbccddee 000000aa                       ........

004028f0 <_global_impure_ptr>:
  4028f0:	20400004                                ..@ 

004028f4 <__sf_fake_stderr>:
	...

00402914 <__sf_fake_stdin>:
	...

00402934 <__sf_fake_stdout>:
	...
  402954:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
  402964:	32313000 36353433 41393837 45444342     .0123456789ABCDE
  402974:	31300046 35343332 39383736 64636261     F.0123456789abcd
  402984:	00006665                                ef..

00402988 <_init>:
  402988:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40298a:	bf00      	nop
  40298c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40298e:	bc08      	pop	{r3}
  402990:	469e      	mov	lr, r3
  402992:	4770      	bx	lr

00402994 <__init_array_start>:
  402994:	0040018d 	.word	0x0040018d

00402998 <_fini>:
  402998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40299a:	bf00      	nop
  40299c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40299e:	bc08      	pop	{r3}
  4029a0:	469e      	mov	lr, r3
  4029a2:	4770      	bx	lr

004029a4 <__fini_array_start>:
  4029a4:	00400169 	.word	0x00400169
