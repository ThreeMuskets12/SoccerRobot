
RobotFirmwarev12.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002eb8  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000064  20400000  00402eb8  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000c0  20400064  00402f1c  00020064  2**2
                  ALLOC
  3 .heap         00000204  20400124  00402fdc  00020064  2**0
                  ALLOC
  4 .stack        00000400  20400328  004031e0  00020064  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020064  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020092  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001bb4b  00000000  00000000  000200eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003d1f  00000000  00000000  0003bc36  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00009df0  00000000  00000000  0003f955  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000bf0  00000000  00000000  00049745  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000ac8  00000000  00000000  0004a335  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00043906  00000000  00000000  0004adfd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00018908  00000000  00000000  0008e703  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00150e9f  00000000  00000000  000a700b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000025f0  00000000  00000000  001f7eac  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	28 07 40 20 ed 01 40 00 e9 01 40 00 e9 01 40 00     (.@ ..@...@...@.
  400010:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e9 01 40 00 e9 01 40 00 00 00 00 00 e9 01 40 00     ..@...@.......@.
  40003c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40004c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40005c:	e9 01 40 00 e9 01 40 00 00 00 00 00 f5 0d 40 00     ..@...@.......@.
  40006c:	e9 0d 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40007c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40008c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40009c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ac:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000bc:	8d 0f 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000cc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000dc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ec:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000fc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40010c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ......@...@...@.
  40012c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40013c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40014c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40015c:	e9 01 40 00 e9 01 40 00 e9 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400064 	.word	0x20400064
  400184:	00000000 	.word	0x00000000
  400188:	00402eb8 	.word	0x00402eb8

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	00402eb8 	.word	0x00402eb8
  4001c8:	20400068 	.word	0x20400068
  4001cc:	00402eb8 	.word	0x00402eb8
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b02      	ldr	r3, [pc, #8]	; (4001e0 <atmel_start_init+0xc>)
  4001d8:	4798      	blx	r3
	stdio_redirect_init();
  4001da:	4b02      	ldr	r3, [pc, #8]	; (4001e4 <atmel_start_init+0x10>)
  4001dc:	4798      	blx	r3
  4001de:	bd08      	pop	{r3, pc}
  4001e0:	004004a9 	.word	0x004004a9
  4001e4:	00401ad9 	.word	0x00401ad9

004001e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e8:	e7fe      	b.n	4001e8 <Dummy_Handler>
	...

004001ec <Reset_Handler>:
{
  4001ec:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001ee:	4b10      	ldr	r3, [pc, #64]	; (400230 <Reset_Handler+0x44>)
  4001f0:	4a10      	ldr	r2, [pc, #64]	; (400234 <Reset_Handler+0x48>)
  4001f2:	429a      	cmp	r2, r3
  4001f4:	d009      	beq.n	40020a <Reset_Handler+0x1e>
  4001f6:	4b0e      	ldr	r3, [pc, #56]	; (400230 <Reset_Handler+0x44>)
  4001f8:	4a0e      	ldr	r2, [pc, #56]	; (400234 <Reset_Handler+0x48>)
  4001fa:	e003      	b.n	400204 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001fc:	6811      	ldr	r1, [r2, #0]
  4001fe:	6019      	str	r1, [r3, #0]
  400200:	3304      	adds	r3, #4
  400202:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  400204:	490c      	ldr	r1, [pc, #48]	; (400238 <Reset_Handler+0x4c>)
  400206:	428b      	cmp	r3, r1
  400208:	d3f8      	bcc.n	4001fc <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  40020a:	4b0c      	ldr	r3, [pc, #48]	; (40023c <Reset_Handler+0x50>)
  40020c:	e002      	b.n	400214 <Reset_Handler+0x28>
                *pDest++ = 0;
  40020e:	2200      	movs	r2, #0
  400210:	601a      	str	r2, [r3, #0]
  400212:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  400214:	4a0a      	ldr	r2, [pc, #40]	; (400240 <Reset_Handler+0x54>)
  400216:	4293      	cmp	r3, r2
  400218:	d3f9      	bcc.n	40020e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40021a:	4a0a      	ldr	r2, [pc, #40]	; (400244 <Reset_Handler+0x58>)
  40021c:	4b0a      	ldr	r3, [pc, #40]	; (400248 <Reset_Handler+0x5c>)
  40021e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400222:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  400224:	4b09      	ldr	r3, [pc, #36]	; (40024c <Reset_Handler+0x60>)
  400226:	4798      	blx	r3
        main();
  400228:	4b09      	ldr	r3, [pc, #36]	; (400250 <Reset_Handler+0x64>)
  40022a:	4798      	blx	r3
  40022c:	e7fe      	b.n	40022c <Reset_Handler+0x40>
  40022e:	bf00      	nop
  400230:	20400000 	.word	0x20400000
  400234:	00402eb8 	.word	0x00402eb8
  400238:	20400064 	.word	0x20400064
  40023c:	20400064 	.word	0x20400064
  400240:	20400124 	.word	0x20400124
  400244:	e000ed00 	.word	0xe000ed00
  400248:	00400000 	.word	0x00400000
  40024c:	00401af9 	.word	0x00401af9
  400250:	0040173d 	.word	0x0040173d

00400254 <EXTERNAL_IRQ_1_init>:
	((Pio *)hw)->PIO_ODR = ~data;
}

static inline void hri_pio_clear_OSR_reg(const void *const hw, hri_pio_osr_reg_t mask)
{
	((Pio *)hw)->PIO_ODR = mask;
  400254:	4b03      	ldr	r3, [pc, #12]	; (400264 <EXTERNAL_IRQ_1_init+0x10>)
  400256:	2202      	movs	r2, #2
  400258:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = ~data;
}

static inline void hri_pio_clear_PUSR_reg(const void *const hw, hri_pio_pusr_reg_t mask)
{
	((Pio *)hw)->PIO_PUDR = mask;
  40025a:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = ~data;
}

static inline void hri_pio_clear_PPDSR_reg(const void *const hw, hri_pio_ppdsr_reg_t mask)
{
	((Pio *)hw)->PIO_PPDDR = mask;
  40025c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400260:	601a      	str	r2, [r3, #0]
  400262:	4770      	bx	lr
  400264:	400e1000 	.word	0x400e1000

00400268 <EXTERNAL_IRQ_0_init>:
	((Pio *)hw)->PIO_ODR = mask;
  400268:	4b03      	ldr	r3, [pc, #12]	; (400278 <EXTERNAL_IRQ_0_init+0x10>)
  40026a:	2220      	movs	r2, #32
  40026c:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40026e:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400270:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400274:	601a      	str	r2, [r3, #0]
  400276:	4770      	bx	lr
  400278:	400e0e00 	.word	0x400e0e00

0040027c <PWM_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40027c:	4b06      	ldr	r3, [pc, #24]	; (400298 <PWM_0_PORT_init+0x1c>)
  40027e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400280:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  400284:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
  40028c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40028e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400292:	605a      	str	r2, [r3, #4]
  400294:	4770      	bx	lr
  400296:	bf00      	nop
  400298:	400e1400 	.word	0x400e1400

0040029c <PWM_0_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40029c:	4b04      	ldr	r3, [pc, #16]	; (4002b0 <PWM_0_CLOCK_init+0x14>)
  40029e:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4002a0:	2b00      	cmp	r3, #0
  4002a2:	db03      	blt.n	4002ac <PWM_0_CLOCK_init+0x10>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002a4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  4002a8:	4b01      	ldr	r3, [pc, #4]	; (4002b0 <PWM_0_CLOCK_init+0x14>)
  4002aa:	611a      	str	r2, [r3, #16]
  4002ac:	4770      	bx	lr
  4002ae:	bf00      	nop
  4002b0:	400e0600 	.word	0x400e0600

004002b4 <PWM_0_init>:
{
	_pmc_enable_periph_clock(ID_PWM0);
}

void PWM_0_init(void)
{
  4002b4:	b508      	push	{r3, lr}
	PWM_0_CLOCK_init();
  4002b6:	4b06      	ldr	r3, [pc, #24]	; (4002d0 <PWM_0_init+0x1c>)
  4002b8:	4798      	blx	r3
	PWM_0_PORT_init();
  4002ba:	4b06      	ldr	r3, [pc, #24]	; (4002d4 <PWM_0_init+0x20>)
  4002bc:	4798      	blx	r3
	pwm_init(&PWM_0, PWM0, _pwm_get_pwm());
  4002be:	4b06      	ldr	r3, [pc, #24]	; (4002d8 <PWM_0_init+0x24>)
  4002c0:	4798      	blx	r3
  4002c2:	4602      	mov	r2, r0
  4002c4:	4905      	ldr	r1, [pc, #20]	; (4002dc <PWM_0_init+0x28>)
  4002c6:	4806      	ldr	r0, [pc, #24]	; (4002e0 <PWM_0_init+0x2c>)
  4002c8:	4b06      	ldr	r3, [pc, #24]	; (4002e4 <PWM_0_init+0x30>)
  4002ca:	4798      	blx	r3
  4002cc:	bd08      	pop	{r3, pc}
  4002ce:	bf00      	nop
  4002d0:	0040029d 	.word	0x0040029d
  4002d4:	0040027d 	.word	0x0040027d
  4002d8:	004010d9 	.word	0x004010d9
  4002dc:	40020000 	.word	0x40020000
  4002e0:	204000b8 	.word	0x204000b8
  4002e4:	00400825 	.word	0x00400825

004002e8 <SPI_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4002e8:	4b11      	ldr	r3, [pc, #68]	; (400330 <SPI_0_PORT_init+0x48>)
  4002ea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002ec:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  4002f0:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4002f2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002f4:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  4002f8:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002fa:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  4002fe:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400300:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400302:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  400306:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400308:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40030a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  40030e:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400310:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400314:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400316:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400318:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  40031c:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40031e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400320:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  400324:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400326:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  40032a:	605a      	str	r2, [r3, #4]
  40032c:	4770      	bx	lr
  40032e:	bf00      	nop
  400330:	400e1400 	.word	0x400e1400

00400334 <SPI_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400334:	4b04      	ldr	r3, [pc, #16]	; (400348 <SPI_0_CLOCK_init+0x14>)
  400336:	699b      	ldr	r3, [r3, #24]
  400338:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  40033c:	d103      	bne.n	400346 <SPI_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40033e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400342:	4b01      	ldr	r3, [pc, #4]	; (400348 <SPI_0_CLOCK_init+0x14>)
  400344:	611a      	str	r2, [r3, #16]
  400346:	4770      	bx	lr
  400348:	400e0600 	.word	0x400e0600

0040034c <SPI_0_init>:
{
	_pmc_enable_periph_clock(ID_SPI0);
}

void SPI_0_init(void)
{
  40034c:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
  40034e:	4b08      	ldr	r3, [pc, #32]	; (400370 <SPI_0_init+0x24>)
  400350:	4798      	blx	r3
	spi_m_sync_set_func_ptr(&SPI_0, _spi_get_spi_m_sync());
  400352:	4b08      	ldr	r3, [pc, #32]	; (400374 <SPI_0_init+0x28>)
  400354:	4798      	blx	r3
  400356:	4c08      	ldr	r4, [pc, #32]	; (400378 <SPI_0_init+0x2c>)
  400358:	4601      	mov	r1, r0
  40035a:	4620      	mov	r0, r4
  40035c:	4b07      	ldr	r3, [pc, #28]	; (40037c <SPI_0_init+0x30>)
  40035e:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SPI0);
  400360:	4907      	ldr	r1, [pc, #28]	; (400380 <SPI_0_init+0x34>)
  400362:	4620      	mov	r0, r4
  400364:	4b07      	ldr	r3, [pc, #28]	; (400384 <SPI_0_init+0x38>)
  400366:	4798      	blx	r3
	SPI_0_PORT_init();
  400368:	4b07      	ldr	r3, [pc, #28]	; (400388 <SPI_0_init+0x3c>)
  40036a:	4798      	blx	r3
  40036c:	bd10      	pop	{r4, pc}
  40036e:	bf00      	nop
  400370:	00400335 	.word	0x00400335
  400374:	004012d9 	.word	0x004012d9
  400378:	204000e0 	.word	0x204000e0
  40037c:	00400869 	.word	0x00400869
  400380:	40008000 	.word	0x40008000
  400384:	00400889 	.word	0x00400889
  400388:	004002e9 	.word	0x004002e9

0040038c <I2C_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40038c:	4b0a      	ldr	r3, [pc, #40]	; (4003b8 <I2C_0_PORT_init+0x2c>)
  40038e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400390:	f022 0210 	bic.w	r2, r2, #16
  400394:	671a      	str	r2, [r3, #112]	; 0x70
  400396:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400398:	f022 0210 	bic.w	r2, r2, #16
  40039c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40039e:	2210      	movs	r2, #16
  4003a0:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4003a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003a4:	f022 0208 	bic.w	r2, r2, #8
  4003a8:	671a      	str	r2, [r3, #112]	; 0x70
  4003aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003ac:	f022 0208 	bic.w	r2, r2, #8
  4003b0:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003b2:	2208      	movs	r2, #8
  4003b4:	605a      	str	r2, [r3, #4]
  4003b6:	4770      	bx	lr
  4003b8:	400e0e00 	.word	0x400e0e00

004003bc <I2C_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4003bc:	4b04      	ldr	r3, [pc, #16]	; (4003d0 <I2C_0_CLOCK_init+0x14>)
  4003be:	699b      	ldr	r3, [r3, #24]
  4003c0:	f413 2f00 	tst.w	r3, #524288	; 0x80000
  4003c4:	d103      	bne.n	4003ce <I2C_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4003c6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  4003ca:	4b01      	ldr	r3, [pc, #4]	; (4003d0 <I2C_0_CLOCK_init+0x14>)
  4003cc:	611a      	str	r2, [r3, #16]
  4003ce:	4770      	bx	lr
  4003d0:	400e0600 	.word	0x400e0600

004003d4 <I2C_0_init>:
{
	_pmc_enable_periph_clock(ID_TWIHS0);
}

void I2C_0_init(void)
{
  4003d4:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
  4003d6:	4b04      	ldr	r3, [pc, #16]	; (4003e8 <I2C_0_init+0x14>)
  4003d8:	4798      	blx	r3

	i2c_m_sync_init(&I2C_0, TWIHS0);
  4003da:	4904      	ldr	r1, [pc, #16]	; (4003ec <I2C_0_init+0x18>)
  4003dc:	4804      	ldr	r0, [pc, #16]	; (4003f0 <I2C_0_init+0x1c>)
  4003de:	4b05      	ldr	r3, [pc, #20]	; (4003f4 <I2C_0_init+0x20>)
  4003e0:	4798      	blx	r3

	I2C_0_PORT_init();
  4003e2:	4b05      	ldr	r3, [pc, #20]	; (4003f8 <I2C_0_init+0x24>)
  4003e4:	4798      	blx	r3
  4003e6:	bd08      	pop	{r3, pc}
  4003e8:	004003bd 	.word	0x004003bd
  4003ec:	40018000 	.word	0x40018000
  4003f0:	204000f8 	.word	0x204000f8
  4003f4:	00400771 	.word	0x00400771
  4003f8:	0040038d 	.word	0x0040038d

004003fc <delay_driver_init>:
}

void delay_driver_init(void)
{
  4003fc:	b508      	push	{r3, lr}
	delay_init(SysTick);
  4003fe:	4802      	ldr	r0, [pc, #8]	; (400408 <delay_driver_init+0xc>)
  400400:	4b02      	ldr	r3, [pc, #8]	; (40040c <delay_driver_init+0x10>)
  400402:	4798      	blx	r3
  400404:	bd08      	pop	{r3, pc}
  400406:	bf00      	nop
  400408:	e000e010 	.word	0xe000e010
  40040c:	00400595 	.word	0x00400595

00400410 <TARGET_IO_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400410:	4b0f      	ldr	r3, [pc, #60]	; (400450 <TARGET_IO_PORT_init+0x40>)
  400412:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400414:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400418:	671a      	str	r2, [r3, #112]	; 0x70
  40041a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40041c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400420:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400422:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400426:	605a      	str	r2, [r3, #4]
}

static inline void hri_matrix_set_CCFG_SYSIO_reg(const void *const hw, hri_matrix_ccfg_sysio_reg_t mask)
{
	MATRIX_CRITICAL_SECTION_ENTER();
	((Matrix *)hw)->CCFG_SYSIO |= mask;
  400428:	4a0a      	ldr	r2, [pc, #40]	; (400454 <TARGET_IO_PORT_init+0x44>)
  40042a:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  40042e:	f043 0310 	orr.w	r3, r3, #16
  400432:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400436:	4b08      	ldr	r3, [pc, #32]	; (400458 <TARGET_IO_PORT_init+0x48>)
  400438:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40043a:	f042 0210 	orr.w	r2, r2, #16
  40043e:	671a      	str	r2, [r3, #112]	; 0x70
  400440:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400442:	f042 0210 	orr.w	r2, r2, #16
  400446:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400448:	2210      	movs	r2, #16
  40044a:	605a      	str	r2, [r3, #4]
  40044c:	4770      	bx	lr
  40044e:	bf00      	nop
  400450:	400e0e00 	.word	0x400e0e00
  400454:	40088000 	.word	0x40088000
  400458:	400e1000 	.word	0x400e1000

0040045c <TARGET_IO_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40045c:	4b04      	ldr	r3, [pc, #16]	; (400470 <TARGET_IO_CLOCK_init+0x14>)
  40045e:	699b      	ldr	r3, [r3, #24]
  400460:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  400464:	d103      	bne.n	40046e <TARGET_IO_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400466:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  40046a:	4b01      	ldr	r3, [pc, #4]	; (400470 <TARGET_IO_CLOCK_init+0x14>)
  40046c:	611a      	str	r2, [r3, #16]
  40046e:	4770      	bx	lr
  400470:	400e0600 	.word	0x400e0600

00400474 <TARGET_IO_init>:
{
	_pmc_enable_periph_clock(ID_USART1);
}

void TARGET_IO_init(void)
{
  400474:	b508      	push	{r3, lr}
	TARGET_IO_CLOCK_init();
  400476:	4b06      	ldr	r3, [pc, #24]	; (400490 <TARGET_IO_init+0x1c>)
  400478:	4798      	blx	r3
	TARGET_IO_PORT_init();
  40047a:	4b06      	ldr	r3, [pc, #24]	; (400494 <TARGET_IO_init+0x20>)
  40047c:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, USART1, _usart_get_usart_sync());
  40047e:	4b06      	ldr	r3, [pc, #24]	; (400498 <TARGET_IO_init+0x24>)
  400480:	4798      	blx	r3
  400482:	4602      	mov	r2, r0
  400484:	4905      	ldr	r1, [pc, #20]	; (40049c <TARGET_IO_init+0x28>)
  400486:	4806      	ldr	r0, [pc, #24]	; (4004a0 <TARGET_IO_init+0x2c>)
  400488:	4b06      	ldr	r3, [pc, #24]	; (4004a4 <TARGET_IO_init+0x30>)
  40048a:	4798      	blx	r3
  40048c:	bd08      	pop	{r3, pc}
  40048e:	bf00      	nop
  400490:	0040045d 	.word	0x0040045d
  400494:	00400411 	.word	0x00400411
  400498:	00401739 	.word	0x00401739
  40049c:	40028000 	.word	0x40028000
  4004a0:	204000d4 	.word	0x204000d4
  4004a4:	00400ab5 	.word	0x00400ab5

004004a8 <system_init>:
}

void system_init(void)
{
  4004a8:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  4004aa:	4b27      	ldr	r3, [pc, #156]	; (400548 <system_init+0xa0>)
  4004ac:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004ae:	4b27      	ldr	r3, [pc, #156]	; (40054c <system_init+0xa4>)
  4004b0:	699b      	ldr	r3, [r3, #24]
  4004b2:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4004b6:	d103      	bne.n	4004c0 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4004bc:	4b23      	ldr	r3, [pc, #140]	; (40054c <system_init+0xa4>)
  4004be:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004c0:	4b22      	ldr	r3, [pc, #136]	; (40054c <system_init+0xa4>)
  4004c2:	699b      	ldr	r3, [r3, #24]
  4004c4:	f413 6f00 	tst.w	r3, #2048	; 0x800
  4004c8:	d103      	bne.n	4004d2 <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004ca:	f44f 6200 	mov.w	r2, #2048	; 0x800
  4004ce:	4b1f      	ldr	r3, [pc, #124]	; (40054c <system_init+0xa4>)
  4004d0:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004d2:	4b1e      	ldr	r3, [pc, #120]	; (40054c <system_init+0xa4>)
  4004d4:	699b      	ldr	r3, [r3, #24]
  4004d6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  4004da:	d103      	bne.n	4004e4 <system_init+0x3c>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004dc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  4004e0:	4b1a      	ldr	r3, [pc, #104]	; (40054c <system_init+0xa4>)
  4004e2:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004e4:	4b19      	ldr	r3, [pc, #100]	; (40054c <system_init+0xa4>)
  4004e6:	699b      	ldr	r3, [r3, #24]
  4004e8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  4004ec:	d103      	bne.n	4004f6 <system_init+0x4e>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004ee:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  4004f2:	4b16      	ldr	r3, [pc, #88]	; (40054c <system_init+0xa4>)
  4004f4:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  4004f6:	4a16      	ldr	r2, [pc, #88]	; (400550 <system_init+0xa8>)
  4004f8:	6853      	ldr	r3, [r2, #4]
  4004fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4004fe:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_SODR = mask;
  400500:	4b14      	ldr	r3, [pc, #80]	; (400554 <system_init+0xac>)
  400502:	2201      	movs	r2, #1
  400504:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  400506:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400508:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40050a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  40050e:	f44f 7200 	mov.w	r2, #512	; 0x200
  400512:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400514:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400516:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400518:	f503 7300 	add.w	r3, r3, #512	; 0x200
  40051c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  400520:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400522:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400524:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(RF24_CE, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(RF24_CE, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_1_init();
  400526:	4b0c      	ldr	r3, [pc, #48]	; (400558 <system_init+0xb0>)
  400528:	4798      	blx	r3
	EXTERNAL_IRQ_0_init();
  40052a:	4b0c      	ldr	r3, [pc, #48]	; (40055c <system_init+0xb4>)
  40052c:	4798      	blx	r3

	PWM_0_init();
  40052e:	4b0c      	ldr	r3, [pc, #48]	; (400560 <system_init+0xb8>)
  400530:	4798      	blx	r3

	SPI_0_init();
  400532:	4b0c      	ldr	r3, [pc, #48]	; (400564 <system_init+0xbc>)
  400534:	4798      	blx	r3

	I2C_0_init();
  400536:	4b0c      	ldr	r3, [pc, #48]	; (400568 <system_init+0xc0>)
  400538:	4798      	blx	r3

	delay_driver_init();
  40053a:	4b0c      	ldr	r3, [pc, #48]	; (40056c <system_init+0xc4>)
  40053c:	4798      	blx	r3

	TARGET_IO_init();
  40053e:	4b0c      	ldr	r3, [pc, #48]	; (400570 <system_init+0xc8>)
  400540:	4798      	blx	r3

	ext_irq_init();
  400542:	4b0c      	ldr	r3, [pc, #48]	; (400574 <system_init+0xcc>)
  400544:	4798      	blx	r3
  400546:	bd08      	pop	{r3, pc}
  400548:	00400b79 	.word	0x00400b79
  40054c:	400e0600 	.word	0x400e0600
  400550:	400e1850 	.word	0x400e1850
  400554:	400e0e00 	.word	0x400e0e00
  400558:	00400255 	.word	0x00400255
  40055c:	00400269 	.word	0x00400269
  400560:	004002b5 	.word	0x004002b5
  400564:	0040034d 	.word	0x0040034d
  400568:	004003d5 	.word	0x004003d5
  40056c:	004003fd 	.word	0x004003fd
  400570:	00400475 	.word	0x00400475
  400574:	0040060d 	.word	0x0040060d

00400578 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  400578:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  40057c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40057e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  400580:	f3bf 8f5f 	dmb	sy
  400584:	4770      	bx	lr

00400586 <atomic_leave_critical>:
  400586:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  40058a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  40058c:	f383 8810 	msr	PRIMASK, r3
  400590:	4770      	bx	lr
	...

00400594 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  400594:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  400596:	4b02      	ldr	r3, [pc, #8]	; (4005a0 <delay_init+0xc>)
  400598:	6018      	str	r0, [r3, #0]
  40059a:	4b02      	ldr	r3, [pc, #8]	; (4005a4 <delay_init+0x10>)
  40059c:	4798      	blx	r3
  40059e:	bd08      	pop	{r3, pc}
  4005a0:	20400080 	.word	0x20400080
  4005a4:	004012f1 	.word	0x004012f1

004005a8 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
  4005a8:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
  4005aa:	4b04      	ldr	r3, [pc, #16]	; (4005bc <delay_us+0x14>)
  4005ac:	681c      	ldr	r4, [r3, #0]
  4005ae:	4b04      	ldr	r3, [pc, #16]	; (4005c0 <delay_us+0x18>)
  4005b0:	4798      	blx	r3
  4005b2:	4601      	mov	r1, r0
  4005b4:	4620      	mov	r0, r4
  4005b6:	4b03      	ldr	r3, [pc, #12]	; (4005c4 <delay_us+0x1c>)
  4005b8:	4798      	blx	r3
  4005ba:	bd10      	pop	{r4, pc}
  4005bc:	20400080 	.word	0x20400080
  4005c0:	00400b6d 	.word	0x00400b6d
  4005c4:	004012fd 	.word	0x004012fd

004005c8 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  4005c8:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  4005ca:	2502      	movs	r5, #2
  4005cc:	2400      	movs	r4, #0

	while (upper >= lower) {
  4005ce:	e007      	b.n	4005e0 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  4005d0:	4a0d      	ldr	r2, [pc, #52]	; (400608 <process_ext_irq+0x40>)
  4005d2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  4005d6:	b1b3      	cbz	r3, 400606 <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  4005d8:	4798      	blx	r3
  4005da:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  4005dc:	3a01      	subs	r2, #1
  4005de:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
  4005e0:	42ac      	cmp	r4, r5
  4005e2:	d810      	bhi.n	400606 <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  4005e4:	192b      	adds	r3, r5, r4
  4005e6:	105b      	asrs	r3, r3, #1
  4005e8:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
  4005ea:	2a01      	cmp	r2, #1
  4005ec:	d80b      	bhi.n	400606 <process_ext_irq+0x3e>
  4005ee:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
  4005f0:	4905      	ldr	r1, [pc, #20]	; (400608 <process_ext_irq+0x40>)
  4005f2:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  4005f6:	6849      	ldr	r1, [r1, #4]
  4005f8:	4281      	cmp	r1, r0
  4005fa:	d0e9      	beq.n	4005d0 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  4005fc:	4281      	cmp	r1, r0
  4005fe:	d2ed      	bcs.n	4005dc <process_ext_irq+0x14>
			lower = middle + 1;
  400600:	3201      	adds	r2, #1
  400602:	b2d4      	uxtb	r4, r2
  400604:	e7ec      	b.n	4005e0 <process_ext_irq+0x18>
  400606:	bd38      	pop	{r3, r4, r5, pc}
  400608:	20400084 	.word	0x20400084

0040060c <ext_irq_init>:
{
  40060c:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  40060e:	2300      	movs	r3, #0
  400610:	e00a      	b.n	400628 <ext_irq_init+0x1c>
		ext_irqs[i].pin = 0xFFFFFFFF;
  400612:	4a08      	ldr	r2, [pc, #32]	; (400634 <ext_irq_init+0x28>)
  400614:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  400618:	f04f 30ff 	mov.w	r0, #4294967295
  40061c:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  40061e:	2100      	movs	r1, #0
  400620:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  400624:	3301      	adds	r3, #1
  400626:	b29b      	uxth	r3, r3
  400628:	2b01      	cmp	r3, #1
  40062a:	d9f2      	bls.n	400612 <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
  40062c:	4802      	ldr	r0, [pc, #8]	; (400638 <ext_irq_init+0x2c>)
  40062e:	4b03      	ldr	r3, [pc, #12]	; (40063c <ext_irq_init+0x30>)
  400630:	4798      	blx	r3
}
  400632:	bd08      	pop	{r3, pc}
  400634:	20400084 	.word	0x20400084
  400638:	004005c9 	.word	0x004005c9
  40063c:	00400e01 	.word	0x00400e01

00400640 <ext_irq_register>:
{
  400640:	b5f0      	push	{r4, r5, r6, r7, lr}
  400642:	b083      	sub	sp, #12
  400644:	4605      	mov	r5, r0
	uint8_t i = 0, j = 0;
  400646:	2300      	movs	r3, #0
	for (; i < EXT_IRQ_AMOUNT; i++) {
  400648:	2b01      	cmp	r3, #1
  40064a:	d80e      	bhi.n	40066a <ext_irq_register+0x2a>
		if (ext_irqs[i].pin == pin) {
  40064c:	4618      	mov	r0, r3
  40064e:	4a2e      	ldr	r2, [pc, #184]	; (400708 <ext_irq_register+0xc8>)
  400650:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  400654:	6852      	ldr	r2, [r2, #4]
  400656:	42aa      	cmp	r2, r5
  400658:	d002      	beq.n	400660 <ext_irq_register+0x20>
	for (; i < EXT_IRQ_AMOUNT; i++) {
  40065a:	3301      	adds	r3, #1
  40065c:	b2db      	uxtb	r3, r3
  40065e:	e7f3      	b.n	400648 <ext_irq_register+0x8>
			ext_irqs[i].cb = cb;
  400660:	4b29      	ldr	r3, [pc, #164]	; (400708 <ext_irq_register+0xc8>)
  400662:	f843 1030 	str.w	r1, [r3, r0, lsl #3]
			found          = true;
  400666:	2701      	movs	r7, #1
			break;
  400668:	e000      	b.n	40066c <ext_irq_register+0x2c>
	bool    found = false;
  40066a:	2700      	movs	r7, #0
	if (NULL == cb) {
  40066c:	b159      	cbz	r1, 400686 <ext_irq_register+0x46>
	if (!found) {
  40066e:	2f00      	cmp	r7, #0
  400670:	d13d      	bne.n	4006ee <ext_irq_register+0xae>
  400672:	2600      	movs	r6, #0
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  400674:	2e01      	cmp	r6, #1
  400676:	d813      	bhi.n	4006a0 <ext_irq_register+0x60>
			if (NULL == ext_irqs[i].cb) {
  400678:	4b23      	ldr	r3, [pc, #140]	; (400708 <ext_irq_register+0xc8>)
  40067a:	f853 3036 	ldr.w	r3, [r3, r6, lsl #3]
  40067e:	b143      	cbz	r3, 400692 <ext_irq_register+0x52>
		for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  400680:	3601      	adds	r6, #1
  400682:	b2f6      	uxtb	r6, r6
  400684:	e7f6      	b.n	400674 <ext_irq_register+0x34>
		if (!found) {
  400686:	2f00      	cmp	r7, #0
  400688:	d038      	beq.n	4006fc <ext_irq_register+0xbc>
		return _ext_irq_enable(pin, false);
  40068a:	4628      	mov	r0, r5
  40068c:	4b1f      	ldr	r3, [pc, #124]	; (40070c <ext_irq_register+0xcc>)
  40068e:	4798      	blx	r3
  400690:	e032      	b.n	4006f8 <ext_irq_register+0xb8>
				ext_irqs[i].cb  = cb;
  400692:	4b1d      	ldr	r3, [pc, #116]	; (400708 <ext_irq_register+0xc8>)
  400694:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
				ext_irqs[i].pin = pin;
  400698:	eb03 03c6 	add.w	r3, r3, r6, lsl #3
  40069c:	605d      	str	r5, [r3, #4]
				found           = true;
  40069e:	2701      	movs	r7, #1
  4006a0:	2300      	movs	r3, #0
  4006a2:	e001      	b.n	4006a8 <ext_irq_register+0x68>
		for (; (j < EXT_IRQ_AMOUNT) && (i < EXT_IRQ_AMOUNT); j++) {
  4006a4:	3301      	adds	r3, #1
  4006a6:	b2db      	uxtb	r3, r3
  4006a8:	2b01      	cmp	r3, #1
  4006aa:	bf98      	it	ls
  4006ac:	2e01      	cmpls	r6, #1
  4006ae:	d81e      	bhi.n	4006ee <ext_irq_register+0xae>
			if ((ext_irqs[i].pin < ext_irqs[j].pin) && (ext_irqs[j].pin != 0xFFFFFFFF)) {
  4006b0:	46b6      	mov	lr, r6
  4006b2:	4a15      	ldr	r2, [pc, #84]	; (400708 <ext_irq_register+0xc8>)
  4006b4:	eb02 01c6 	add.w	r1, r2, r6, lsl #3
  4006b8:	6848      	ldr	r0, [r1, #4]
  4006ba:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  4006be:	6852      	ldr	r2, [r2, #4]
  4006c0:	4290      	cmp	r0, r2
  4006c2:	d2ef      	bcs.n	4006a4 <ext_irq_register+0x64>
  4006c4:	f1b2 3fff 	cmp.w	r2, #4294967295
  4006c8:	d0ec      	beq.n	4006a4 <ext_irq_register+0x64>
				struct ext_irq tmp = ext_irqs[j];
  4006ca:	4c0f      	ldr	r4, [pc, #60]	; (400708 <ext_irq_register+0xc8>)
  4006cc:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
  4006d0:	e892 0003 	ldmia.w	r2, {r0, r1}
  4006d4:	e88d 0003 	stmia.w	sp, {r0, r1}
				ext_irqs[j] = ext_irqs[i];
  4006d8:	eb04 04c6 	add.w	r4, r4, r6, lsl #3
  4006dc:	e894 0003 	ldmia.w	r4, {r0, r1}
  4006e0:	e882 0003 	stmia.w	r2, {r0, r1}
				ext_irqs[i] = tmp;
  4006e4:	e89d 0003 	ldmia.w	sp, {r0, r1}
  4006e8:	e884 0003 	stmia.w	r4, {r0, r1}
  4006ec:	e7da      	b.n	4006a4 <ext_irq_register+0x64>
	if (!found) {
  4006ee:	b147      	cbz	r7, 400702 <ext_irq_register+0xc2>
	return _ext_irq_enable(pin, true);
  4006f0:	2101      	movs	r1, #1
  4006f2:	4628      	mov	r0, r5
  4006f4:	4b05      	ldr	r3, [pc, #20]	; (40070c <ext_irq_register+0xcc>)
  4006f6:	4798      	blx	r3
}
  4006f8:	b003      	add	sp, #12
  4006fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			return ERR_INVALID_ARG;
  4006fc:	f06f 000c 	mvn.w	r0, #12
  400700:	e7fa      	b.n	4006f8 <ext_irq_register+0xb8>
		return ERR_INVALID_ARG;
  400702:	f06f 000c 	mvn.w	r0, #12
  400706:	e7f7      	b.n	4006f8 <ext_irq_register+0xb8>
  400708:	20400084 	.word	0x20400084
  40070c:	00400e29 	.word	0x00400e29

00400710 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
  400710:	b510      	push	{r4, lr}
  400712:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
  400714:	8903      	ldrh	r3, [r0, #8]
  400716:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  40071a:	4614      	mov	r4, r2
  40071c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
  40071e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400722:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
  400726:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400728:	a901      	add	r1, sp, #4
  40072a:	3814      	subs	r0, #20
  40072c:	4b03      	ldr	r3, [pc, #12]	; (40073c <i2c_m_sync_write+0x2c>)
  40072e:	4798      	blx	r3

	if (ret) {
  400730:	b910      	cbnz	r0, 400738 <i2c_m_sync_write+0x28>
		return ret;
	}

	return n;
}
  400732:	4620      	mov	r0, r4
  400734:	b004      	add	sp, #16
  400736:	bd10      	pop	{r4, pc}
		return ret;
  400738:	4604      	mov	r4, r0
  40073a:	e7fa      	b.n	400732 <i2c_m_sync_write+0x22>
  40073c:	004013bd 	.word	0x004013bd

00400740 <i2c_m_sync_read>:
{
  400740:	b510      	push	{r4, lr}
  400742:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
  400744:	8903      	ldrh	r3, [r0, #8]
  400746:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  40074a:	4614      	mov	r4, r2
  40074c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
  40074e:	f248 0301 	movw	r3, #32769	; 0x8001
  400752:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
  400756:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400758:	a901      	add	r1, sp, #4
  40075a:	3814      	subs	r0, #20
  40075c:	4b03      	ldr	r3, [pc, #12]	; (40076c <i2c_m_sync_read+0x2c>)
  40075e:	4798      	blx	r3
	if (ret) {
  400760:	b910      	cbnz	r0, 400768 <i2c_m_sync_read+0x28>
}
  400762:	4620      	mov	r0, r4
  400764:	b004      	add	sp, #16
  400766:	bd10      	pop	{r4, pc}
		return ret;
  400768:	4604      	mov	r4, r0
  40076a:	e7fa      	b.n	400762 <i2c_m_sync_read+0x22>
  40076c:	004013bd 	.word	0x004013bd

00400770 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
  400770:	b538      	push	{r3, r4, r5, lr}
  400772:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
  400774:	4604      	mov	r4, r0
  400776:	225e      	movs	r2, #94	; 0x5e
  400778:	4908      	ldr	r1, [pc, #32]	; (40079c <i2c_m_sync_init+0x2c>)
  40077a:	3000      	adds	r0, #0
  40077c:	bf18      	it	ne
  40077e:	2001      	movne	r0, #1
  400780:	4b07      	ldr	r3, [pc, #28]	; (4007a0 <i2c_m_sync_init+0x30>)
  400782:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
  400784:	4629      	mov	r1, r5
  400786:	4620      	mov	r0, r4
  400788:	4b06      	ldr	r3, [pc, #24]	; (4007a4 <i2c_m_sync_init+0x34>)
  40078a:	4798      	blx	r3
	if (init_status) {
  40078c:	4603      	mov	r3, r0
  40078e:	b918      	cbnz	r0, 400798 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
  400790:	4a05      	ldr	r2, [pc, #20]	; (4007a8 <i2c_m_sync_init+0x38>)
  400792:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
  400794:	4a05      	ldr	r2, [pc, #20]	; (4007ac <i2c_m_sync_init+0x3c>)
  400796:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
  400798:	4618      	mov	r0, r3
  40079a:	bd38      	pop	{r3, r4, r5, pc}
  40079c:	00402c24 	.word	0x00402c24
  4007a0:	00400b29 	.word	0x00400b29
  4007a4:	00401375 	.word	0x00401375
  4007a8:	00400741 	.word	0x00400741
  4007ac:	00400711 	.word	0x00400711

004007b0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  4007b0:	b570      	push	{r4, r5, r6, lr}
  4007b2:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4007b4:	4604      	mov	r4, r0
  4007b6:	460d      	mov	r5, r1
  4007b8:	2800      	cmp	r0, #0
  4007ba:	bf18      	it	ne
  4007bc:	2900      	cmpne	r1, #0
  4007be:	bf14      	ite	ne
  4007c0:	2001      	movne	r0, #1
  4007c2:	2000      	moveq	r0, #0
  4007c4:	2234      	movs	r2, #52	; 0x34
  4007c6:	4904      	ldr	r1, [pc, #16]	; (4007d8 <io_write+0x28>)
  4007c8:	4b04      	ldr	r3, [pc, #16]	; (4007dc <io_write+0x2c>)
  4007ca:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  4007cc:	6823      	ldr	r3, [r4, #0]
  4007ce:	4632      	mov	r2, r6
  4007d0:	4629      	mov	r1, r5
  4007d2:	4620      	mov	r0, r4
  4007d4:	4798      	blx	r3
}
  4007d6:	bd70      	pop	{r4, r5, r6, pc}
  4007d8:	00402c40 	.word	0x00402c40
  4007dc:	00400b29 	.word	0x00400b29

004007e0 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4007e0:	b570      	push	{r4, r5, r6, lr}
  4007e2:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4007e4:	4604      	mov	r4, r0
  4007e6:	460d      	mov	r5, r1
  4007e8:	2800      	cmp	r0, #0
  4007ea:	bf18      	it	ne
  4007ec:	2900      	cmpne	r1, #0
  4007ee:	bf14      	ite	ne
  4007f0:	2001      	movne	r0, #1
  4007f2:	2000      	moveq	r0, #0
  4007f4:	223d      	movs	r2, #61	; 0x3d
  4007f6:	4904      	ldr	r1, [pc, #16]	; (400808 <io_read+0x28>)
  4007f8:	4b04      	ldr	r3, [pc, #16]	; (40080c <io_read+0x2c>)
  4007fa:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  4007fc:	6863      	ldr	r3, [r4, #4]
  4007fe:	4632      	mov	r2, r6
  400800:	4629      	mov	r1, r5
  400802:	4620      	mov	r0, r4
  400804:	4798      	blx	r3
}
  400806:	bd70      	pop	{r4, r5, r6, pc}
  400808:	00402c40 	.word	0x00402c40
  40080c:	00400b29 	.word	0x00400b29

00400810 <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
  400810:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.period) {
  400812:	6943      	ldr	r3, [r0, #20]
  400814:	b103      	cbz	r3, 400818 <pwm_period_expired+0x8>
		descr->pwm_cb.period(descr);
  400816:	4798      	blx	r3
  400818:	bd08      	pop	{r3, pc}

0040081a <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
  40081a:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.error) {
  40081c:	6983      	ldr	r3, [r0, #24]
  40081e:	b103      	cbz	r3, 400822 <pwm_detect_fault+0x8>
		descr->pwm_cb.error(descr);
  400820:	4798      	blx	r3
  400822:	bd08      	pop	{r3, pc}

00400824 <pwm_init>:
{
  400824:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400826:	4604      	mov	r4, r0
  400828:	460d      	mov	r5, r1
  40082a:	2800      	cmp	r0, #0
  40082c:	bf18      	it	ne
  40082e:	2900      	cmpne	r1, #0
  400830:	bf14      	ite	ne
  400832:	2001      	movne	r0, #1
  400834:	2000      	moveq	r0, #0
  400836:	2233      	movs	r2, #51	; 0x33
  400838:	4906      	ldr	r1, [pc, #24]	; (400854 <pwm_init+0x30>)
  40083a:	4b07      	ldr	r3, [pc, #28]	; (400858 <pwm_init+0x34>)
  40083c:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
  40083e:	4629      	mov	r1, r5
  400840:	4620      	mov	r0, r4
  400842:	4b06      	ldr	r3, [pc, #24]	; (40085c <pwm_init+0x38>)
  400844:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
  400846:	4b06      	ldr	r3, [pc, #24]	; (400860 <pwm_init+0x3c>)
  400848:	6023      	str	r3, [r4, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
  40084a:	4b06      	ldr	r3, [pc, #24]	; (400864 <pwm_init+0x40>)
  40084c:	6063      	str	r3, [r4, #4]
}
  40084e:	2000      	movs	r0, #0
  400850:	bd38      	pop	{r3, r4, r5, pc}
  400852:	bf00      	nop
  400854:	00402c54 	.word	0x00402c54
  400858:	00400b29 	.word	0x00400b29
  40085c:	00400fa1 	.word	0x00400fa1
  400860:	00400811 	.word	0x00400811
  400864:	0040081b 	.word	0x0040081b

00400868 <spi_m_sync_set_func_ptr>:

/**
 *  \brief Initialize the SPI HAL instance function pointer for HPL APIs.
 */
void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi, void *const func)
{
  400868:	b538      	push	{r3, r4, r5, lr}
  40086a:	460d      	mov	r5, r1
	ASSERT(spi);
  40086c:	4604      	mov	r4, r0
  40086e:	2239      	movs	r2, #57	; 0x39
  400870:	4903      	ldr	r1, [pc, #12]	; (400880 <spi_m_sync_set_func_ptr+0x18>)
  400872:	3000      	adds	r0, #0
  400874:	bf18      	it	ne
  400876:	2001      	movne	r0, #1
  400878:	4b02      	ldr	r3, [pc, #8]	; (400884 <spi_m_sync_set_func_ptr+0x1c>)
  40087a:	4798      	blx	r3
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
  40087c:	6025      	str	r5, [r4, #0]
  40087e:	bd38      	pop	{r3, r4, r5, pc}
  400880:	00402c6c 	.word	0x00402c6c
  400884:	00400b29 	.word	0x00400b29

00400888 <spi_m_sync_init>:
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
  400888:	b538      	push	{r3, r4, r5, lr}
	int32_t rc = 0;
	ASSERT(spi && hw);
  40088a:	4604      	mov	r4, r0
  40088c:	460d      	mov	r5, r1
  40088e:	2800      	cmp	r0, #0
  400890:	bf18      	it	ne
  400892:	2900      	cmpne	r1, #0
  400894:	bf14      	ite	ne
  400896:	2001      	movne	r0, #1
  400898:	2000      	moveq	r0, #0
  40089a:	2240      	movs	r2, #64	; 0x40
  40089c:	4909      	ldr	r1, [pc, #36]	; (4008c4 <spi_m_sync_init+0x3c>)
  40089e:	4b0a      	ldr	r3, [pc, #40]	; (4008c8 <spi_m_sync_init+0x40>)
  4008a0:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
  4008a2:	4620      	mov	r0, r4
  4008a4:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
  4008a8:	4629      	mov	r1, r5
  4008aa:	4b08      	ldr	r3, [pc, #32]	; (4008cc <spi_m_sync_init+0x44>)
  4008ac:	4798      	blx	r3

	if (rc < 0) {
  4008ae:	2800      	cmp	r0, #0
  4008b0:	db07      	blt.n	4008c2 <spi_m_sync_init+0x3a>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
  4008b2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4008b6:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
  4008b8:	4b05      	ldr	r3, [pc, #20]	; (4008d0 <spi_m_sync_init+0x48>)
  4008ba:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
  4008bc:	4b05      	ldr	r3, [pc, #20]	; (4008d4 <spi_m_sync_init+0x4c>)
  4008be:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
  4008c0:	2000      	movs	r0, #0
}
  4008c2:	bd38      	pop	{r3, r4, r5, pc}
  4008c4:	00402c6c 	.word	0x00402c6c
  4008c8:	00400b29 	.word	0x00400b29
  4008cc:	004010fd 	.word	0x004010fd
  4008d0:	0040097d 	.word	0x0040097d
  4008d4:	00400941 	.word	0x00400941

004008d8 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
  4008d8:	b510      	push	{r4, lr}
	ASSERT(spi);
  4008da:	4604      	mov	r4, r0
  4008dc:	2257      	movs	r2, #87	; 0x57
  4008de:	4905      	ldr	r1, [pc, #20]	; (4008f4 <spi_m_sync_enable+0x1c>)
  4008e0:	3000      	adds	r0, #0
  4008e2:	bf18      	it	ne
  4008e4:	2001      	movne	r0, #1
  4008e6:	4b04      	ldr	r3, [pc, #16]	; (4008f8 <spi_m_sync_enable+0x20>)
  4008e8:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
  4008ea:	1d20      	adds	r0, r4, #4
  4008ec:	4b03      	ldr	r3, [pc, #12]	; (4008fc <spi_m_sync_enable+0x24>)
  4008ee:	4798      	blx	r3
  4008f0:	bd10      	pop	{r4, pc}
  4008f2:	bf00      	nop
  4008f4:	00402c6c 	.word	0x00402c6c
  4008f8:	00400b29 	.word	0x00400b29
  4008fc:	004011a5 	.word	0x004011a5

00400900 <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
  400900:	b530      	push	{r4, r5, lr}
  400902:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
  400904:	4605      	mov	r5, r0
  400906:	460c      	mov	r4, r1
  400908:	2800      	cmp	r0, #0
  40090a:	bf18      	it	ne
  40090c:	2900      	cmpne	r1, #0
  40090e:	bf14      	ite	ne
  400910:	2001      	movne	r0, #1
  400912:	2000      	moveq	r0, #0
  400914:	22b3      	movs	r2, #179	; 0xb3
  400916:	4907      	ldr	r1, [pc, #28]	; (400934 <spi_m_sync_transfer+0x34>)
  400918:	4b07      	ldr	r3, [pc, #28]	; (400938 <spi_m_sync_transfer+0x38>)
  40091a:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
  40091c:	6823      	ldr	r3, [r4, #0]
  40091e:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
  400920:	6863      	ldr	r3, [r4, #4]
  400922:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
  400924:	68a3      	ldr	r3, [r4, #8]
  400926:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
  400928:	a901      	add	r1, sp, #4
  40092a:	1d28      	adds	r0, r5, #4
  40092c:	4b03      	ldr	r3, [pc, #12]	; (40093c <spi_m_sync_transfer+0x3c>)
  40092e:	4798      	blx	r3
}
  400930:	b005      	add	sp, #20
  400932:	bd30      	pop	{r4, r5, pc}
  400934:	00402c6c 	.word	0x00402c6c
  400938:	00400b29 	.word	0x00400b29
  40093c:	004011d9 	.word	0x004011d9

00400940 <_spi_m_sync_io_write>:
{
  400940:	b570      	push	{r4, r5, r6, lr}
  400942:	b084      	sub	sp, #16
  400944:	460e      	mov	r6, r1
  400946:	4615      	mov	r5, r2
	ASSERT(io);
  400948:	4604      	mov	r4, r0
  40094a:	22a3      	movs	r2, #163	; 0xa3
  40094c:	4908      	ldr	r1, [pc, #32]	; (400970 <_spi_m_sync_io_write+0x30>)
  40094e:	3000      	adds	r0, #0
  400950:	bf18      	it	ne
  400952:	2001      	movne	r0, #1
  400954:	4b07      	ldr	r3, [pc, #28]	; (400974 <_spi_m_sync_io_write+0x34>)
  400956:	4798      	blx	r3
	xfer.rxbuf = 0;
  400958:	2300      	movs	r3, #0
  40095a:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
  40095c:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
  40095e:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400960:	a901      	add	r1, sp, #4
  400962:	f1a4 000c 	sub.w	r0, r4, #12
  400966:	4b04      	ldr	r3, [pc, #16]	; (400978 <_spi_m_sync_io_write+0x38>)
  400968:	4798      	blx	r3
}
  40096a:	b004      	add	sp, #16
  40096c:	bd70      	pop	{r4, r5, r6, pc}
  40096e:	bf00      	nop
  400970:	00402c6c 	.word	0x00402c6c
  400974:	00400b29 	.word	0x00400b29
  400978:	00400901 	.word	0x00400901

0040097c <_spi_m_sync_io_read>:
{
  40097c:	b570      	push	{r4, r5, r6, lr}
  40097e:	b084      	sub	sp, #16
  400980:	460e      	mov	r6, r1
  400982:	4615      	mov	r5, r2
	ASSERT(io);
  400984:	4604      	mov	r4, r0
  400986:	2287      	movs	r2, #135	; 0x87
  400988:	4908      	ldr	r1, [pc, #32]	; (4009ac <_spi_m_sync_io_read+0x30>)
  40098a:	3000      	adds	r0, #0
  40098c:	bf18      	it	ne
  40098e:	2001      	movne	r0, #1
  400990:	4b07      	ldr	r3, [pc, #28]	; (4009b0 <_spi_m_sync_io_read+0x34>)
  400992:	4798      	blx	r3
	xfer.rxbuf = buf;
  400994:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
  400996:	2300      	movs	r3, #0
  400998:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
  40099a:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  40099c:	a901      	add	r1, sp, #4
  40099e:	f1a4 000c 	sub.w	r0, r4, #12
  4009a2:	4b04      	ldr	r3, [pc, #16]	; (4009b4 <_spi_m_sync_io_read+0x38>)
  4009a4:	4798      	blx	r3
}
  4009a6:	b004      	add	sp, #16
  4009a8:	bd70      	pop	{r4, r5, r6, pc}
  4009aa:	bf00      	nop
  4009ac:	00402c6c 	.word	0x00402c6c
  4009b0:	00400b29 	.word	0x00400b29
  4009b4:	00400901 	.word	0x00400901

004009b8 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
  4009b8:	b538      	push	{r3, r4, r5, lr}
	ASSERT(spi && io);
  4009ba:	4604      	mov	r4, r0
  4009bc:	460d      	mov	r5, r1
  4009be:	2800      	cmp	r0, #0
  4009c0:	bf18      	it	ne
  4009c2:	2900      	cmpne	r1, #0
  4009c4:	bf14      	ite	ne
  4009c6:	2001      	movne	r0, #1
  4009c8:	2000      	moveq	r0, #0
  4009ca:	22bd      	movs	r2, #189	; 0xbd
  4009cc:	4903      	ldr	r1, [pc, #12]	; (4009dc <spi_m_sync_get_io_descriptor+0x24>)
  4009ce:	4b04      	ldr	r3, [pc, #16]	; (4009e0 <spi_m_sync_get_io_descriptor+0x28>)
  4009d0:	4798      	blx	r3
	*io = &spi->io;
  4009d2:	340c      	adds	r4, #12
  4009d4:	602c      	str	r4, [r5, #0]
	return 0;
}
  4009d6:	2000      	movs	r0, #0
  4009d8:	bd38      	pop	{r3, r4, r5, pc}
  4009da:	bf00      	nop
  4009dc:	00402c6c 	.word	0x00402c6c
  4009e0:	00400b29 	.word	0x00400b29

004009e4 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  4009e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4009e6:	4616      	mov	r6, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  4009e8:	4605      	mov	r5, r0
  4009ea:	460f      	mov	r7, r1
  4009ec:	2800      	cmp	r0, #0
  4009ee:	bf18      	it	ne
  4009f0:	2900      	cmpne	r1, #0
  4009f2:	d002      	beq.n	4009fa <usart_sync_write+0x16>
  4009f4:	bb0a      	cbnz	r2, 400a3a <usart_sync_write+0x56>
  4009f6:	2000      	movs	r0, #0
  4009f8:	e000      	b.n	4009fc <usart_sync_write+0x18>
  4009fa:	2000      	movs	r0, #0
  4009fc:	22f1      	movs	r2, #241	; 0xf1
  4009fe:	4910      	ldr	r1, [pc, #64]	; (400a40 <usart_sync_write+0x5c>)
  400a00:	4b10      	ldr	r3, [pc, #64]	; (400a44 <usart_sync_write+0x60>)
  400a02:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
  400a04:	f105 0408 	add.w	r4, r5, #8
  400a08:	4620      	mov	r0, r4
  400a0a:	4b0f      	ldr	r3, [pc, #60]	; (400a48 <usart_sync_write+0x64>)
  400a0c:	4798      	blx	r3
  400a0e:	2800      	cmp	r0, #0
  400a10:	d0f8      	beq.n	400a04 <usart_sync_write+0x20>
  400a12:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
  400a14:	5d79      	ldrb	r1, [r7, r5]
  400a16:	4620      	mov	r0, r4
  400a18:	4b0c      	ldr	r3, [pc, #48]	; (400a4c <usart_sync_write+0x68>)
  400a1a:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
  400a1c:	4620      	mov	r0, r4
  400a1e:	4b0a      	ldr	r3, [pc, #40]	; (400a48 <usart_sync_write+0x64>)
  400a20:	4798      	blx	r3
  400a22:	2800      	cmp	r0, #0
  400a24:	d0fa      	beq.n	400a1c <usart_sync_write+0x38>
			;
	} while (++offset < length);
  400a26:	3501      	adds	r5, #1
  400a28:	42b5      	cmp	r5, r6
  400a2a:	d3f3      	bcc.n	400a14 <usart_sync_write+0x30>
	while (!_usart_sync_is_transmit_done(&descr->device))
  400a2c:	4620      	mov	r0, r4
  400a2e:	4b08      	ldr	r3, [pc, #32]	; (400a50 <usart_sync_write+0x6c>)
  400a30:	4798      	blx	r3
  400a32:	2800      	cmp	r0, #0
  400a34:	d0fa      	beq.n	400a2c <usart_sync_write+0x48>
		;
	return (int32_t)offset;
}
  400a36:	4628      	mov	r0, r5
  400a38:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
  400a3a:	2001      	movs	r0, #1
  400a3c:	e7de      	b.n	4009fc <usart_sync_write+0x18>
  400a3e:	bf00      	nop
  400a40:	00402c88 	.word	0x00402c88
  400a44:	00400b29 	.word	0x00400b29
  400a48:	004016c1 	.word	0x004016c1
  400a4c:	00401679 	.word	0x00401679
  400a50:	004016e9 	.word	0x004016e9

00400a54 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  400a54:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400a58:	4617      	mov	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  400a5a:	4605      	mov	r5, r0
  400a5c:	4688      	mov	r8, r1
  400a5e:	2800      	cmp	r0, #0
  400a60:	bf18      	it	ne
  400a62:	2900      	cmpne	r1, #0
  400a64:	d002      	beq.n	400a6c <usart_sync_read+0x18>
  400a66:	b9d2      	cbnz	r2, 400a9e <usart_sync_read+0x4a>
  400a68:	2000      	movs	r0, #0
  400a6a:	e000      	b.n	400a6e <usart_sync_read+0x1a>
  400a6c:	2000      	movs	r0, #0
  400a6e:	f44f 7286 	mov.w	r2, #268	; 0x10c
  400a72:	490c      	ldr	r1, [pc, #48]	; (400aa4 <usart_sync_read+0x50>)
  400a74:	4b0c      	ldr	r3, [pc, #48]	; (400aa8 <usart_sync_read+0x54>)
  400a76:	4798      	blx	r3
	uint32_t                      offset = 0;
  400a78:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
  400a7a:	f105 0408 	add.w	r4, r5, #8
  400a7e:	4620      	mov	r0, r4
  400a80:	4b0a      	ldr	r3, [pc, #40]	; (400aac <usart_sync_read+0x58>)
  400a82:	4798      	blx	r3
  400a84:	2800      	cmp	r0, #0
  400a86:	d0f8      	beq.n	400a7a <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
  400a88:	4620      	mov	r0, r4
  400a8a:	4b09      	ldr	r3, [pc, #36]	; (400ab0 <usart_sync_read+0x5c>)
  400a8c:	4798      	blx	r3
  400a8e:	f808 0006 	strb.w	r0, [r8, r6]
	} while (++offset < length);
  400a92:	3601      	adds	r6, #1
  400a94:	42be      	cmp	r6, r7
  400a96:	d3f0      	bcc.n	400a7a <usart_sync_read+0x26>

	return (int32_t)offset;
}
  400a98:	4630      	mov	r0, r6
  400a9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(io_descr && buf && length);
  400a9e:	2001      	movs	r0, #1
  400aa0:	e7e5      	b.n	400a6e <usart_sync_read+0x1a>
  400aa2:	bf00      	nop
  400aa4:	00402c88 	.word	0x00402c88
  400aa8:	00400b29 	.word	0x00400b29
  400aac:	00401711 	.word	0x00401711
  400ab0:	0040169d 	.word	0x0040169d

00400ab4 <usart_sync_init>:
{
  400ab4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400ab6:	4604      	mov	r4, r0
  400ab8:	460d      	mov	r5, r1
  400aba:	2800      	cmp	r0, #0
  400abc:	bf18      	it	ne
  400abe:	2900      	cmpne	r1, #0
  400ac0:	bf14      	ite	ne
  400ac2:	2001      	movne	r0, #1
  400ac4:	2000      	moveq	r0, #0
  400ac6:	2234      	movs	r2, #52	; 0x34
  400ac8:	4907      	ldr	r1, [pc, #28]	; (400ae8 <usart_sync_init+0x34>)
  400aca:	4b08      	ldr	r3, [pc, #32]	; (400aec <usart_sync_init+0x38>)
  400acc:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
  400ace:	4629      	mov	r1, r5
  400ad0:	f104 0008 	add.w	r0, r4, #8
  400ad4:	4b06      	ldr	r3, [pc, #24]	; (400af0 <usart_sync_init+0x3c>)
  400ad6:	4798      	blx	r3
	if (init_status) {
  400ad8:	4603      	mov	r3, r0
  400ada:	b918      	cbnz	r0, 400ae4 <usart_sync_init+0x30>
	descr->io.read  = usart_sync_read;
  400adc:	4a05      	ldr	r2, [pc, #20]	; (400af4 <usart_sync_init+0x40>)
  400ade:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
  400ae0:	4a05      	ldr	r2, [pc, #20]	; (400af8 <usart_sync_init+0x44>)
  400ae2:	6022      	str	r2, [r4, #0]
}
  400ae4:	4618      	mov	r0, r3
  400ae6:	bd38      	pop	{r3, r4, r5, pc}
  400ae8:	00402c88 	.word	0x00402c88
  400aec:	00400b29 	.word	0x00400b29
  400af0:	0040160d 	.word	0x0040160d
  400af4:	00400a55 	.word	0x00400a55
  400af8:	004009e5 	.word	0x004009e5

00400afc <usart_sync_enable>:
{
  400afc:	b510      	push	{r4, lr}
	ASSERT(descr);
  400afe:	4604      	mov	r4, r0
  400b00:	2253      	movs	r2, #83	; 0x53
  400b02:	4906      	ldr	r1, [pc, #24]	; (400b1c <usart_sync_enable+0x20>)
  400b04:	3000      	adds	r0, #0
  400b06:	bf18      	it	ne
  400b08:	2001      	movne	r0, #1
  400b0a:	4b05      	ldr	r3, [pc, #20]	; (400b20 <usart_sync_enable+0x24>)
  400b0c:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
  400b0e:	f104 0008 	add.w	r0, r4, #8
  400b12:	4b04      	ldr	r3, [pc, #16]	; (400b24 <usart_sync_enable+0x28>)
  400b14:	4798      	blx	r3
}
  400b16:	2000      	movs	r0, #0
  400b18:	bd10      	pop	{r4, pc}
  400b1a:	bf00      	nop
  400b1c:	00402c88 	.word	0x00402c88
  400b20:	00400b29 	.word	0x00400b29
  400b24:	00401645 	.word	0x00401645

00400b28 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  400b28:	b900      	cbnz	r0, 400b2c <assert+0x4>
		__asm("BKPT #0");
  400b2a:	be00      	bkpt	0x0000
  400b2c:	4770      	bx	lr
	...

00400b30 <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
  400b30:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
  400b32:	4a06      	ldr	r2, [pc, #24]	; (400b4c <_sbrk+0x1c>)
  400b34:	6812      	ldr	r2, [r2, #0]
  400b36:	b122      	cbz	r2, 400b42 <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
  400b38:	4a04      	ldr	r2, [pc, #16]	; (400b4c <_sbrk+0x1c>)
  400b3a:	6810      	ldr	r0, [r2, #0]

	heap += incr;
  400b3c:	4403      	add	r3, r0
  400b3e:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
  400b40:	4770      	bx	lr
		heap = (unsigned char *)&_end;
  400b42:	4903      	ldr	r1, [pc, #12]	; (400b50 <_sbrk+0x20>)
  400b44:	4a01      	ldr	r2, [pc, #4]	; (400b4c <_sbrk+0x1c>)
  400b46:	6011      	str	r1, [r2, #0]
  400b48:	e7f6      	b.n	400b38 <_sbrk+0x8>
  400b4a:	bf00      	nop
  400b4c:	20400094 	.word	0x20400094
  400b50:	20400728 	.word	0x20400728

00400b54 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
  400b54:	f04f 30ff 	mov.w	r0, #4294967295
  400b58:	4770      	bx	lr

00400b5a <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
  400b5a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  400b5e:	604b      	str	r3, [r1, #4]

	return 0;
}
  400b60:	2000      	movs	r0, #0
  400b62:	4770      	bx	lr

00400b64 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
  400b64:	2001      	movs	r0, #1
  400b66:	4770      	bx	lr

00400b68 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
  400b68:	2000      	movs	r0, #0
  400b6a:	4770      	bx	lr

00400b6c <_get_cycles_for_us>:
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
	return _get_cycles_for_us_internal(us, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  400b6c:	f44f 7396 	mov.w	r3, #300	; 0x12c
  400b70:	fb03 f000 	mul.w	r0, r3, r0
  400b74:	4770      	bx	lr
	...

00400b78 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  400b78:	b500      	push	{lr}
  400b7a:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  400b7c:	a801      	add	r0, sp, #4
  400b7e:	4b0e      	ldr	r3, [pc, #56]	; (400bb8 <_init_chip+0x40>)
  400b80:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  400b82:	4a0e      	ldr	r2, [pc, #56]	; (400bbc <_init_chip+0x44>)
  400b84:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  400b88:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400b8c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  400b90:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400b94:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  400b98:	a801      	add	r0, sp, #4
  400b9a:	4b09      	ldr	r3, [pc, #36]	; (400bc0 <_init_chip+0x48>)
  400b9c:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  400b9e:	4a09      	ldr	r2, [pc, #36]	; (400bc4 <_init_chip+0x4c>)
  400ba0:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  400ba2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  400ba6:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  400baa:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  400bac:	4b06      	ldr	r3, [pc, #24]	; (400bc8 <_init_chip+0x50>)
  400bae:	4798      	blx	r3
}
  400bb0:	b003      	add	sp, #12
  400bb2:	f85d fb04 	ldr.w	pc, [sp], #4
  400bb6:	bf00      	nop
  400bb8:	00400579 	.word	0x00400579
  400bbc:	e000ed00 	.word	0xe000ed00
  400bc0:	00400587 	.word	0x00400587
  400bc4:	400e0c00 	.word	0x400e0c00
  400bc8:	00400f25 	.word	0x00400f25

00400bcc <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  400bcc:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  400bce:	2500      	movs	r5, #0
  400bd0:	428d      	cmp	r5, r1
  400bd2:	d210      	bcs.n	400bf6 <_ffs+0x2a>
  400bd4:	2201      	movs	r2, #1
  400bd6:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400bd8:	2b1f      	cmp	r3, #31
  400bda:	d80a      	bhi.n	400bf2 <_ffs+0x26>
			if (v[i] & bit) {
  400bdc:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  400be0:	4222      	tst	r2, r4
  400be2:	d102      	bne.n	400bea <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400be4:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400be6:	3301      	adds	r3, #1
  400be8:	e7f6      	b.n	400bd8 <_ffs+0xc>
				return i * 32 + j;
  400bea:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  400bee:	bc30      	pop	{r4, r5}
  400bf0:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  400bf2:	3501      	adds	r5, #1
  400bf4:	e7ec      	b.n	400bd0 <_ffs+0x4>
	return -1;
  400bf6:	f04f 30ff 	mov.w	r0, #4294967295
  400bfa:	e7f8      	b.n	400bee <_ffs+0x22>

00400bfc <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  400bfc:	b510      	push	{r4, lr}
  400bfe:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  400c00:	2300      	movs	r3, #0
  400c02:	9301      	str	r3, [sp, #4]
  400c04:	9302      	str	r3, [sp, #8]
  400c06:	9303      	str	r3, [sp, #12]
  400c08:	9304      	str	r3, [sp, #16]
  400c0a:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  400c0c:	4b21      	ldr	r3, [pc, #132]	; (400c94 <_ext_irq_handler+0x98>)
  400c0e:	6818      	ldr	r0, [r3, #0]
  400c10:	22f8      	movs	r2, #248	; 0xf8
  400c12:	4921      	ldr	r1, [pc, #132]	; (400c98 <_ext_irq_handler+0x9c>)
  400c14:	3000      	adds	r0, #0
  400c16:	bf18      	it	ne
  400c18:	2001      	movne	r0, #1
  400c1a:	4b20      	ldr	r3, [pc, #128]	; (400c9c <_ext_irq_handler+0xa0>)
  400c1c:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  400c1e:	4b20      	ldr	r3, [pc, #128]	; (400ca0 <_ext_irq_handler+0xa4>)
  400c20:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400c22:	6c9b      	ldr	r3, [r3, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400c24:	4013      	ands	r3, r2
  400c26:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400c28:	491e      	ldr	r1, [pc, #120]	; (400ca4 <_ext_irq_handler+0xa8>)
  400c2a:	6cca      	ldr	r2, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400c2c:	6c89      	ldr	r1, [r1, #72]	; 0x48
	flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	flags[1] = hri_pio_read_ISR_reg(PIOB);
	flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400c2e:	400a      	ands	r2, r1
  400c30:	9202      	str	r2, [sp, #8]
	flag_total |= flags[1];
  400c32:	4313      	orrs	r3, r2
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400c34:	e025      	b.n	400c82 <_ext_irq_handler+0x86>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  400c36:	4b17      	ldr	r3, [pc, #92]	; (400c94 <_ext_irq_handler+0x98>)
  400c38:	681b      	ldr	r3, [r3, #0]
  400c3a:	4620      	mov	r0, r4
  400c3c:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  400c3e:	1163      	asrs	r3, r4, #5
  400c40:	f004 041f 	and.w	r4, r4, #31
  400c44:	2201      	movs	r2, #1
  400c46:	fa02 f404 	lsl.w	r4, r2, r4
  400c4a:	aa06      	add	r2, sp, #24
  400c4c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400c50:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400c54:	ea22 0204 	bic.w	r2, r2, r4
  400c58:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  400c5c:	2105      	movs	r1, #5
  400c5e:	a801      	add	r0, sp, #4
  400c60:	4b11      	ldr	r3, [pc, #68]	; (400ca8 <_ext_irq_handler+0xac>)
  400c62:	4798      	blx	r3
  400c64:	4604      	mov	r4, r0
		while (-1 != pos) {
  400c66:	f1b4 3fff 	cmp.w	r4, #4294967295
  400c6a:	d1e4      	bne.n	400c36 <_ext_irq_handler+0x3a>
	return ((Pio *)hw)->PIO_ISR;
  400c6c:	4a0c      	ldr	r2, [pc, #48]	; (400ca0 <_ext_irq_handler+0xa4>)
  400c6e:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400c70:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400c72:	400b      	ands	r3, r1
  400c74:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400c76:	490b      	ldr	r1, [pc, #44]	; (400ca4 <_ext_irq_handler+0xa8>)
  400c78:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400c7a:	6c8a      	ldr	r2, [r1, #72]	; 0x48
		flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
		flags[1] = hri_pio_read_ISR_reg(PIOB);
		flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400c7c:	4002      	ands	r2, r0
  400c7e:	9202      	str	r2, [sp, #8]
		flag_total |= flags[1];
  400c80:	4313      	orrs	r3, r2
	while (flag_total) {
  400c82:	b12b      	cbz	r3, 400c90 <_ext_irq_handler+0x94>
		pos = _ffs(flags, 5);
  400c84:	2105      	movs	r1, #5
  400c86:	a801      	add	r0, sp, #4
  400c88:	4b07      	ldr	r3, [pc, #28]	; (400ca8 <_ext_irq_handler+0xac>)
  400c8a:	4798      	blx	r3
  400c8c:	4604      	mov	r4, r0
		while (-1 != pos) {
  400c8e:	e7ea      	b.n	400c66 <_ext_irq_handler+0x6a>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  400c90:	b006      	add	sp, #24
  400c92:	bd10      	pop	{r4, pc}
  400c94:	20400098 	.word	0x20400098
  400c98:	00402ce4 	.word	0x00402ce4
  400c9c:	00400b29 	.word	0x00400b29
  400ca0:	400e0e00 	.word	0x400e0e00
  400ca4:	400e1000 	.word	0x400e1000
  400ca8:	00400bcd 	.word	0x00400bcd

00400cac <_pio_get_hardware_index>:
{
  400cac:	b510      	push	{r4, lr}
	ASSERT(hw);
  400cae:	4604      	mov	r4, r0
  400cb0:	22d2      	movs	r2, #210	; 0xd2
  400cb2:	4905      	ldr	r1, [pc, #20]	; (400cc8 <_pio_get_hardware_index+0x1c>)
  400cb4:	3000      	adds	r0, #0
  400cb6:	bf18      	it	ne
  400cb8:	2001      	movne	r0, #1
  400cba:	4b04      	ldr	r3, [pc, #16]	; (400ccc <_pio_get_hardware_index+0x20>)
  400cbc:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  400cbe:	4804      	ldr	r0, [pc, #16]	; (400cd0 <_pio_get_hardware_index+0x24>)
  400cc0:	4420      	add	r0, r4
}
  400cc2:	f3c0 2047 	ubfx	r0, r0, #9, #8
  400cc6:	bd10      	pop	{r4, pc}
  400cc8:	00402ce4 	.word	0x00402ce4
  400ccc:	00400b29 	.word	0x00400b29
  400cd0:	bff1f200 	.word	0xbff1f200

00400cd4 <_pio_get_index>:
{
  400cd4:	b510      	push	{r4, lr}
	ASSERT(hw);
  400cd6:	4604      	mov	r4, r0
  400cd8:	22e0      	movs	r2, #224	; 0xe0
  400cda:	490d      	ldr	r1, [pc, #52]	; (400d10 <_pio_get_index+0x3c>)
  400cdc:	3000      	adds	r0, #0
  400cde:	bf18      	it	ne
  400ce0:	2001      	movne	r0, #1
  400ce2:	4b0c      	ldr	r3, [pc, #48]	; (400d14 <_pio_get_index+0x40>)
  400ce4:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  400ce6:	4620      	mov	r0, r4
  400ce8:	4b0b      	ldr	r3, [pc, #44]	; (400d18 <_pio_get_index+0x44>)
  400cea:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400cec:	2300      	movs	r3, #0
  400cee:	2b01      	cmp	r3, #1
  400cf0:	d80b      	bhi.n	400d0a <_pio_get_index+0x36>
		if (_ext_irq[i].number == offset) {
  400cf2:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  400cf6:	008a      	lsls	r2, r1, #2
  400cf8:	4908      	ldr	r1, [pc, #32]	; (400d1c <_pio_get_index+0x48>)
  400cfa:	5c8a      	ldrb	r2, [r1, r2]
  400cfc:	4290      	cmp	r0, r2
  400cfe:	d002      	beq.n	400d06 <_pio_get_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400d00:	3301      	adds	r3, #1
  400d02:	b2db      	uxtb	r3, r3
  400d04:	e7f3      	b.n	400cee <_pio_get_index+0x1a>
			return i;
  400d06:	b258      	sxtb	r0, r3
  400d08:	bd10      	pop	{r4, pc}
	return ERR_INVALID_DATA;
  400d0a:	f04f 30ff 	mov.w	r0, #4294967295
}
  400d0e:	bd10      	pop	{r4, pc}
  400d10:	00402ce4 	.word	0x00402ce4
  400d14:	00400b29 	.word	0x00400b29
  400d18:	00400cad 	.word	0x00400cad
  400d1c:	00402ca4 	.word	0x00402ca4

00400d20 <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400d20:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400d22:	4604      	mov	r4, r0
  400d24:	f240 1259 	movw	r2, #345	; 0x159
  400d28:	4929      	ldr	r1, [pc, #164]	; (400dd0 <_pio_init+0xb0>)
  400d2a:	3000      	adds	r0, #0
  400d2c:	bf18      	it	ne
  400d2e:	2001      	movne	r0, #1
  400d30:	4b28      	ldr	r3, [pc, #160]	; (400dd4 <_pio_init+0xb4>)
  400d32:	4798      	blx	r3

	i = _pio_get_index(hw);
  400d34:	4620      	mov	r0, r4
  400d36:	4b28      	ldr	r3, [pc, #160]	; (400dd8 <_pio_init+0xb8>)
  400d38:	4798      	blx	r3
	if (i < 0) {
  400d3a:	2800      	cmp	r0, #0
  400d3c:	db43      	blt.n	400dc6 <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  400d3e:	4d27      	ldr	r5, [pc, #156]	; (400ddc <_pio_init+0xbc>)
  400d40:	00c2      	lsls	r2, r0, #3
  400d42:	1a11      	subs	r1, r2, r0
  400d44:	008b      	lsls	r3, r1, #2
  400d46:	442b      	add	r3, r5
  400d48:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  400d4a:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  400d4e:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400d50:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400d54:	6919      	ldr	r1, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  400d56:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
  400d5a:	699b      	ldr	r3, [r3, #24]
	((Pio *)hw)->PIO_FELLSR = mask;
  400d5c:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400d60:	1a10      	subs	r0, r2, r0
  400d62:	0083      	lsls	r3, r0, #2
  400d64:	442b      	add	r3, r5
  400d66:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  400d68:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  400d6c:	4620      	mov	r0, r4
  400d6e:	4b1c      	ldr	r3, [pc, #112]	; (400de0 <_pio_init+0xc0>)
  400d70:	4798      	blx	r3
  400d72:	4428      	add	r0, r5
  400d74:	f990 3038 	ldrsb.w	r3, [r0, #56]	; 0x38
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400d78:	2b00      	cmp	r3, #0
  400d7a:	db0c      	blt.n	400d96 <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400d7c:	095a      	lsrs	r2, r3, #5
  400d7e:	f003 001f 	and.w	r0, r3, #31
  400d82:	2101      	movs	r1, #1
  400d84:	4081      	lsls	r1, r0
  400d86:	3220      	adds	r2, #32
  400d88:	4816      	ldr	r0, [pc, #88]	; (400de4 <_pio_init+0xc4>)
  400d8a:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  400d8e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400d92:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400d96:	2b00      	cmp	r3, #0
  400d98:	db08      	blt.n	400dac <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400d9a:	095a      	lsrs	r2, r3, #5
  400d9c:	f003 001f 	and.w	r0, r3, #31
  400da0:	2101      	movs	r1, #1
  400da2:	4081      	lsls	r1, r0
  400da4:	3260      	adds	r2, #96	; 0x60
  400da6:	480f      	ldr	r0, [pc, #60]	; (400de4 <_pio_init+0xc4>)
  400da8:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  400dac:	2b00      	cmp	r3, #0
  400dae:	db0d      	blt.n	400dcc <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400db0:	0959      	lsrs	r1, r3, #5
  400db2:	f003 031f 	and.w	r3, r3, #31
  400db6:	2201      	movs	r2, #1
  400db8:	fa02 f303 	lsl.w	r3, r2, r3
  400dbc:	4a09      	ldr	r2, [pc, #36]	; (400de4 <_pio_init+0xc4>)
  400dbe:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  400dc2:	2000      	movs	r0, #0
  400dc4:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  400dc6:	f06f 0010 	mvn.w	r0, #16
  400dca:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  400dcc:	2000      	movs	r0, #0
}
  400dce:	bd38      	pop	{r3, r4, r5, pc}
  400dd0:	00402ce4 	.word	0x00402ce4
  400dd4:	00400b29 	.word	0x00400b29
  400dd8:	00400cd5 	.word	0x00400cd5
  400ddc:	00402ca4 	.word	0x00402ca4
  400de0:	00400cad 	.word	0x00400cad
  400de4:	e000e100 	.word	0xe000e100

00400de8 <PIOB_Handler>:
{
  400de8:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400dea:	4b01      	ldr	r3, [pc, #4]	; (400df0 <PIOB_Handler+0x8>)
  400dec:	4798      	blx	r3
  400dee:	bd08      	pop	{r3, pc}
  400df0:	00400bfd 	.word	0x00400bfd

00400df4 <PIOA_Handler>:
{
  400df4:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400df6:	4b01      	ldr	r3, [pc, #4]	; (400dfc <PIOA_Handler+0x8>)
  400df8:	4798      	blx	r3
  400dfa:	bd08      	pop	{r3, pc}
  400dfc:	00400bfd 	.word	0x00400bfd

00400e00 <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400e00:	b538      	push	{r3, r4, r5, lr}
  400e02:	4605      	mov	r5, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  400e04:	4804      	ldr	r0, [pc, #16]	; (400e18 <_ext_irq_init+0x18>)
  400e06:	4c05      	ldr	r4, [pc, #20]	; (400e1c <_ext_irq_init+0x1c>)
  400e08:	47a0      	blx	r4
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	_pio_init(PIOB);
  400e0a:	4805      	ldr	r0, [pc, #20]	; (400e20 <_ext_irq_init+0x20>)
  400e0c:	47a0      	blx	r4

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  400e0e:	4b05      	ldr	r3, [pc, #20]	; (400e24 <_ext_irq_init+0x24>)
  400e10:	601d      	str	r5, [r3, #0]

	return ERR_NONE;
}
  400e12:	2000      	movs	r0, #0
  400e14:	bd38      	pop	{r3, r4, r5, pc}
  400e16:	bf00      	nop
  400e18:	400e0e00 	.word	0x400e0e00
  400e1c:	00400d21 	.word	0x00400d21
  400e20:	400e1000 	.word	0x400e1000
  400e24:	20400098 	.word	0x20400098

00400e28 <_ext_irq_enable>:

	return ERR_NONE;
}

int32_t _ext_irq_enable(const uint32_t pin, const bool enable)
{
  400e28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  400e2c:	4604      	mov	r4, r0
  400e2e:	460f      	mov	r7, r1
	void *   hw   = PIOA;
	uint32_t temp = 0;

	ASSERT(pin < 160);
  400e30:	f8df 8050 	ldr.w	r8, [pc, #80]	; 400e84 <_ext_irq_enable+0x5c>
  400e34:	f44f 72d3 	mov.w	r2, #422	; 0x1a6
  400e38:	4641      	mov	r1, r8
  400e3a:	289f      	cmp	r0, #159	; 0x9f
  400e3c:	bf8c      	ite	hi
  400e3e:	2000      	movhi	r0, #0
  400e40:	2001      	movls	r0, #1
  400e42:	4e0e      	ldr	r6, [pc, #56]	; (400e7c <_ext_irq_enable+0x54>)
  400e44:	47b0      	blx	r6

	hw   = _get_hardware_instance(pin);
  400e46:	b2e5      	uxtb	r5, r4
	ASSERT(pin < 160);
  400e48:	22c3      	movs	r2, #195	; 0xc3
  400e4a:	4641      	mov	r1, r8
  400e4c:	2d9f      	cmp	r5, #159	; 0x9f
  400e4e:	bf8c      	ite	hi
  400e50:	2000      	movhi	r0, #0
  400e52:	2001      	movls	r0, #1
  400e54:	47b0      	blx	r6
	return (void *)((uint32_t)PIOA + (pin >> 5) * 0x200);
  400e56:	096d      	lsrs	r5, r5, #5
  400e58:	4b09      	ldr	r3, [pc, #36]	; (400e80 <_ext_irq_enable+0x58>)
  400e5a:	eb03 2545 	add.w	r5, r3, r5, lsl #9
	temp = pin & 31;
  400e5e:	f004 041f 	and.w	r4, r4, #31

	if (enable) {
  400e62:	b937      	cbnz	r7, 400e72 <_ext_irq_enable+0x4a>
		hri_pio_set_IMR_reg(hw, 1ul << temp);
	} else {
		hri_pio_clear_IMR_reg(hw, 1ul << temp);
  400e64:	2301      	movs	r3, #1
  400e66:	fa03 f404 	lsl.w	r4, r3, r4
	((Pio *)hw)->PIO_IDR = mask;
  400e6a:	646c      	str	r4, [r5, #68]	; 0x44
	}

	return ERR_NONE;
}
  400e6c:	2000      	movs	r0, #0
  400e6e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		hri_pio_set_IMR_reg(hw, 1ul << temp);
  400e72:	2301      	movs	r3, #1
  400e74:	fa03 f404 	lsl.w	r4, r3, r4
	((Pio *)hw)->PIO_IER = mask;
  400e78:	642c      	str	r4, [r5, #64]	; 0x40
  400e7a:	e7f7      	b.n	400e6c <_ext_irq_enable+0x44>
  400e7c:	00400b29 	.word	0x00400b29
  400e80:	400e0e00 	.word	0x400e0e00
  400e84:	00402ce4 	.word	0x00402ce4

00400e88 <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400e88:	490e      	ldr	r1, [pc, #56]	; (400ec4 <_pmc_init_sources+0x3c>)
  400e8a:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400e8c:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400e90:	4b0d      	ldr	r3, [pc, #52]	; (400ec8 <_pmc_init_sources+0x40>)
  400e92:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400e94:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400e96:	4b0b      	ldr	r3, [pc, #44]	; (400ec4 <_pmc_init_sources+0x3c>)
  400e98:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400e9a:	f013 0f01 	tst.w	r3, #1
  400e9e:	d0fa      	beq.n	400e96 <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400ea0:	4b08      	ldr	r3, [pc, #32]	; (400ec4 <_pmc_init_sources+0x3c>)
  400ea2:	6a19      	ldr	r1, [r3, #32]
  400ea4:	4a09      	ldr	r2, [pc, #36]	; (400ecc <_pmc_init_sources+0x44>)
  400ea6:	430a      	orrs	r2, r1
  400ea8:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400eaa:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400eac:	4a08      	ldr	r2, [pc, #32]	; (400ed0 <_pmc_init_sources+0x48>)
  400eae:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400eb0:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  400eb2:	4a08      	ldr	r2, [pc, #32]	; (400ed4 <_pmc_init_sources+0x4c>)
  400eb4:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400eb6:	4b03      	ldr	r3, [pc, #12]	; (400ec4 <_pmc_init_sources+0x3c>)
  400eb8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400eba:	f013 0f02 	tst.w	r3, #2
  400ebe:	d0fa      	beq.n	400eb6 <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  400ec0:	4770      	bx	lr
  400ec2:	bf00      	nop
  400ec4:	400e0600 	.word	0x400e0600
  400ec8:	00373e01 	.word	0x00373e01
  400ecc:	01370000 	.word	0x01370000
  400ed0:	f800ffff 	.word	0xf800ffff
  400ed4:	20183f01 	.word	0x20183f01

00400ed8 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400ed8:	4a11      	ldr	r2, [pc, #68]	; (400f20 <_pmc_init_master_clock+0x48>)
  400eda:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400edc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  400ee0:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400ee2:	4b0f      	ldr	r3, [pc, #60]	; (400f20 <_pmc_init_master_clock+0x48>)
  400ee4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400ee6:	f013 0f08 	tst.w	r3, #8
  400eea:	d0fa      	beq.n	400ee2 <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400eec:	4a0c      	ldr	r2, [pc, #48]	; (400f20 <_pmc_init_master_clock+0x48>)
  400eee:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  400ef0:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  400ef4:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400ef8:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400efa:	4b09      	ldr	r3, [pc, #36]	; (400f20 <_pmc_init_master_clock+0x48>)
  400efc:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400efe:	f013 0f08 	tst.w	r3, #8
  400f02:	d0fa      	beq.n	400efa <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400f04:	4a06      	ldr	r2, [pc, #24]	; (400f20 <_pmc_init_master_clock+0x48>)
  400f06:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400f08:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400f0c:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400f10:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400f12:	4b03      	ldr	r3, [pc, #12]	; (400f20 <_pmc_init_master_clock+0x48>)
  400f14:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400f16:	f013 0f08 	tst.w	r3, #8
  400f1a:	d0fa      	beq.n	400f12 <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  400f1c:	4770      	bx	lr
  400f1e:	bf00      	nop
  400f20:	400e0600 	.word	0x400e0600

00400f24 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  400f24:	b508      	push	{r3, lr}
	_pmc_init_sources();
  400f26:	4b02      	ldr	r3, [pc, #8]	; (400f30 <_pmc_init+0xc>)
  400f28:	4798      	blx	r3
	_pmc_init_master_clock();
  400f2a:	4b02      	ldr	r3, [pc, #8]	; (400f34 <_pmc_init+0x10>)
  400f2c:	4798      	blx	r3
  400f2e:	bd08      	pop	{r3, pc}
  400f30:	00400e89 	.word	0x00400e89
  400f34:	00400ed9 	.word	0x00400ed9

00400f38 <_pwm_get_cfg>:
 */
static const struct _pwm_cfg *_pwm_get_cfg(void *const hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  400f38:	2300      	movs	r3, #0
  400f3a:	b10b      	cbz	r3, 400f40 <_pwm_get_cfg+0x8>
		if (_pwms[i].hw == hw) {
			return (_pwms + i);
		}
	}

	return NULL;
  400f3c:	2000      	movs	r0, #0
}
  400f3e:	4770      	bx	lr
		if (_pwms[i].hw == hw) {
  400f40:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
  400f44:	008a      	lsls	r2, r1, #2
  400f46:	4906      	ldr	r1, [pc, #24]	; (400f60 <_pwm_get_cfg+0x28>)
  400f48:	588a      	ldr	r2, [r1, r2]
  400f4a:	4282      	cmp	r2, r0
  400f4c:	d002      	beq.n	400f54 <_pwm_get_cfg+0x1c>
	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  400f4e:	3301      	adds	r3, #1
  400f50:	b2db      	uxtb	r3, r3
  400f52:	e7f2      	b.n	400f3a <_pwm_get_cfg+0x2>
			return (_pwms + i);
  400f54:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  400f58:	009a      	lsls	r2, r3, #2
  400f5a:	4608      	mov	r0, r1
  400f5c:	4410      	add	r0, r2
  400f5e:	4770      	bx	lr
  400f60:	00402d00 	.word	0x00402d00

00400f64 <_pwm_init_irq_param>:
/**
 * \brief Init irq param with the given pwm hardware instance
 */
static void _pwm_init_irq_param(const void *const hw, struct _pwm_device *dev)
{
	if (hw == PWM0) {
  400f64:	4b03      	ldr	r3, [pc, #12]	; (400f74 <_pwm_init_irq_param+0x10>)
  400f66:	4298      	cmp	r0, r3
  400f68:	d000      	beq.n	400f6c <_pwm_init_irq_param+0x8>
  400f6a:	4770      	bx	lr
		_pwm0_dev = dev;
  400f6c:	4b02      	ldr	r3, [pc, #8]	; (400f78 <_pwm_init_irq_param+0x14>)
  400f6e:	6019      	str	r1, [r3, #0]
	}
}
  400f70:	e7fb      	b.n	400f6a <_pwm_init_irq_param+0x6>
  400f72:	bf00      	nop
  400f74:	40020000 	.word	0x40020000
  400f78:	2040009c 	.word	0x2040009c

00400f7c <_pwm_interrupt_handler>:
 * \internal interrupt handler for PWM
 *
 * \param[in] instance PWM instance number
 */
static void _pwm_interrupt_handler(struct _pwm_device *device)
{
  400f7c:	b508      	push	{r3, lr}
	if (hri_pwm_read_ISR1_reg(device->hw)) {
  400f7e:	6903      	ldr	r3, [r0, #16]
	return tmp;
}

static inline hri_pwm_isr1_reg_t hri_pwm_read_ISR1_reg(const void *const hw)
{
	return ((Pwm *)hw)->PWM_ISR1;
  400f80:	69db      	ldr	r3, [r3, #28]
  400f82:	b113      	cbz	r3, 400f8a <_pwm_interrupt_handler+0xe>
		if (NULL != device->callback.pwm_period_cb) {
  400f84:	6803      	ldr	r3, [r0, #0]
  400f86:	b103      	cbz	r3, 400f8a <_pwm_interrupt_handler+0xe>
			device->callback.pwm_period_cb(device);
  400f88:	4798      	blx	r3
  400f8a:	bd08      	pop	{r3, pc}

00400f8c <PWM0_Handler>:

/**
 * \internal PWM interrupt handler
 */
void PWM0_Handler(void)
{
  400f8c:	b508      	push	{r3, lr}
	_pwm_interrupt_handler(_pwm0_dev);
  400f8e:	4b02      	ldr	r3, [pc, #8]	; (400f98 <PWM0_Handler+0xc>)
  400f90:	6818      	ldr	r0, [r3, #0]
  400f92:	4b02      	ldr	r3, [pc, #8]	; (400f9c <PWM0_Handler+0x10>)
  400f94:	4798      	blx	r3
  400f96:	bd08      	pop	{r3, pc}
  400f98:	2040009c 	.word	0x2040009c
  400f9c:	00400f7d 	.word	0x00400f7d

00400fa0 <_pwm_init>:
}

int32_t _pwm_init(struct _pwm_device *const device, void *const hw)
{
  400fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400fa2:	4606      	mov	r6, r0
	ASSERT(hw);
  400fa4:	460c      	mov	r4, r1
  400fa6:	1c08      	adds	r0, r1, #0
  400fa8:	bf18      	it	ne
  400faa:	2001      	movne	r0, #1
  400fac:	f240 1271 	movw	r2, #369	; 0x171
  400fb0:	4944      	ldr	r1, [pc, #272]	; (4010c4 <_pwm_init+0x124>)
  400fb2:	4b45      	ldr	r3, [pc, #276]	; (4010c8 <_pwm_init+0x128>)
  400fb4:	4798      	blx	r3
	int8_t                      i;
	const struct _pwm_cfg *     cfg;
	const struct _pwm_ch_cfg *  ch;
	const struct _pwm_comp_cfg *comp;

	cfg = _pwm_get_cfg(hw);
  400fb6:	4620      	mov	r0, r4
  400fb8:	4b44      	ldr	r3, [pc, #272]	; (4010cc <_pwm_init+0x12c>)
  400fba:	4798      	blx	r3
  400fbc:	4605      	mov	r5, r0

	device->hw = hw;
  400fbe:	6134      	str	r4, [r6, #16]
	/* Init PMW */
	hri_pwm_write_CLK_reg(hw, cfg->pwm_clk);
  400fc0:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_pwm_write_CLK_reg(const void *const hw, hri_pwm_clk_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_CLK = data;
  400fc2:	6023      	str	r3, [r4, #0]
	hri_pwm_write_ELMR_reg(hw, 0, cfg->pwm_elmr0);
  400fc4:	68c3      	ldr	r3, [r0, #12]
}

static inline void hri_pwm_write_ELMR_reg(const void *const hw, uint8_t index, hri_pwm_elmr_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ELMR[index] = data;
  400fc6:	67e3      	str	r3, [r4, #124]	; 0x7c
	hri_pwm_write_ELMR_reg(hw, 1, cfg->pwm_elmr1);
  400fc8:	6903      	ldr	r3, [r0, #16]
  400fca:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	hri_pwm_write_FMR_reg(hw, cfg->pwm_fmr);
  400fce:	6943      	ldr	r3, [r0, #20]
	((Pwm *)hw)->PWM_FMR = data;
  400fd0:	65e3      	str	r3, [r4, #92]	; 0x5c
	hri_pwm_write_FPV1_reg(hw, cfg->pwm_fpv1);
  400fd2:	6983      	ldr	r3, [r0, #24]
	((Pwm *)hw)->PWM_FPV1 = data;
  400fd4:	66a3      	str	r3, [r4, #104]	; 0x68
	hri_pwm_write_FPV2_reg(hw, cfg->pwm_fpv2);
  400fd6:	69c3      	ldr	r3, [r0, #28]
}

static inline void hri_pwm_write_FPV2_reg(const void *const hw, hri_pwm_fpv2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_FPV2 = data;
  400fd8:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	hri_pwm_write_FPE_reg(hw, cfg->pwm_fpe);
  400fdc:	6a03      	ldr	r3, [r0, #32]
	((Pwm *)hw)->PWM_FPE = data;
  400fde:	66e3      	str	r3, [r4, #108]	; 0x6c
	hri_pwm_write_ETRG1_reg(hw, cfg->pwm_etrg1);
  400fe0:	6a43      	ldr	r3, [r0, #36]	; 0x24
}

static inline void hri_pwm_write_ETRG1_reg(const void *const hw, hri_pwm_etrg1_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG1 = data;
  400fe2:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	hri_pwm_write_ETRG2_reg(hw, cfg->pwm_etrg2);
  400fe6:	6a83      	ldr	r3, [r0, #40]	; 0x28
}

static inline void hri_pwm_write_ETRG2_reg(const void *const hw, hri_pwm_etrg2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG2 = data;
  400fe8:	f8c4 344c 	str.w	r3, [r4, #1100]	; 0x44c

	/* Init Channel */
	for (i = 0; i < cfg->ch_num; i++) {
  400fec:	2300      	movs	r3, #0
  400fee:	e019      	b.n	401024 <_pwm_init+0x84>
		ch = cfg->ch + i;
  400ff0:	6b2f      	ldr	r7, [r5, #48]	; 0x30
  400ff2:	0118      	lsls	r0, r3, #4
  400ff4:	eb07 0e00 	add.w	lr, r7, r0
		hri_pwm_write_CMR_reg(hw, ch->index, ch->mode);
  400ff8:	5c3a      	ldrb	r2, [r7, r0]
  400ffa:	f8de 1004 	ldr.w	r1, [lr, #4]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CMR = data;
  400ffe:	3210      	adds	r2, #16
  401000:	0152      	lsls	r2, r2, #5
  401002:	50a1      	str	r1, [r4, r2]
		hri_pwm_write_CDTY_reg(hw, ch->index, ch->duty_cycle);
  401004:	5c3a      	ldrb	r2, [r7, r0]
  401006:	f8de 100c 	ldr.w	r1, [lr, #12]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CDTY = data;
  40100a:	3210      	adds	r2, #16
  40100c:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  401010:	6051      	str	r1, [r2, #4]
		hri_pwm_write_CPRD_reg(hw, ch->index, ch->period);
  401012:	5c3a      	ldrb	r2, [r7, r0]
  401014:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CPRD = data;
  401018:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  40101c:	f8c2 120c 	str.w	r1, [r2, #524]	; 0x20c
	for (i = 0; i < cfg->ch_num; i++) {
  401020:	3301      	adds	r3, #1
  401022:	b25b      	sxtb	r3, r3
  401024:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  401026:	4293      	cmp	r3, r2
  401028:	d3e2      	bcc.n	400ff0 <_pwm_init+0x50>
  40102a:	2300      	movs	r3, #0
  40102c:	e014      	b.n	401058 <_pwm_init+0xb8>
	}
	/* Init comparison */
	for (i = 0; i < cfg->comp_num; i++) {
		comp = cfg->comp + i;
  40102e:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  401030:	eb03 0043 	add.w	r0, r3, r3, lsl #1
  401034:	0082      	lsls	r2, r0, #2
  401036:	eb01 0e02 	add.w	lr, r1, r2
		hri_pwm_write_CMPM_reg(hw, comp->index, comp->comp_cmpm);
  40103a:	5c88      	ldrb	r0, [r1, r2]
  40103c:	f8de 7004 	ldr.w	r7, [lr, #4]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPM = data;
  401040:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  401044:	f8c0 7138 	str.w	r7, [r0, #312]	; 0x138
		hri_pwm_write_CMPV_reg(hw, comp->index, comp->comp_cmpv);
  401048:	5c8a      	ldrb	r2, [r1, r2]
  40104a:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPV = data;
  40104e:	3213      	adds	r2, #19
  401050:	0112      	lsls	r2, r2, #4
  401052:	50a1      	str	r1, [r4, r2]
	for (i = 0; i < cfg->comp_num; i++) {
  401054:	3301      	adds	r3, #1
  401056:	b25b      	sxtb	r3, r3
  401058:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  40105a:	4293      	cmp	r3, r2
  40105c:	d3e7      	bcc.n	40102e <_pwm_init+0x8e>
	}

	_pwm_init_irq_param(hw, device);
  40105e:	4631      	mov	r1, r6
  401060:	4620      	mov	r0, r4
  401062:	4b1b      	ldr	r3, [pc, #108]	; (4010d0 <_pwm_init+0x130>)
  401064:	4798      	blx	r3
	NVIC_DisableIRQ(cfg->irq);
  401066:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  40106a:	2b00      	cmp	r3, #0
  40106c:	db0d      	blt.n	40108a <_pwm_init+0xea>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  40106e:	095a      	lsrs	r2, r3, #5
  401070:	f003 031f 	and.w	r3, r3, #31
  401074:	2101      	movs	r1, #1
  401076:	fa01 f303 	lsl.w	r3, r1, r3
  40107a:	3220      	adds	r2, #32
  40107c:	4915      	ldr	r1, [pc, #84]	; (4010d4 <_pwm_init+0x134>)
  40107e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  401082:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401086:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(cfg->irq);
  40108a:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  40108e:	2b00      	cmp	r3, #0
  401090:	db09      	blt.n	4010a6 <_pwm_init+0x106>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  401092:	095a      	lsrs	r2, r3, #5
  401094:	f003 031f 	and.w	r3, r3, #31
  401098:	2101      	movs	r1, #1
  40109a:	fa01 f303 	lsl.w	r3, r1, r3
  40109e:	3260      	adds	r2, #96	; 0x60
  4010a0:	490c      	ldr	r1, [pc, #48]	; (4010d4 <_pwm_init+0x134>)
  4010a2:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	NVIC_EnableIRQ(cfg->irq);
  4010a6:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  4010aa:	2b00      	cmp	r3, #0
  4010ac:	db08      	blt.n	4010c0 <_pwm_init+0x120>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4010ae:	0959      	lsrs	r1, r3, #5
  4010b0:	f003 031f 	and.w	r3, r3, #31
  4010b4:	2201      	movs	r2, #1
  4010b6:	fa02 f303 	lsl.w	r3, r2, r3
  4010ba:	4a06      	ldr	r2, [pc, #24]	; (4010d4 <_pwm_init+0x134>)
  4010bc:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

	return ERR_NONE;
}
  4010c0:	2000      	movs	r0, #0
  4010c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4010c4:	00402d4c 	.word	0x00402d4c
  4010c8:	00400b29 	.word	0x00400b29
  4010cc:	00400f39 	.word	0x00400f39
  4010d0:	00400f65 	.word	0x00400f65
  4010d4:	e000e100 	.word	0xe000e100

004010d8 <_pwm_get_pwm>:
 * \brief Retrieve pwm helper functions
 */
struct _pwm_hpl_interface *_pwm_get_pwm(void)
{
	return NULL;
}
  4010d8:	2000      	movs	r0, #0
  4010da:	4770      	bx	lr

004010dc <_spi_sync_enable>:
}

static inline void hri_spi_write_CR_reg(const void *const hw, hri_spi_cr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_CR = data;
  4010dc:	2301      	movs	r3, #1
  4010de:	6003      	str	r3, [r0, #0]
static int32_t _spi_sync_enable(void *const hw)
{
	hri_spi_write_CR_reg(hw, SPI_CR_SPIEN);

	return ERR_NONE;
}
  4010e0:	2000      	movs	r0, #0
  4010e2:	4770      	bx	lr

004010e4 <_spi_get_hardware_index>:
 * \brief Retrieve ordinal number of the given SPI hardware instance
 */
static uint8_t _spi_get_hardware_index(const void *const hw)
{

	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  4010e4:	4b04      	ldr	r3, [pc, #16]	; (4010f8 <_spi_get_hardware_index+0x14>)
  4010e6:	4403      	add	r3, r0
  4010e8:	f3c3 4307 	ubfx	r3, r3, #16, #8

	if (index == 5) {
  4010ec:	2b05      	cmp	r3, #5
  4010ee:	d001      	beq.n	4010f4 <_spi_get_hardware_index+0x10>
		return 1;
	} else {
		return 0;
  4010f0:	2000      	movs	r0, #0
	}
}
  4010f2:	4770      	bx	lr
		return 1;
  4010f4:	2001      	movs	r0, #1
  4010f6:	4770      	bx	lr
  4010f8:	bfff8000 	.word	0xbfff8000

004010fc <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  4010fc:	b570      	push	{r4, r5, r6, lr}
  4010fe:	4606      	mov	r6, r0
  401100:	460c      	mov	r4, r1
	uint8_t n = _spi_get_hardware_index((const void *)hw_addr);
  401102:	4608      	mov	r0, r1
  401104:	4b20      	ldr	r3, [pc, #128]	; (401188 <_spi_m_sync_init+0x8c>)
  401106:	4798      	blx	r3
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  401108:	2300      	movs	r3, #0
  40110a:	b33b      	cbz	r3, 40115c <_spi_m_sync_init+0x60>
	return NULL;
  40110c:	2500      	movs	r5, #0
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  40110e:	f44f 729a 	mov.w	r2, #308	; 0x134
  401112:	491e      	ldr	r1, [pc, #120]	; (40118c <_spi_m_sync_init+0x90>)
  401114:	2e00      	cmp	r6, #0
  401116:	bf18      	it	ne
  401118:	2c00      	cmpne	r4, #0
  40111a:	bf14      	ite	ne
  40111c:	2001      	movne	r0, #1
  40111e:	2000      	moveq	r0, #0
  401120:	4b1b      	ldr	r3, [pc, #108]	; (401190 <_spi_m_sync_init+0x94>)
  401122:	4798      	blx	r3

	if (regs == NULL) {
  401124:	b355      	cbz	r5, 40117c <_spi_m_sync_init+0x80>
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  401126:	6923      	ldr	r3, [r4, #16]
		return ERR_INVALID_ARG;
	}

	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  401128:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  40112c:	d129      	bne.n	401182 <_spi_m_sync_init+0x86>
	((Spi *)hw)->SPI_CR = data;
  40112e:	2380      	movs	r3, #128	; 0x80
  401130:	6023      	str	r3, [r4, #0]
		return ERR_DENIED;
	}
	hri_spi_write_CR_reg(hw, SPI_CR_SWRST);
	dev->prvt = hw;
  401132:	6034      	str	r4, [r6, #0]
	hri_spi_write_CR_reg(hw, (regs->cr & ~(SPI_CR_SPIEN | SPI_CR_SPIDIS | SPI_CR_SWRST | SPI_CR_LASTXFER)));
  401134:	686a      	ldr	r2, [r5, #4]
  401136:	4b17      	ldr	r3, [pc, #92]	; (401194 <_spi_m_sync_init+0x98>)
  401138:	4013      	ands	r3, r2
  40113a:	6023      	str	r3, [r4, #0]
	hri_spi_write_MR_reg(hw, ((regs->mr | SPI_MR_PCS(0x0E) | SPI_MR_MODFDIS) & ~SPI_MR_LLB));
  40113c:	68ab      	ldr	r3, [r5, #8]
  40113e:	4a16      	ldr	r2, [pc, #88]	; (401198 <_spi_m_sync_init+0x9c>)
  401140:	401a      	ands	r2, r3
  401142:	4b16      	ldr	r3, [pc, #88]	; (40119c <_spi_m_sync_init+0xa0>)
  401144:	4313      	orrs	r3, r2
	((Spi *)hw)->SPI_MR = data;
  401146:	6063      	str	r3, [r4, #4]
	hri_spi_write_CSR_reg(hw, 0, regs->csr);
  401148:	68eb      	ldr	r3, [r5, #12]
	((Spi *)hw)->SPI_CSR[index] = data;
  40114a:	6323      	str	r3, [r4, #48]	; 0x30

	dev->dummy_byte = regs->dummy_byte;
  40114c:	8a2b      	ldrh	r3, [r5, #16]
  40114e:	80f3      	strh	r3, [r6, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  401150:	68eb      	ldr	r3, [r5, #12]
  401152:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  401156:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
  401158:	2000      	movs	r0, #0
  40115a:	bd70      	pop	{r4, r5, r6, pc}
		if (spi_regs[i].number == n) {
  40115c:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  401160:	008a      	lsls	r2, r1, #2
  401162:	490f      	ldr	r1, [pc, #60]	; (4011a0 <_spi_m_sync_init+0xa4>)
  401164:	5c8a      	ldrb	r2, [r1, r2]
  401166:	4290      	cmp	r0, r2
  401168:	d002      	beq.n	401170 <_spi_m_sync_init+0x74>
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  40116a:	3301      	adds	r3, #1
  40116c:	b2db      	uxtb	r3, r3
  40116e:	e7cc      	b.n	40110a <_spi_m_sync_init+0xe>
			return &spi_regs[i];
  401170:	eb03 0583 	add.w	r5, r3, r3, lsl #2
  401174:	00ab      	lsls	r3, r5, #2
  401176:	460d      	mov	r5, r1
  401178:	441d      	add	r5, r3
  40117a:	e7c8      	b.n	40110e <_spi_m_sync_init+0x12>
		return ERR_INVALID_ARG;
  40117c:	f06f 000c 	mvn.w	r0, #12
  401180:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
  401182:	f06f 0010 	mvn.w	r0, #16
}
  401186:	bd70      	pop	{r4, r5, r6, pc}
  401188:	004010e5 	.word	0x004010e5
  40118c:	00402d78 	.word	0x00402d78
  401190:	00400b29 	.word	0x00400b29
  401194:	feffff7c 	.word	0xfeffff7c
  401198:	fff1ff6f 	.word	0xfff1ff6f
  40119c:	000e0010 	.word	0x000e0010
  4011a0:	00402d64 	.word	0x00402d64

004011a4 <_spi_m_sync_enable>:

	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
  4011a4:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  4011a6:	4604      	mov	r4, r0
  4011a8:	b168      	cbz	r0, 4011c6 <_spi_m_sync_enable+0x22>
  4011aa:	6803      	ldr	r3, [r0, #0]
  4011ac:	b14b      	cbz	r3, 4011c2 <_spi_m_sync_enable+0x1e>
  4011ae:	2001      	movs	r0, #1
  4011b0:	f44f 72b9 	mov.w	r2, #370	; 0x172
  4011b4:	4905      	ldr	r1, [pc, #20]	; (4011cc <_spi_m_sync_enable+0x28>)
  4011b6:	4b06      	ldr	r3, [pc, #24]	; (4011d0 <_spi_m_sync_enable+0x2c>)
  4011b8:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
  4011ba:	6820      	ldr	r0, [r4, #0]
  4011bc:	4b05      	ldr	r3, [pc, #20]	; (4011d4 <_spi_m_sync_enable+0x30>)
  4011be:	4798      	blx	r3
}
  4011c0:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
  4011c2:	2000      	movs	r0, #0
  4011c4:	e7f4      	b.n	4011b0 <_spi_m_sync_enable+0xc>
  4011c6:	2000      	movs	r0, #0
  4011c8:	e7f2      	b.n	4011b0 <_spi_m_sync_enable+0xc>
  4011ca:	bf00      	nop
  4011cc:	00402d78 	.word	0x00402d78
  4011d0:	00400b29 	.word	0x00400b29
  4011d4:	004010dd 	.word	0x004010dd

004011d8 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
  4011d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4011dc:	b086      	sub	sp, #24
  4011de:	4607      	mov	r7, r0
  4011e0:	460d      	mov	r5, r1
	void *                 hw   = dev->prvt;
  4011e2:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
  4011e4:	680b      	ldr	r3, [r1, #0]
  4011e6:	9301      	str	r3, [sp, #4]
  4011e8:	684b      	ldr	r3, [r1, #4]
  4011ea:	9302      	str	r3, [sp, #8]
  4011ec:	2300      	movs	r3, #0
  4011ee:	9303      	str	r3, [sp, #12]
  4011f0:	9304      	str	r3, [sp, #16]
  4011f2:	7903      	ldrb	r3, [r0, #4]
  4011f4:	f88d 3014 	strb.w	r3, [sp, #20]

	ASSERT(dev && hw);
  4011f8:	1c26      	adds	r6, r4, #0
  4011fa:	bf18      	it	ne
  4011fc:	2601      	movne	r6, #1
  4011fe:	f240 2231 	movw	r2, #561	; 0x231
  401202:	4933      	ldr	r1, [pc, #204]	; (4012d0 <_spi_m_sync_trans+0xf8>)
  401204:	2800      	cmp	r0, #0
  401206:	bf0c      	ite	eq
  401208:	2000      	moveq	r0, #0
  40120a:	f006 0001 	andne.w	r0, r6, #1
  40120e:	4b31      	ldr	r3, [pc, #196]	; (4012d4 <_spi_m_sync_trans+0xfc>)
  401210:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  401212:	6923      	ldr	r3, [r4, #16]

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_spi_get_SR_SPIENS_bit(hw)) {
  401214:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401218:	d122      	bne.n	401260 <_spi_m_sync_trans+0x88>
		return ERR_NOT_INITIALIZED;
  40121a:	f06f 0013 	mvn.w	r0, #19
  40121e:	e053      	b.n	4012c8 <_spi_m_sync_trans+0xf0>
		return false;
  401220:	2300      	movs	r3, #0
  401222:	e035      	b.n	401290 <_spi_m_sync_trans+0xb8>
			data |= (*ctrl->txbuf) << 8;
  401224:	7850      	ldrb	r0, [r2, #1]
  401226:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			ctrl->txbuf++;
  40122a:	3202      	adds	r2, #2
  40122c:	9201      	str	r2, [sp, #4]
	ctrl->txcnt++;
  40122e:	3301      	adds	r3, #1
  401230:	9303      	str	r3, [sp, #12]
}

static inline void hri_spi_write_TDR_reg(const void *const hw, hri_spi_tdr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_TDR = data;
  401232:	60e1      	str	r1, [r4, #12]
	return ((Spi *)hw)->SPI_SR;
  401234:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ASSERT(hw);
  401238:	f240 2222 	movw	r2, #546	; 0x222
  40123c:	4924      	ldr	r1, [pc, #144]	; (4012d0 <_spi_m_sync_trans+0xf8>)
  40123e:	4630      	mov	r0, r6
  401240:	4b24      	ldr	r3, [pc, #144]	; (4012d4 <_spi_m_sync_trans+0xfc>)
  401242:	4798      	blx	r3
	if (SPI_SR_OVRES & iflag) {
  401244:	f018 0f08 	tst.w	r8, #8
  401248:	d038      	beq.n	4012bc <_spi_m_sync_trans+0xe4>
		return ERR_OVERFLOW;
  40124a:	f06f 0012 	mvn.w	r0, #18
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
			}
		}
		rc = _spi_err_check(hri_spi_read_SR_reg(hw), hw);
		if (rc < 0) {
  40124e:	2800      	cmp	r0, #0
  401250:	db36      	blt.n	4012c0 <_spi_m_sync_trans+0xe8>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
  401252:	9803      	ldr	r0, [sp, #12]
  401254:	68ab      	ldr	r3, [r5, #8]
  401256:	4298      	cmp	r0, r3
  401258:	d302      	bcc.n	401260 <_spi_m_sync_trans+0x88>
  40125a:	9a04      	ldr	r2, [sp, #16]
  40125c:	4293      	cmp	r3, r2
  40125e:	d92f      	bls.n	4012c0 <_spi_m_sync_trans+0xe8>
  401260:	6923      	ldr	r3, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_RDRF)) {
  401262:	f013 0f01 	tst.w	r3, #1
  401266:	d0db      	beq.n	401220 <_spi_m_sync_trans+0x48>
	return (((Spi *)hw)->SPI_RDR & SPI_RDR_RD_Msk) >> SPI_RDR_RD_Pos;
  401268:	68a3      	ldr	r3, [r4, #8]
  40126a:	b29b      	uxth	r3, r3
	if (ctrl->rxbuf) {
  40126c:	9a02      	ldr	r2, [sp, #8]
  40126e:	b15a      	cbz	r2, 401288 <_spi_m_sync_trans+0xb0>
		*ctrl->rxbuf++ = (uint8_t)data;
  401270:	1c51      	adds	r1, r2, #1
  401272:	9102      	str	r1, [sp, #8]
  401274:	7013      	strb	r3, [r2, #0]
		if (ctrl->char_size > 1) {
  401276:	f89d 2014 	ldrb.w	r2, [sp, #20]
  40127a:	2a01      	cmp	r2, #1
  40127c:	d904      	bls.n	401288 <_spi_m_sync_trans+0xb0>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
  40127e:	460a      	mov	r2, r1
  401280:	3101      	adds	r1, #1
  401282:	9102      	str	r1, [sp, #8]
  401284:	0a1b      	lsrs	r3, r3, #8
  401286:	7013      	strb	r3, [r2, #0]
	ctrl->rxcnt++;
  401288:	9b04      	ldr	r3, [sp, #16]
  40128a:	3301      	adds	r3, #1
  40128c:	9304      	str	r3, [sp, #16]
	return true;
  40128e:	2301      	movs	r3, #1
		if (!_spi_rx_check_and_receive(hw, &ctrl)) {
  401290:	2b00      	cmp	r3, #0
  401292:	d1cf      	bne.n	401234 <_spi_m_sync_trans+0x5c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
  401294:	9b03      	ldr	r3, [sp, #12]
  401296:	9a04      	ldr	r2, [sp, #16]
  401298:	429a      	cmp	r2, r3
  40129a:	d3cb      	bcc.n	401234 <_spi_m_sync_trans+0x5c>
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
  40129c:	88f9      	ldrh	r1, [r7, #6]
	return ((Spi *)hw)->SPI_SR;
  40129e:	6922      	ldr	r2, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_TDRE)) {
  4012a0:	f012 0f02 	tst.w	r2, #2
  4012a4:	d0c6      	beq.n	401234 <_spi_m_sync_trans+0x5c>
	if (ctrl->txbuf) {
  4012a6:	9a01      	ldr	r2, [sp, #4]
  4012a8:	2a00      	cmp	r2, #0
  4012aa:	d0c0      	beq.n	40122e <_spi_m_sync_trans+0x56>
		data = *ctrl->txbuf++;
  4012ac:	1c51      	adds	r1, r2, #1
  4012ae:	9101      	str	r1, [sp, #4]
  4012b0:	7811      	ldrb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
  4012b2:	f89d 0014 	ldrb.w	r0, [sp, #20]
  4012b6:	2801      	cmp	r0, #1
  4012b8:	d8b4      	bhi.n	401224 <_spi_m_sync_trans+0x4c>
  4012ba:	e7b8      	b.n	40122e <_spi_m_sync_trans+0x56>
	return ERR_NONE;
  4012bc:	2000      	movs	r0, #0
  4012be:	e7c6      	b.n	40124e <_spi_m_sync_trans+0x76>
	tmp = ((Spi *)hw)->SPI_SR;
  4012c0:	6923      	ldr	r3, [r4, #16]
	while (!(hri_spi_get_SR_reg(hw, SPI_SR_TXEMPTY))) {
  4012c2:	f413 7f00 	tst.w	r3, #512	; 0x200
  4012c6:	d0fb      	beq.n	4012c0 <_spi_m_sync_trans+0xe8>

	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
  4012c8:	b006      	add	sp, #24
  4012ca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4012ce:	bf00      	nop
  4012d0:	00402d78 	.word	0x00402d78
  4012d4:	00400b29 	.word	0x00400b29

004012d8 <_spi_get_spi_m_sync>:
 * \brief Retrieve usart sync helper functions
 */
void *_spi_get_spi_m_sync(void)
{
	return (void *)NULL;
}
  4012d8:	2000      	movs	r0, #0
  4012da:	4770      	bx	lr

004012dc <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  4012dc:	4b03      	ldr	r3, [pc, #12]	; (4012ec <_system_time_init+0x10>)
  4012de:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  4012e2:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  4012e4:	2205      	movs	r2, #5
  4012e6:	601a      	str	r2, [r3, #0]
  4012e8:	4770      	bx	lr
  4012ea:	bf00      	nop
  4012ec:	e000e010 	.word	0xe000e010

004012f0 <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  4012f0:	b508      	push	{r3, lr}
	_system_time_init(hw);
  4012f2:	4b01      	ldr	r3, [pc, #4]	; (4012f8 <_delay_init+0x8>)
  4012f4:	4798      	blx	r3
  4012f6:	bd08      	pop	{r3, pc}
  4012f8:	004012dd 	.word	0x004012dd

004012fc <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
  4012fc:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
  4012fe:	e00d      	b.n	40131c <_delay_cycles+0x20>
		SysTick->LOAD = 0xFFFFFF;
  401300:	4b0d      	ldr	r3, [pc, #52]	; (401338 <_delay_cycles+0x3c>)
  401302:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
  401306:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
  401308:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  40130a:	4b0b      	ldr	r3, [pc, #44]	; (401338 <_delay_cycles+0x3c>)
  40130c:	681b      	ldr	r3, [r3, #0]
  40130e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401312:	d0fa      	beq.n	40130a <_delay_cycles+0xe>
			;
		buf -= 0xFFFFFF;
  401314:	f101 417f 	add.w	r1, r1, #4278190080	; 0xff000000
  401318:	3101      	adds	r1, #1
	while (n--) {
  40131a:	4610      	mov	r0, r2
  40131c:	1e43      	subs	r3, r0, #1
  40131e:	b2da      	uxtb	r2, r3
  401320:	2800      	cmp	r0, #0
  401322:	d1ed      	bne.n	401300 <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
  401324:	4b04      	ldr	r3, [pc, #16]	; (401338 <_delay_cycles+0x3c>)
  401326:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
  401328:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  40132a:	4b03      	ldr	r3, [pc, #12]	; (401338 <_delay_cycles+0x3c>)
  40132c:	681b      	ldr	r3, [r3, #0]
  40132e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401332:	d0fa      	beq.n	40132a <_delay_cycles+0x2e>
		;
}
  401334:	4770      	bx	lr
  401336:	bf00      	nop
  401338:	e000e010 	.word	0xe000e010

0040133c <_get_i2cm_sync_cfg>:
 */
static const struct _i2cm_sync_cfg *_get_i2cm_sync_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  40133c:	2300      	movs	r3, #0
  40133e:	b13b      	cbz	r3, 401350 <_get_i2cm_sync_cfg+0x14>
		if (_i2cm_sync_cfgs[i].hw == hw) {
			return &(_i2cm_sync_cfgs[i]);
		}
	}
	return NULL;
  401340:	2000      	movs	r0, #0
  401342:	4770      	bx	lr
			return &(_i2cm_sync_cfgs[i]);
  401344:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  401348:	00e3      	lsls	r3, r4, #3
  40134a:	4608      	mov	r0, r1
  40134c:	4418      	add	r0, r3
  40134e:	e00c      	b.n	40136a <_get_i2cm_sync_cfg+0x2e>
{
  401350:	b410      	push	{r4}
		if (_i2cm_sync_cfgs[i].hw == hw) {
  401352:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  401356:	00ca      	lsls	r2, r1, #3
  401358:	4905      	ldr	r1, [pc, #20]	; (401370 <_get_i2cm_sync_cfg+0x34>)
  40135a:	588a      	ldr	r2, [r1, r2]
  40135c:	4282      	cmp	r2, r0
  40135e:	d0f1      	beq.n	401344 <_get_i2cm_sync_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  401360:	3301      	adds	r3, #1
  401362:	b2db      	uxtb	r3, r3
  401364:	2b00      	cmp	r3, #0
  401366:	d0f4      	beq.n	401352 <_get_i2cm_sync_cfg+0x16>
	return NULL;
  401368:	2000      	movs	r0, #0
}
  40136a:	f85d 4b04 	ldr.w	r4, [sp], #4
  40136e:	4770      	bx	lr
  401370:	00402d90 	.word	0x00402d90

00401374 <_i2c_m_sync_init>:

int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const dev, void *const hw)
{
  401374:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && hw);
  401376:	4604      	mov	r4, r0
  401378:	460d      	mov	r5, r1
  40137a:	2800      	cmp	r0, #0
  40137c:	bf18      	it	ne
  40137e:	2900      	cmpne	r1, #0
  401380:	bf14      	ite	ne
  401382:	2001      	movne	r0, #1
  401384:	2000      	moveq	r0, #0
  401386:	2278      	movs	r2, #120	; 0x78
  401388:	4909      	ldr	r1, [pc, #36]	; (4013b0 <_i2c_m_sync_init+0x3c>)
  40138a:	4b0a      	ldr	r3, [pc, #40]	; (4013b4 <_i2c_m_sync_init+0x40>)
  40138c:	4798      	blx	r3

	const struct _i2cm_sync_cfg *cfg;

	dev->hw = hw;
  40138e:	6125      	str	r5, [r4, #16]
	cfg     = _get_i2cm_sync_cfg(dev->hw);
  401390:	4628      	mov	r0, r5
  401392:	4b09      	ldr	r3, [pc, #36]	; (4013b8 <_i2c_m_sync_init+0x44>)
  401394:	4798      	blx	r3

	// hri_twihs_write_CR_reg(hw, TWIHS_CR_SWRST);
	// hri_twihs_read_RHR_reg(hw);
	hri_twihs_write_CR_reg(dev->hw, cfg->ctrl);
  401396:	6843      	ldr	r3, [r0, #4]
}

static inline void hri_twihs_write_CR_reg(const void *const hw, hri_twihs_cr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_CR = data;
  401398:	602b      	str	r3, [r5, #0]
	hri_twihs_write_SMBTR_reg(dev->hw, cfg->smbtr);
  40139a:	6923      	ldr	r3, [r4, #16]
  40139c:	6882      	ldr	r2, [r0, #8]
	((Twihs *)hw)->TWIHS_SMBTR = data;
  40139e:	639a      	str	r2, [r3, #56]	; 0x38
	hri_twihs_write_FILTR_reg(dev->hw, cfg->filtr);
  4013a0:	6923      	ldr	r3, [r4, #16]
  4013a2:	68c2      	ldr	r2, [r0, #12]
	((Twihs *)hw)->TWIHS_FILTR = data;
  4013a4:	645a      	str	r2, [r3, #68]	; 0x44
	hri_twihs_write_CWGR_reg(dev->hw, cfg->cwgr);
  4013a6:	6923      	ldr	r3, [r4, #16]
  4013a8:	6902      	ldr	r2, [r0, #16]
	((Twihs *)hw)->TWIHS_CWGR = data;
  4013aa:	611a      	str	r2, [r3, #16]

	return ERR_NONE;
}
  4013ac:	2000      	movs	r0, #0
  4013ae:	bd38      	pop	{r3, r4, r5, pc}
  4013b0:	00402da8 	.word	0x00402da8
  4013b4:	00400b29 	.word	0x00400b29
  4013b8:	0040133d 	.word	0x0040133d

004013bc <_i2c_m_sync_transfer>:

	return ERR_NONE;
}

int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
  4013bc:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && msg);
  4013be:	4604      	mov	r4, r0
  4013c0:	460d      	mov	r5, r1
  4013c2:	2800      	cmp	r0, #0
  4013c4:	bf18      	it	ne
  4013c6:	2900      	cmpne	r1, #0
  4013c8:	bf14      	ite	ne
  4013ca:	2001      	movne	r0, #1
  4013cc:	2000      	moveq	r0, #0
  4013ce:	22ba      	movs	r2, #186	; 0xba
  4013d0:	4952      	ldr	r1, [pc, #328]	; (40151c <_i2c_m_sync_transfer+0x160>)
  4013d2:	4b53      	ldr	r3, [pc, #332]	; (401520 <_i2c_m_sync_transfer+0x164>)
  4013d4:	4798      	blx	r3

	if (dev->service.msg.flags & I2C_M_BUSY) {
  4013d6:	8863      	ldrh	r3, [r4, #2]
  4013d8:	f413 7f80 	tst.w	r3, #256	; 0x100
  4013dc:	f040 809a 	bne.w	401514 <_i2c_m_sync_transfer+0x158>
		return I2C_ERR_BUSY;
	}

	if (msg->flags & I2C_M_RD) {
  4013e0:	886b      	ldrh	r3, [r5, #2]
  4013e2:	f013 0f01 	tst.w	r3, #1
  4013e6:	d118      	bne.n	40141a <_i2c_m_sync_transfer+0x5e>
{
	uint32_t i;
	uint32_t sr;
	int      ret = ERR_NONE;

	msg->flags |= I2C_M_BUSY;
  4013e8:	886b      	ldrh	r3, [r5, #2]
  4013ea:	b29b      	uxth	r3, r3
  4013ec:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4013f0:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  4013f2:	882b      	ldrh	r3, [r5, #0]
  4013f4:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4013f8:	d05f      	beq.n	4014ba <_i2c_m_sync_transfer+0xfe>
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1));
  4013fa:	6922      	ldr	r2, [r4, #16]
  4013fc:	0a1b      	lsrs	r3, r3, #8
  4013fe:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401402:	041b      	lsls	r3, r3, #16
  401404:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401408:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Twihs *)hw)->TWIHS_MMR = data;
  40140c:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  40140e:	6923      	ldr	r3, [r4, #16]
  401410:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401412:	60da      	str	r2, [r3, #12]
	for (i = 0; i < msg->len; i++) {
		/* Wait for data is transferred from TWIHS_THR or if NACK is detected */
		do {
			sr = hri_twihs_read_SR_reg(dev->hw);
			if (sr & TWIHS_SR_NACK) {
				ret = I2C_NACK;
  401414:	2000      	movs	r0, #0
  401416:	4601      	mov	r1, r0
  401418:	e05c      	b.n	4014d4 <_i2c_m_sync_transfer+0x118>

static inline int32_t _i2c_m_sync_read(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
	uint32_t i;

	msg->flags |= I2C_M_BUSY;
  40141a:	886b      	ldrh	r3, [r5, #2]
  40141c:	b29b      	uxth	r3, r3
  40141e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401422:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401424:	882b      	ldrh	r3, [r5, #0]
  401426:	f413 6f80 	tst.w	r3, #1024	; 0x400
  40142a:	d022      	beq.n	401472 <_i2c_m_sync_transfer+0xb6>
		hri_twihs_write_MMR_reg(dev->hw,
  40142c:	6922      	ldr	r2, [r4, #16]
		                        TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1) | TWIHS_MMR_MREAD);
  40142e:	0a1b      	lsrs	r3, r3, #8
  401430:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401434:	041b      	lsls	r3, r3, #16
  401436:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  40143a:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
	((Twihs *)hw)->TWIHS_MMR = data;
  40143e:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  401440:	6923      	ldr	r3, [r4, #16]
  401442:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401444:	60da      	str	r2, [r3, #12]
	} else {
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
	}
	/* In single data byte master read, the START and STOP must both be set */
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  401446:	6923      	ldr	r3, [r4, #16]
  401448:	686a      	ldr	r2, [r5, #4]
  40144a:	2a01      	cmp	r2, #1
  40144c:	d019      	beq.n	401482 <_i2c_m_sync_transfer+0xc6>
  40144e:	2201      	movs	r2, #1
	((Twihs *)hw)->TWIHS_CR = data;
  401450:	601a      	str	r2, [r3, #0]

	for (i = 0; i < msg->len; i++) {
  401452:	2100      	movs	r1, #0
  401454:	686b      	ldr	r3, [r5, #4]
  401456:	4299      	cmp	r1, r3
  401458:	d222      	bcs.n	4014a0 <_i2c_m_sync_transfer+0xe4>
		/* Wait for a byte has been received in TWIHS_RHR since last read */
		while (!hri_twihs_get_SR_RXRDY_bit(dev->hw)) {
  40145a:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_RXRDY) > 0;
  40145c:	6a1a      	ldr	r2, [r3, #32]
  40145e:	f012 0f02 	tst.w	r2, #2
  401462:	d110      	bne.n	401486 <_i2c_m_sync_transfer+0xca>
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_NACK) > 0;
  401464:	6a1b      	ldr	r3, [r3, #32]
			/* Check whether slave acknowledge received after the address byte */
			if (hri_twihs_get_SR_NACK_bit(dev->hw))
  401466:	f413 7f80 	tst.w	r3, #256	; 0x100
  40146a:	d0f6      	beq.n	40145a <_i2c_m_sync_transfer+0x9e>
				return I2C_NACK;
  40146c:	f06f 0001 	mvn.w	r0, #1
		return _i2c_m_sync_read(dev, msg);
  401470:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
  401472:	6922      	ldr	r2, [r4, #16]
  401474:	041b      	lsls	r3, r3, #16
  401476:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  40147a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Twihs *)hw)->TWIHS_MMR = data;
  40147e:	6053      	str	r3, [r2, #4]
  401480:	e7e1      	b.n	401446 <_i2c_m_sync_transfer+0x8a>
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  401482:	2203      	movs	r2, #3
  401484:	e7e4      	b.n	401450 <_i2c_m_sync_transfer+0x94>
		};

		msg->buffer[i] = hri_twihs_read_RHR_reg(dev->hw);
  401486:	68aa      	ldr	r2, [r5, #8]
	return ((Twihs *)hw)->TWIHS_RHR;
  401488:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40148a:	5453      	strb	r3, [r2, r1]
		/* In multiple data bytes master read, the STOP must be set after the
		 * last data received but one */
		if (i == (msg->len - 2)) {
  40148c:	686b      	ldr	r3, [r5, #4]
  40148e:	3b02      	subs	r3, #2
  401490:	4299      	cmp	r1, r3
  401492:	d001      	beq.n	401498 <_i2c_m_sync_transfer+0xdc>
	for (i = 0; i < msg->len; i++) {
  401494:	3101      	adds	r1, #1
  401496:	e7dd      	b.n	401454 <_i2c_m_sync_transfer+0x98>
			hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401498:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  40149a:	2202      	movs	r2, #2
  40149c:	601a      	str	r2, [r3, #0]
  40149e:	e7f9      	b.n	401494 <_i2c_m_sync_transfer+0xd8>
		}
	}

	while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  4014a0:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  4014a2:	6a1b      	ldr	r3, [r3, #32]
  4014a4:	f013 0f01 	tst.w	r3, #1
  4014a8:	d0fa      	beq.n	4014a0 <_i2c_m_sync_transfer+0xe4>
	};
	dev->service.msg.flags &= ~I2C_M_BUSY;
  4014aa:	8863      	ldrh	r3, [r4, #2]
  4014ac:	b29b      	uxth	r3, r3
  4014ae:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  4014b2:	b29b      	uxth	r3, r3
  4014b4:	8063      	strh	r3, [r4, #2]

	return ERR_NONE;
  4014b6:	2000      	movs	r0, #0
  4014b8:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr));
  4014ba:	6922      	ldr	r2, [r4, #16]
  4014bc:	041b      	lsls	r3, r3, #16
  4014be:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
	((Twihs *)hw)->TWIHS_MMR = data;
  4014c2:	6053      	str	r3, [r2, #4]
  4014c4:	e7a6      	b.n	401414 <_i2c_m_sync_transfer+0x58>
				ret = I2C_NACK;
  4014c6:	f06f 0001 	mvn.w	r0, #1
		if (ret != ERR_NONE)
  4014ca:	b978      	cbnz	r0, 4014ec <_i2c_m_sync_transfer+0x130>
		hri_twihs_write_THR_reg(dev->hw, msg->buffer[i]);
  4014cc:	68ab      	ldr	r3, [r5, #8]
  4014ce:	5c5b      	ldrb	r3, [r3, r1]
}

static inline void hri_twihs_write_THR_reg(const void *const hw, hri_twihs_thr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_THR = data;
  4014d0:	6353      	str	r3, [r2, #52]	; 0x34
	for (i = 0; i < msg->len; i++) {
  4014d2:	3101      	adds	r1, #1
  4014d4:	686b      	ldr	r3, [r5, #4]
  4014d6:	4299      	cmp	r1, r3
  4014d8:	d208      	bcs.n	4014ec <_i2c_m_sync_transfer+0x130>
			sr = hri_twihs_read_SR_reg(dev->hw);
  4014da:	6922      	ldr	r2, [r4, #16]
	return ((Twihs *)hw)->TWIHS_SR;
  4014dc:	6a13      	ldr	r3, [r2, #32]
			if (sr & TWIHS_SR_NACK) {
  4014de:	f413 7f80 	tst.w	r3, #256	; 0x100
  4014e2:	d1f0      	bne.n	4014c6 <_i2c_m_sync_transfer+0x10a>
		} while (!(sr & TWIHS_SR_TXRDY));
  4014e4:	f013 0f04 	tst.w	r3, #4
  4014e8:	d0f7      	beq.n	4014da <_i2c_m_sync_transfer+0x11e>
  4014ea:	e7ee      	b.n	4014ca <_i2c_m_sync_transfer+0x10e>
	if (msg->flags & I2C_M_STOP) {
  4014ec:	886b      	ldrh	r3, [r5, #2]
  4014ee:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  4014f2:	d106      	bne.n	401502 <_i2c_m_sync_transfer+0x146>
	dev->service.msg.flags &= ~I2C_M_BUSY;
  4014f4:	8863      	ldrh	r3, [r4, #2]
  4014f6:	b29b      	uxth	r3, r3
  4014f8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  4014fc:	b29b      	uxth	r3, r3
  4014fe:	8063      	strh	r3, [r4, #2]
		return _i2c_m_sync_write(dev, msg);
  401500:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401502:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401504:	2202      	movs	r2, #2
  401506:	601a      	str	r2, [r3, #0]
		while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401508:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  40150a:	6a1b      	ldr	r3, [r3, #32]
  40150c:	f013 0f01 	tst.w	r3, #1
  401510:	d0fa      	beq.n	401508 <_i2c_m_sync_transfer+0x14c>
  401512:	e7ef      	b.n	4014f4 <_i2c_m_sync_transfer+0x138>
		return I2C_ERR_BUSY;
  401514:	f06f 0005 	mvn.w	r0, #5
}
  401518:	bd38      	pop	{r3, r4, r5, pc}
  40151a:	bf00      	nop
  40151c:	00402da8 	.word	0x00402da8
  401520:	00400b29 	.word	0x00400b29

00401524 <_usart_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given usart hardware instance
 */
static uint8_t _usart_get_hardware_index(const void *const hw)
{
  401524:	b510      	push	{r4, lr}
	ASSERT(hw);
  401526:	4604      	mov	r4, r0
  401528:	f240 222b 	movw	r2, #555	; 0x22b
  40152c:	4905      	ldr	r1, [pc, #20]	; (401544 <_usart_get_hardware_index+0x20>)
  40152e:	3000      	adds	r0, #0
  401530:	bf18      	it	ne
  401532:	2001      	movne	r0, #1
  401534:	4b04      	ldr	r3, [pc, #16]	; (401548 <_usart_get_hardware_index+0x24>)
  401536:	4798      	blx	r3

#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)USART0) / sizeof(Usart);
#endif

	return ((uint32_t)hw - (uint32_t)USART0) >> 14;
  401538:	4804      	ldr	r0, [pc, #16]	; (40154c <_usart_get_hardware_index+0x28>)
  40153a:	4420      	add	r0, r4
}
  40153c:	f3c0 3087 	ubfx	r0, r0, #14, #8
  401540:	bd10      	pop	{r4, pc}
  401542:	bf00      	nop
  401544:	00402dd0 	.word	0x00402dd0
  401548:	00400b29 	.word	0x00400b29
  40154c:	bffdc000 	.word	0xbffdc000

00401550 <_get_usart_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given usart hardware instance
 */
static uint8_t _get_usart_index(const void *const hw)
{
  401550:	b510      	push	{r4, lr}
	ASSERT(hw);
  401552:	4604      	mov	r4, r0
  401554:	f240 2287 	movw	r2, #647	; 0x287
  401558:	490e      	ldr	r1, [pc, #56]	; (401594 <_get_usart_index+0x44>)
  40155a:	3000      	adds	r0, #0
  40155c:	bf18      	it	ne
  40155e:	2001      	movne	r0, #1
  401560:	4b0d      	ldr	r3, [pc, #52]	; (401598 <_get_usart_index+0x48>)
  401562:	4798      	blx	r3
	uint8_t usart_offset = _usart_get_hardware_index(hw);
  401564:	4620      	mov	r0, r4
  401566:	4b0d      	ldr	r3, [pc, #52]	; (40159c <_get_usart_index+0x4c>)
  401568:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  40156a:	2300      	movs	r3, #0
  40156c:	b143      	cbz	r3, 401580 <_get_usart_index+0x30>
		if (_usarts[i].number == usart_offset) {
			return i;
		}
	}

	ASSERT(false);
  40156e:	f240 2291 	movw	r2, #657	; 0x291
  401572:	4908      	ldr	r1, [pc, #32]	; (401594 <_get_usart_index+0x44>)
  401574:	2000      	movs	r0, #0
  401576:	4b08      	ldr	r3, [pc, #32]	; (401598 <_get_usart_index+0x48>)
  401578:	4798      	blx	r3
	return 0;
  40157a:	2300      	movs	r3, #0
}
  40157c:	4618      	mov	r0, r3
  40157e:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == usart_offset) {
  401580:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  401584:	008a      	lsls	r2, r1, #2
  401586:	4906      	ldr	r1, [pc, #24]	; (4015a0 <_get_usart_index+0x50>)
  401588:	5c8a      	ldrb	r2, [r1, r2]
  40158a:	4290      	cmp	r0, r2
  40158c:	d0f6      	beq.n	40157c <_get_usart_index+0x2c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  40158e:	3301      	adds	r3, #1
  401590:	b2db      	uxtb	r3, r3
  401592:	e7eb      	b.n	40156c <_get_usart_index+0x1c>
  401594:	00402dd0 	.word	0x00402dd0
  401598:	00400b29 	.word	0x00400b29
  40159c:	00401525 	.word	0x00401525
  4015a0:	00402dc4 	.word	0x00402dc4

004015a4 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
  4015a4:	b510      	push	{r4, lr}
	ASSERT(hw);
  4015a6:	4604      	mov	r4, r0
  4015a8:	f240 229e 	movw	r2, #670	; 0x29e
  4015ac:	4911      	ldr	r1, [pc, #68]	; (4015f4 <_usart_init+0x50>)
  4015ae:	3000      	adds	r0, #0
  4015b0:	bf18      	it	ne
  4015b2:	2001      	movne	r0, #1
  4015b4:	4b10      	ldr	r3, [pc, #64]	; (4015f8 <_usart_init+0x54>)
  4015b6:	4798      	blx	r3
	uint8_t i = _get_usart_index(hw);
  4015b8:	4620      	mov	r0, r4
  4015ba:	4b10      	ldr	r3, [pc, #64]	; (4015fc <_usart_init+0x58>)
  4015bc:	4798      	blx	r3
}

static inline void hri_usart_write_US_WPMR_reg(const void *const hw, hri_usart_us_wpmr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_WPMR = data;
  4015be:	4b10      	ldr	r3, [pc, #64]	; (401600 <_usart_init+0x5c>)
  4015c0:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	((Usart *)hw)->US_MR = data;
  4015c4:	2300      	movs	r3, #0
  4015c6:	6063      	str	r3, [r4, #4]
	((Usart *)hw)->US_RTOR = data;
  4015c8:	6263      	str	r3, [r4, #36]	; 0x24
	((Usart *)hw)->US_TTGR = data;
  4015ca:	62a3      	str	r3, [r4, #40]	; 0x28
}

static inline void hri_usart_write_US_CR_reg(const void *const hw, hri_usart_us_cr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_CR = data;
  4015cc:	22ac      	movs	r2, #172	; 0xac
  4015ce:	6022      	str	r2, [r4, #0]
  4015d0:	f44f 7280 	mov.w	r2, #256	; 0x100
  4015d4:	6022      	str	r2, [r4, #0]
  4015d6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  4015da:	6022      	str	r2, [r4, #0]
	/* Reset status bits. */
	hri_usart_write_US_CR_reg(hw, US_CR_RSTSTA);
	/* Turn off RTS and DTR if exist. */
	hri_usart_write_US_CR_reg(hw, US_CR_USART_RTSDIS);

	hri_usart_write_US_MR_reg(hw, _usarts[i].us_mr);
  4015dc:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  4015e0:	0081      	lsls	r1, r0, #2
  4015e2:	4a08      	ldr	r2, [pc, #32]	; (401604 <_usart_init+0x60>)
  4015e4:	440a      	add	r2, r1
  4015e6:	6852      	ldr	r2, [r2, #4]
	((Usart *)hw)->US_MR = data;
  4015e8:	6062      	str	r2, [r4, #4]
	((Usart *)hw)->US_BRGR = data;
  4015ea:	4a07      	ldr	r2, [pc, #28]	; (401608 <_usart_init+0x64>)
  4015ec:	6222      	str	r2, [r4, #32]
	hri_usart_write_US_BRGR_reg(hw, _usarts[i].us_brgr);

	return ERR_NONE;
}
  4015ee:	4618      	mov	r0, r3
  4015f0:	bd10      	pop	{r4, pc}
  4015f2:	bf00      	nop
  4015f4:	00402dd0 	.word	0x00402dd0
  4015f8:	00400b29 	.word	0x00400b29
  4015fc:	00401551 	.word	0x00401551
  401600:	55534100 	.word	0x55534100
  401604:	00402dc4 	.word	0x00402dc4
  401608:	000100f4 	.word	0x000100f4

0040160c <_usart_sync_init>:
{
  40160c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40160e:	460c      	mov	r4, r1
	ASSERT(device);
  401610:	4e09      	ldr	r6, [pc, #36]	; (401638 <_usart_sync_init+0x2c>)
  401612:	4607      	mov	r7, r0
  401614:	22bd      	movs	r2, #189	; 0xbd
  401616:	4631      	mov	r1, r6
  401618:	3000      	adds	r0, #0
  40161a:	bf18      	it	ne
  40161c:	2001      	movne	r0, #1
  40161e:	4d07      	ldr	r5, [pc, #28]	; (40163c <_usart_sync_init+0x30>)
  401620:	47a8      	blx	r5
	ASSERT(hw);
  401622:	22be      	movs	r2, #190	; 0xbe
  401624:	4631      	mov	r1, r6
  401626:	1c20      	adds	r0, r4, #0
  401628:	bf18      	it	ne
  40162a:	2001      	movne	r0, #1
  40162c:	47a8      	blx	r5
	device->hw = hw;
  40162e:	603c      	str	r4, [r7, #0]
	return _usart_init(hw);
  401630:	4620      	mov	r0, r4
  401632:	4b03      	ldr	r3, [pc, #12]	; (401640 <_usart_sync_init+0x34>)
  401634:	4798      	blx	r3
}
  401636:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401638:	00402dd0 	.word	0x00402dd0
  40163c:	00400b29 	.word	0x00400b29
  401640:	004015a5 	.word	0x004015a5

00401644 <_usart_sync_enable>:
{
  401644:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
  401646:	4e0a      	ldr	r6, [pc, #40]	; (401670 <_usart_sync_enable+0x2c>)
  401648:	4604      	mov	r4, r0
  40164a:	f240 1205 	movw	r2, #261	; 0x105
  40164e:	4631      	mov	r1, r6
  401650:	3000      	adds	r0, #0
  401652:	bf18      	it	ne
  401654:	2001      	movne	r0, #1
  401656:	4d07      	ldr	r5, [pc, #28]	; (401674 <_usart_sync_enable+0x30>)
  401658:	47a8      	blx	r5
	_usart_enable(device->hw);
  40165a:	6824      	ldr	r4, [r4, #0]
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline void _usart_enable(void *const hw)
{
	ASSERT(hw);
  40165c:	f240 22c7 	movw	r2, #711	; 0x2c7
  401660:	4631      	mov	r1, r6
  401662:	1c20      	adds	r0, r4, #0
  401664:	bf18      	it	ne
  401666:	2001      	movne	r0, #1
  401668:	47a8      	blx	r5
	((Usart *)hw)->US_CR = data;
  40166a:	2350      	movs	r3, #80	; 0x50
  40166c:	6023      	str	r3, [r4, #0]
  40166e:	bd70      	pop	{r4, r5, r6, pc}
  401670:	00402dd0 	.word	0x00402dd0
  401674:	00400b29 	.word	0x00400b29

00401678 <_usart_sync_write_byte>:
{
  401678:	b538      	push	{r3, r4, r5, lr}
  40167a:	460c      	mov	r4, r1
	ASSERT(device);
  40167c:	4605      	mov	r5, r0
  40167e:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
  401682:	4904      	ldr	r1, [pc, #16]	; (401694 <_usart_sync_write_byte+0x1c>)
  401684:	3000      	adds	r0, #0
  401686:	bf18      	it	ne
  401688:	2001      	movne	r0, #1
  40168a:	4b03      	ldr	r3, [pc, #12]	; (401698 <_usart_sync_write_byte+0x20>)
  40168c:	4798      	blx	r3
	hri_usart_write_US_THR_reg(device->hw, (hri_usart_us_thr_reg_t)data);
  40168e:	682b      	ldr	r3, [r5, #0]
}

static inline void hri_usart_write_US_THR_reg(const void *const hw, hri_usart_us_thr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_THR = data;
  401690:	61dc      	str	r4, [r3, #28]
  401692:	bd38      	pop	{r3, r4, r5, pc}
  401694:	00402dd0 	.word	0x00402dd0
  401698:	00400b29 	.word	0x00400b29

0040169c <_usart_sync_read_byte>:
{
  40169c:	b510      	push	{r4, lr}
	ASSERT(device);
  40169e:	4604      	mov	r4, r0
  4016a0:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
  4016a4:	4904      	ldr	r1, [pc, #16]	; (4016b8 <_usart_sync_read_byte+0x1c>)
  4016a6:	3000      	adds	r0, #0
  4016a8:	bf18      	it	ne
  4016aa:	2001      	movne	r0, #1
  4016ac:	4b03      	ldr	r3, [pc, #12]	; (4016bc <_usart_sync_read_byte+0x20>)
  4016ae:	4798      	blx	r3
	return (uint8_t)(hri_usart_read_US_RHR_reg(device->hw) & 0xff);
  4016b0:	6823      	ldr	r3, [r4, #0]
	return ((Usart *)hw)->US_RHR;
  4016b2:	6998      	ldr	r0, [r3, #24]
}
  4016b4:	b2c0      	uxtb	r0, r0
  4016b6:	bd10      	pop	{r4, pc}
  4016b8:	00402dd0 	.word	0x00402dd0
  4016bc:	00400b29 	.word	0x00400b29

004016c0 <_usart_sync_is_ready_to_send>:
{
  4016c0:	b510      	push	{r4, lr}
	ASSERT(device);
  4016c2:	4604      	mov	r4, r0
  4016c4:	f240 12c3 	movw	r2, #451	; 0x1c3
  4016c8:	4905      	ldr	r1, [pc, #20]	; (4016e0 <_usart_sync_is_ready_to_send+0x20>)
  4016ca:	3000      	adds	r0, #0
  4016cc:	bf18      	it	ne
  4016ce:	2001      	movne	r0, #1
  4016d0:	4b04      	ldr	r3, [pc, #16]	; (4016e4 <_usart_sync_is_ready_to_send+0x24>)
  4016d2:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXRDY_bit(device->hw);
  4016d4:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXRDY) > 0;
  4016d6:	6958      	ldr	r0, [r3, #20]
}
  4016d8:	f3c0 0040 	ubfx	r0, r0, #1, #1
  4016dc:	bd10      	pop	{r4, pc}
  4016de:	bf00      	nop
  4016e0:	00402dd0 	.word	0x00402dd0
  4016e4:	00400b29 	.word	0x00400b29

004016e8 <_usart_sync_is_transmit_done>:
{
  4016e8:	b510      	push	{r4, lr}
	ASSERT(device);
  4016ea:	4604      	mov	r4, r0
  4016ec:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
  4016f0:	4905      	ldr	r1, [pc, #20]	; (401708 <_usart_sync_is_transmit_done+0x20>)
  4016f2:	3000      	adds	r0, #0
  4016f4:	bf18      	it	ne
  4016f6:	2001      	movne	r0, #1
  4016f8:	4b04      	ldr	r3, [pc, #16]	; (40170c <_usart_sync_is_transmit_done+0x24>)
  4016fa:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXEMPTY_bit(device->hw);
  4016fc:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXEMPTY) > 0;
  4016fe:	6958      	ldr	r0, [r3, #20]
}
  401700:	f3c0 2040 	ubfx	r0, r0, #9, #1
  401704:	bd10      	pop	{r4, pc}
  401706:	bf00      	nop
  401708:	00402dd0 	.word	0x00402dd0
  40170c:	00400b29 	.word	0x00400b29

00401710 <_usart_sync_is_byte_received>:
{
  401710:	b510      	push	{r4, lr}
	ASSERT(device);
  401712:	4604      	mov	r4, r0
  401714:	f44f 72ef 	mov.w	r2, #478	; 0x1de
  401718:	4905      	ldr	r1, [pc, #20]	; (401730 <_usart_sync_is_byte_received+0x20>)
  40171a:	3000      	adds	r0, #0
  40171c:	bf18      	it	ne
  40171e:	2001      	movne	r0, #1
  401720:	4b04      	ldr	r3, [pc, #16]	; (401734 <_usart_sync_is_byte_received+0x24>)
  401722:	4798      	blx	r3
	return hri_usart_get_US_CSR_RXRDY_bit(device->hw);
  401724:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_RXRDY) > 0;
  401726:	6958      	ldr	r0, [r3, #20]
  401728:	f000 0001 	and.w	r0, r0, #1
}
  40172c:	bd10      	pop	{r4, pc}
  40172e:	bf00      	nop
  401730:	00402dd0 	.word	0x00402dd0
  401734:	00400b29 	.word	0x00400b29

00401738 <_usart_get_usart_sync>:
}
  401738:	2000      	movs	r0, #0
  40173a:	4770      	bx	lr

0040173c <main>:
void set_pmw_motor_0(struct _pwm_device *const device, uint32_t duty_cycle){
	set_pwm_channel(device, CHANNEL_0, duty_cycle);
}

int main(void)
{
  40173c:	b500      	push	{lr}
  40173e:	b089      	sub	sp, #36	; 0x24
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  401740:	4b07      	ldr	r3, [pc, #28]	; (401760 <main+0x24>)
  401742:	4798      	blx	r3
	/*Initialize the IMU, making sure to pass in the address of the start of the float array that will hold the quaternion coefficients*/
	
	//init_IMU(&imu_vector_buffer[0]);
	
	uint8_t data_store[32];
	memset(&data_store[0], 0, sizeof(uint8_t)*32);
  401744:	2220      	movs	r2, #32
  401746:	2100      	movs	r1, #0
  401748:	4668      	mov	r0, sp
  40174a:	4b06      	ldr	r3, [pc, #24]	; (401764 <main+0x28>)
  40174c:	4798      	blx	r3
	nRF24_init(data_store);
  40174e:	4668      	mov	r0, sp
  401750:	4b05      	ldr	r3, [pc, #20]	; (401768 <main+0x2c>)
  401752:	4798      	blx	r3
	delay_us(200); //Should be 200 us, setting higher for testing
  401754:	20c8      	movs	r0, #200	; 0xc8
  401756:	4b05      	ldr	r3, [pc, #20]	; (40176c <main+0x30>)
  401758:	4798      	blx	r3
	nRF24_enter_receive();
  40175a:	4b05      	ldr	r3, [pc, #20]	; (401770 <main+0x34>)
  40175c:	4798      	blx	r3
  40175e:	e7fe      	b.n	40175e <main+0x22>
  401760:	004001d5 	.word	0x004001d5
  401764:	00401b51 	.word	0x00401b51
  401768:	00401909 	.word	0x00401909
  40176c:	004005a9 	.word	0x004005a9
  401770:	004019c1 	.word	0x004019c1

00401774 <nRF24_write_to_register>:

struct io_descriptor *spi_0_io;

uint8_t* global_data_pointer;

void nRF24_write_to_register(uint8_t registerd, uint8_t data){ //First sends the SPI Command "W_REGISTER", followed by the data to write!
  401774:	b530      	push	{r4, r5, lr}
  401776:	b083      	sub	sp, #12
	uint8_t buffer[2];
	memset(&buffer[0], 0, sizeof(uint8_t)*2);
	buffer[0] = buffer[0] | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer[0] = (buffer[0]) | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401778:	f040 0020 	orr.w	r0, r0, #32
  40177c:	f88d 0004 	strb.w	r0, [sp, #4]
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	buffer[1] = data;
  401780:	f88d 1005 	strb.w	r1, [sp, #5]
	((Pio *)hw)->PIO_CODR = mask;
  401784:	4c06      	ldr	r4, [pc, #24]	; (4017a0 <nRF24_write_to_register+0x2c>)
  401786:	f44f 7500 	mov.w	r5, #512	; 0x200
  40178a:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, buffer, 2); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  40178c:	2202      	movs	r2, #2
  40178e:	a901      	add	r1, sp, #4
  401790:	4b04      	ldr	r3, [pc, #16]	; (4017a4 <nRF24_write_to_register+0x30>)
  401792:	6818      	ldr	r0, [r3, #0]
  401794:	4b04      	ldr	r3, [pc, #16]	; (4017a8 <nRF24_write_to_register+0x34>)
  401796:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401798:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40179a:	b003      	add	sp, #12
  40179c:	bd30      	pop	{r4, r5, pc}
  40179e:	bf00      	nop
  4017a0:	400e1200 	.word	0x400e1200
  4017a4:	2040011c 	.word	0x2040011c
  4017a8:	004007b1 	.word	0x004007b1

004017ac <nRF24_write_to_register_multi_byte>:

void nRF24_write_to_register_multi_byte(uint8_t registerd, uint8_t *data, int length){ //SPI Command "W_REGISTER"
  4017ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4017b0:	b083      	sub	sp, #12
  4017b2:	4688      	mov	r8, r1
  4017b4:	4691      	mov	r9, r2
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer = buffer | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  4017b6:	f040 0020 	orr.w	r0, r0, #32
  4017ba:	a902      	add	r1, sp, #8
  4017bc:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  4017c0:	4c08      	ldr	r4, [pc, #32]	; (4017e4 <nRF24_write_to_register_multi_byte+0x38>)
  4017c2:	f44f 7500 	mov.w	r5, #512	; 0x200
  4017c6:	6365      	str	r5, [r4, #52]	; 0x34
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1);
  4017c8:	4f07      	ldr	r7, [pc, #28]	; (4017e8 <nRF24_write_to_register_multi_byte+0x3c>)
  4017ca:	2201      	movs	r2, #1
  4017cc:	6838      	ldr	r0, [r7, #0]
  4017ce:	4e07      	ldr	r6, [pc, #28]	; (4017ec <nRF24_write_to_register_multi_byte+0x40>)
  4017d0:	47b0      	blx	r6
	io_write(spi_0_io, data, length); 
  4017d2:	fa1f f289 	uxth.w	r2, r9
  4017d6:	4641      	mov	r1, r8
  4017d8:	6838      	ldr	r0, [r7, #0]
  4017da:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  4017dc:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  4017de:	b003      	add	sp, #12
  4017e0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4017e4:	400e1200 	.word	0x400e1200
  4017e8:	2040011c 	.word	0x2040011c
  4017ec:	004007b1 	.word	0x004007b1

004017f0 <nRF24_read_from_register>:

uint8_t nRF24_read_from_register(uint8_t registerd){ //SPI Command "R_REGISTER"
  4017f0:	b570      	push	{r4, r5, r6, lr}
  4017f2:	b082      	sub	sp, #8
	uint8_t in_byte;
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | registerd;
  4017f4:	a902      	add	r1, sp, #8
  4017f6:	f801 0d02 	strb.w	r0, [r1, #-2]!
	((Pio *)hw)->PIO_CODR = mask;
  4017fa:	4c0a      	ldr	r4, [pc, #40]	; (401824 <nRF24_read_from_register+0x34>)
  4017fc:	f44f 7500 	mov.w	r5, #512	; 0x200
  401800:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  401802:	4e09      	ldr	r6, [pc, #36]	; (401828 <nRF24_read_from_register+0x38>)
  401804:	2201      	movs	r2, #1
  401806:	6830      	ldr	r0, [r6, #0]
  401808:	4b08      	ldr	r3, [pc, #32]	; (40182c <nRF24_read_from_register+0x3c>)
  40180a:	4798      	blx	r3
	io_read(spi_0_io, &in_byte, 1);
  40180c:	2201      	movs	r2, #1
  40180e:	f10d 0107 	add.w	r1, sp, #7
  401812:	6830      	ldr	r0, [r6, #0]
  401814:	4b06      	ldr	r3, [pc, #24]	; (401830 <nRF24_read_from_register+0x40>)
  401816:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401818:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	return in_byte;
}
  40181a:	f89d 0007 	ldrb.w	r0, [sp, #7]
  40181e:	b002      	add	sp, #8
  401820:	bd70      	pop	{r4, r5, r6, pc}
  401822:	bf00      	nop
  401824:	400e1200 	.word	0x400e1200
  401828:	2040011c 	.word	0x2040011c
  40182c:	004007b1 	.word	0x004007b1
  401830:	004007e1 	.word	0x004007e1

00401834 <nRF24_send_SPI_command>:
	io_write(spi_0_io, &buffer, 1);
	io_read(spi_0_io, data_pointer, length);
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}

void nRF24_send_SPI_command(uint8_t command){
  401834:	b530      	push	{r4, r5, lr}
  401836:	b083      	sub	sp, #12
  401838:	a902      	add	r1, sp, #8
  40183a:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  40183e:	4c06      	ldr	r4, [pc, #24]	; (401858 <nRF24_send_SPI_command+0x24>)
  401840:	f44f 7500 	mov.w	r5, #512	; 0x200
  401844:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &command, 1);
  401846:	2201      	movs	r2, #1
  401848:	4b04      	ldr	r3, [pc, #16]	; (40185c <nRF24_send_SPI_command+0x28>)
  40184a:	6818      	ldr	r0, [r3, #0]
  40184c:	4b04      	ldr	r3, [pc, #16]	; (401860 <nRF24_send_SPI_command+0x2c>)
  40184e:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401850:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  401852:	b003      	add	sp, #12
  401854:	bd30      	pop	{r4, r5, pc}
  401856:	bf00      	nop
  401858:	400e1200 	.word	0x400e1200
  40185c:	2040011c 	.word	0x2040011c
  401860:	004007b1 	.word	0x004007b1

00401864 <nRF24_receive_data>:
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
	gpio_set_pin_level(RF24_CE, true);
}

void nRF24_receive_data(){
  401864:	b570      	push	{r4, r5, r6, lr}
  401866:	b082      	sub	sp, #8
	uint8_t cmd = R_RX_PAYLOAD;
  401868:	a902      	add	r1, sp, #8
  40186a:	2361      	movs	r3, #97	; 0x61
  40186c:	f801 3d01 	strb.w	r3, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401870:	4c18      	ldr	r4, [pc, #96]	; (4018d4 <nRF24_receive_data+0x70>)
  401872:	f44f 7500 	mov.w	r5, #512	; 0x200
  401876:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &cmd, 1);
  401878:	4e17      	ldr	r6, [pc, #92]	; (4018d8 <nRF24_receive_data+0x74>)
  40187a:	2201      	movs	r2, #1
  40187c:	6830      	ldr	r0, [r6, #0]
  40187e:	4b17      	ldr	r3, [pc, #92]	; (4018dc <nRF24_receive_data+0x78>)
  401880:	4798      	blx	r3
	io_read(spi_0_io, global_data_pointer, 32);
  401882:	2220      	movs	r2, #32
  401884:	4b16      	ldr	r3, [pc, #88]	; (4018e0 <nRF24_receive_data+0x7c>)
  401886:	6819      	ldr	r1, [r3, #0]
  401888:	6830      	ldr	r0, [r6, #0]
  40188a:	4b16      	ldr	r3, [pc, #88]	; (4018e4 <nRF24_receive_data+0x80>)
  40188c:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  40188e:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	delay_us(11); //Make sure we had enough time to grab the data before flushing
  401890:	200b      	movs	r0, #11
  401892:	4b15      	ldr	r3, [pc, #84]	; (4018e8 <nRF24_receive_data+0x84>)
  401894:	4798      	blx	r3
	cmd = FLUSH_RX;
  401896:	20e2      	movs	r0, #226	; 0xe2
  401898:	f88d 0007 	strb.w	r0, [sp, #7]
	nRF24_send_SPI_command(cmd);
  40189c:	4b13      	ldr	r3, [pc, #76]	; (4018ec <nRF24_receive_data+0x88>)
  40189e:	4798      	blx	r3
	uint8_t status_read = nRF24_read_from_register(STATUS);
  4018a0:	2007      	movs	r0, #7
  4018a2:	4b13      	ldr	r3, [pc, #76]	; (4018f0 <nRF24_receive_data+0x8c>)
  4018a4:	4798      	blx	r3
	status_read = status_read | 64;
  4018a6:	f040 0140 	orr.w	r1, r0, #64	; 0x40
	nRF24_write_to_register(STATUS, status_read);
  4018aa:	b2c9      	uxtb	r1, r1
  4018ac:	2007      	movs	r0, #7
  4018ae:	4b11      	ldr	r3, [pc, #68]	; (4018f4 <nRF24_receive_data+0x90>)
  4018b0:	4798      	blx	r3
	//uint8_t charray[64];
	for(int x = 0; x < 32; x++){
  4018b2:	2400      	movs	r4, #0
  4018b4:	e006      	b.n	4018c4 <nRF24_receive_data+0x60>
		printf("%02x ", global_data_pointer[x]);
  4018b6:	4b0a      	ldr	r3, [pc, #40]	; (4018e0 <nRF24_receive_data+0x7c>)
  4018b8:	681b      	ldr	r3, [r3, #0]
  4018ba:	5d19      	ldrb	r1, [r3, r4]
  4018bc:	480e      	ldr	r0, [pc, #56]	; (4018f8 <nRF24_receive_data+0x94>)
  4018be:	4b0f      	ldr	r3, [pc, #60]	; (4018fc <nRF24_receive_data+0x98>)
  4018c0:	4798      	blx	r3
	for(int x = 0; x < 32; x++){
  4018c2:	3401      	adds	r4, #1
  4018c4:	2c1f      	cmp	r4, #31
  4018c6:	ddf6      	ble.n	4018b6 <nRF24_receive_data+0x52>
	}
	printf("\r\n");
  4018c8:	480d      	ldr	r0, [pc, #52]	; (401900 <nRF24_receive_data+0x9c>)
  4018ca:	4b0e      	ldr	r3, [pc, #56]	; (401904 <nRF24_receive_data+0xa0>)
  4018cc:	4798      	blx	r3
}
  4018ce:	b002      	add	sp, #8
  4018d0:	bd70      	pop	{r4, r5, r6, pc}
  4018d2:	bf00      	nop
  4018d4:	400e1200 	.word	0x400e1200
  4018d8:	2040011c 	.word	0x2040011c
  4018dc:	004007b1 	.word	0x004007b1
  4018e0:	20400118 	.word	0x20400118
  4018e4:	004007e1 	.word	0x004007e1
  4018e8:	004005a9 	.word	0x004005a9
  4018ec:	00401835 	.word	0x00401835
  4018f0:	004017f1 	.word	0x004017f1
  4018f4:	00401775 	.word	0x00401775
  4018f8:	00402df4 	.word	0x00402df4
  4018fc:	00401cb9 	.word	0x00401cb9
  401900:	00402dfc 	.word	0x00402dfc
  401904:	00401da1 	.word	0x00401da1

00401908 <nRF24_init>:
void nRF24_init(uint8_t* data_pointer){ //You are in standby-1 at the end of this call
  401908:	b530      	push	{r4, r5, lr}
  40190a:	b083      	sub	sp, #12
  40190c:	4605      	mov	r5, r0
	spi_m_sync_get_io_descriptor(&SPI_0, &spi_0_io);
  40190e:	4c20      	ldr	r4, [pc, #128]	; (401990 <nRF24_init+0x88>)
  401910:	4920      	ldr	r1, [pc, #128]	; (401994 <nRF24_init+0x8c>)
  401912:	4620      	mov	r0, r4
  401914:	4b20      	ldr	r3, [pc, #128]	; (401998 <nRF24_init+0x90>)
  401916:	4798      	blx	r3
	global_data_pointer = data_pointer;
  401918:	4b20      	ldr	r3, [pc, #128]	; (40199c <nRF24_init+0x94>)
  40191a:	601d      	str	r5, [r3, #0]
	spi_m_sync_enable(&SPI_0);
  40191c:	4620      	mov	r0, r4
  40191e:	4b20      	ldr	r3, [pc, #128]	; (4019a0 <nRF24_init+0x98>)
  401920:	4798      	blx	r3
	((Pio *)hw)->PIO_CODR = mask;
  401922:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  401926:	4b1f      	ldr	r3, [pc, #124]	; (4019a4 <nRF24_init+0x9c>)
  401928:	635a      	str	r2, [r3, #52]	; 0x34
	nRF24_write_to_register(CONFIG,0); //0000 0000 keep us in power down, disable checksums
  40192a:	2100      	movs	r1, #0
  40192c:	4608      	mov	r0, r1
  40192e:	4c1e      	ldr	r4, [pc, #120]	; (4019a8 <nRF24_init+0xa0>)
  401930:	47a0      	blx	r4
	uint8_t status_read = nRF24_read_from_register(STATUS);
  401932:	2007      	movs	r0, #7
  401934:	4b1d      	ldr	r3, [pc, #116]	; (4019ac <nRF24_init+0xa4>)
  401936:	4798      	blx	r3
	status_read = status_read | 64;
  401938:	f040 0140 	orr.w	r1, r0, #64	; 0x40
	nRF24_write_to_register(STATUS, status_read);
  40193c:	b2c9      	uxtb	r1, r1
  40193e:	2007      	movs	r0, #7
  401940:	47a0      	blx	r4
	nRF24_write_to_register(EN_AA,0); //0000 0000 no auto ACK
  401942:	2100      	movs	r1, #0
  401944:	2001      	movs	r0, #1
  401946:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR,0); //0000 0000 disable all RX pipes
  401948:	2100      	movs	r1, #0
  40194a:	2002      	movs	r0, #2
  40194c:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_AW,3); //0000 0011 5 byte tx rx address fields
  40194e:	2103      	movs	r1, #3
  401950:	4608      	mov	r0, r1
  401952:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_RETR,0); //0000 0000 no auto retransmission
  401954:	2100      	movs	r1, #0
  401956:	2004      	movs	r0, #4
  401958:	47a0      	blx	r4
	nRF24_write_to_register(RF_CH,120); //0011 1111 first bit must be 0, 011 1111 = 63 freq = 2400 + 63 = 2463 = 2.463 GHz
  40195a:	2178      	movs	r1, #120	; 0x78
  40195c:	2005      	movs	r0, #5
  40195e:	47a0      	blx	r4
	nRF24_write_to_register(RF_SETUP,6); //0000 0010 1 Mbps and -12 db //SET BACK TO 2
  401960:	2106      	movs	r1, #6
  401962:	4608      	mov	r0, r1
  401964:	47a0      	blx	r4
	uint8_t tx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  401966:	4b12      	ldr	r3, [pc, #72]	; (4019b0 <nRF24_init+0xa8>)
  401968:	e893 0003 	ldmia.w	r3, {r0, r1}
  40196c:	9000      	str	r0, [sp, #0]
  40196e:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(TX_ADDR, &tx_address[0], 5); //Set TX addr as e7e7e7e7e7
  401972:	2205      	movs	r2, #5
  401974:	4669      	mov	r1, sp
  401976:	2010      	movs	r0, #16
  401978:	4b0e      	ldr	r3, [pc, #56]	; (4019b4 <nRF24_init+0xac>)
  40197a:	4798      	blx	r3
	nRF24_write_to_register(CONFIG,2); //0000 0020 enter standby-1, disable checksums
  40197c:	2102      	movs	r1, #2
  40197e:	2000      	movs	r0, #0
  401980:	47a0      	blx	r4
	ext_irq_register(PB1, nRF24_receive_data);
  401982:	490d      	ldr	r1, [pc, #52]	; (4019b8 <nRF24_init+0xb0>)
  401984:	2021      	movs	r0, #33	; 0x21
  401986:	4b0d      	ldr	r3, [pc, #52]	; (4019bc <nRF24_init+0xb4>)
  401988:	4798      	blx	r3
}
  40198a:	b003      	add	sp, #12
  40198c:	bd30      	pop	{r4, r5, pc}
  40198e:	bf00      	nop
  401990:	204000e0 	.word	0x204000e0
  401994:	2040011c 	.word	0x2040011c
  401998:	004009b9 	.word	0x004009b9
  40199c:	20400118 	.word	0x20400118
  4019a0:	004008d9 	.word	0x004008d9
  4019a4:	400e1400 	.word	0x400e1400
  4019a8:	00401775 	.word	0x00401775
  4019ac:	004017f1 	.word	0x004017f1
  4019b0:	00402dec 	.word	0x00402dec
  4019b4:	004017ad 	.word	0x004017ad
  4019b8:	00401865 	.word	0x00401865
  4019bc:	00400641 	.word	0x00400641

004019c0 <nRF24_enter_receive>:
void nRF24_enter_receive(){ //You are in receive at the end of this call
  4019c0:	b510      	push	{r4, lr}
  4019c2:	b082      	sub	sp, #8
	config_reg = nRF24_read_from_register(CONFIG);
  4019c4:	2000      	movs	r0, #0
  4019c6:	4b0f      	ldr	r3, [pc, #60]	; (401a04 <nRF24_enter_receive+0x44>)
  4019c8:	4798      	blx	r3
	config_reg = config_reg | 1; //XXXX XXX1 PRIM_RX to 1
  4019ca:	f040 0101 	orr.w	r1, r0, #1
	nRF24_write_to_register(CONFIG, config_reg);
  4019ce:	b2c9      	uxtb	r1, r1
  4019d0:	2000      	movs	r0, #0
  4019d2:	4c0d      	ldr	r4, [pc, #52]	; (401a08 <nRF24_enter_receive+0x48>)
  4019d4:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR, 2); //0000 0010 set data pipe 1 to on
  4019d6:	2102      	movs	r1, #2
  4019d8:	4608      	mov	r0, r1
  4019da:	47a0      	blx	r4
	uint8_t rx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  4019dc:	4b0b      	ldr	r3, [pc, #44]	; (401a0c <nRF24_enter_receive+0x4c>)
  4019de:	e893 0003 	ldmia.w	r3, {r0, r1}
  4019e2:	9000      	str	r0, [sp, #0]
  4019e4:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
  4019e8:	2205      	movs	r2, #5
  4019ea:	4669      	mov	r1, sp
  4019ec:	200b      	movs	r0, #11
  4019ee:	4b08      	ldr	r3, [pc, #32]	; (401a10 <nRF24_enter_receive+0x50>)
  4019f0:	4798      	blx	r3
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
  4019f2:	2120      	movs	r1, #32
  4019f4:	2012      	movs	r0, #18
  4019f6:	47a0      	blx	r4
	((Pio *)hw)->PIO_SODR = mask;
  4019f8:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  4019fc:	4b05      	ldr	r3, [pc, #20]	; (401a14 <nRF24_enter_receive+0x54>)
  4019fe:	631a      	str	r2, [r3, #48]	; 0x30
}
  401a00:	b002      	add	sp, #8
  401a02:	bd10      	pop	{r4, pc}
  401a04:	004017f1 	.word	0x004017f1
  401a08:	00401775 	.word	0x00401775
  401a0c:	00402dec 	.word	0x00402dec
  401a10:	004017ad 	.word	0x004017ad
  401a14:	400e1400 	.word	0x400e1400

00401a18 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
  401a18:	b958      	cbnz	r0, 401a32 <_read+0x1a>
{
  401a1a:	b508      	push	{r3, lr}
  401a1c:	460b      	mov	r3, r1
  401a1e:	4611      	mov	r1, r2
  401a20:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
  401a22:	4b05      	ldr	r3, [pc, #20]	; (401a38 <_read+0x20>)
  401a24:	4798      	blx	r3
	if (n < 0) {
  401a26:	2800      	cmp	r0, #0
  401a28:	db00      	blt.n	401a2c <_read+0x14>
		return -1;
	}

	return n;
}
  401a2a:	bd08      	pop	{r3, pc}
		return -1;
  401a2c:	f04f 30ff 	mov.w	r0, #4294967295
  401a30:	bd08      	pop	{r3, pc}
		return -1;
  401a32:	f04f 30ff 	mov.w	r0, #4294967295
  401a36:	4770      	bx	lr
  401a38:	00401a91 	.word	0x00401a91

00401a3c <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
  401a3c:	3801      	subs	r0, #1
  401a3e:	2802      	cmp	r0, #2
  401a40:	d80b      	bhi.n	401a5a <_write+0x1e>
{
  401a42:	b508      	push	{r3, lr}
  401a44:	460b      	mov	r3, r1
  401a46:	4611      	mov	r1, r2
  401a48:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
  401a4a:	4b05      	ldr	r3, [pc, #20]	; (401a60 <_write+0x24>)
  401a4c:	4798      	blx	r3
	if (n < 0) {
  401a4e:	2800      	cmp	r0, #0
  401a50:	db00      	blt.n	401a54 <_write+0x18>
		return -1;
	}

	return n;
}
  401a52:	bd08      	pop	{r3, pc}
		return -1;
  401a54:	f04f 30ff 	mov.w	r0, #4294967295
  401a58:	bd08      	pop	{r3, pc}
		return -1;
  401a5a:	f04f 30ff 	mov.w	r0, #4294967295
  401a5e:	4770      	bx	lr
  401a60:	00401ab5 	.word	0x00401ab5

00401a64 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
  401a64:	b570      	push	{r4, r5, r6, lr}
  401a66:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
  401a68:	4d06      	ldr	r5, [pc, #24]	; (401a84 <stdio_io_init+0x20>)
  401a6a:	682b      	ldr	r3, [r5, #0]
  401a6c:	2100      	movs	r1, #0
  401a6e:	6898      	ldr	r0, [r3, #8]
  401a70:	4c05      	ldr	r4, [pc, #20]	; (401a88 <stdio_io_init+0x24>)
  401a72:	47a0      	blx	r4
	setbuf(stdin, NULL);
  401a74:	682b      	ldr	r3, [r5, #0]
  401a76:	2100      	movs	r1, #0
  401a78:	6858      	ldr	r0, [r3, #4]
  401a7a:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
  401a7c:	4b03      	ldr	r3, [pc, #12]	; (401a8c <stdio_io_init+0x28>)
  401a7e:	601e      	str	r6, [r3, #0]
  401a80:	bd70      	pop	{r4, r5, r6, pc}
  401a82:	bf00      	nop
  401a84:	20400000 	.word	0x20400000
  401a88:	00401dd1 	.word	0x00401dd1
  401a8c:	204000ac 	.word	0x204000ac

00401a90 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
  401a90:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  401a92:	4b06      	ldr	r3, [pc, #24]	; (401aac <stdio_io_read+0x1c>)
  401a94:	681b      	ldr	r3, [r3, #0]
  401a96:	b133      	cbz	r3, 401aa6 <stdio_io_read+0x16>
  401a98:	460a      	mov	r2, r1
  401a9a:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
  401a9c:	b292      	uxth	r2, r2
  401a9e:	4618      	mov	r0, r3
  401aa0:	4b03      	ldr	r3, [pc, #12]	; (401ab0 <stdio_io_read+0x20>)
  401aa2:	4798      	blx	r3
  401aa4:	bd08      	pop	{r3, pc}
		return 0;
  401aa6:	2000      	movs	r0, #0
}
  401aa8:	bd08      	pop	{r3, pc}
  401aaa:	bf00      	nop
  401aac:	204000ac 	.word	0x204000ac
  401ab0:	004007e1 	.word	0x004007e1

00401ab4 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
  401ab4:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  401ab6:	4b06      	ldr	r3, [pc, #24]	; (401ad0 <stdio_io_write+0x1c>)
  401ab8:	681b      	ldr	r3, [r3, #0]
  401aba:	b133      	cbz	r3, 401aca <stdio_io_write+0x16>
  401abc:	460a      	mov	r2, r1
  401abe:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
  401ac0:	b292      	uxth	r2, r2
  401ac2:	4618      	mov	r0, r3
  401ac4:	4b03      	ldr	r3, [pc, #12]	; (401ad4 <stdio_io_write+0x20>)
  401ac6:	4798      	blx	r3
  401ac8:	bd08      	pop	{r3, pc}
		return 0;
  401aca:	2000      	movs	r0, #0
}
  401acc:	bd08      	pop	{r3, pc}
  401ace:	bf00      	nop
  401ad0:	204000ac 	.word	0x204000ac
  401ad4:	004007b1 	.word	0x004007b1

00401ad8 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
  401ad8:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
  401ada:	4c04      	ldr	r4, [pc, #16]	; (401aec <stdio_redirect_init+0x14>)
  401adc:	4620      	mov	r0, r4
  401ade:	4b04      	ldr	r3, [pc, #16]	; (401af0 <stdio_redirect_init+0x18>)
  401ae0:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
  401ae2:	4620      	mov	r0, r4
  401ae4:	4b03      	ldr	r3, [pc, #12]	; (401af4 <stdio_redirect_init+0x1c>)
  401ae6:	4798      	blx	r3
  401ae8:	bd10      	pop	{r4, pc}
  401aea:	bf00      	nop
  401aec:	204000d4 	.word	0x204000d4
  401af0:	00400afd 	.word	0x00400afd
  401af4:	00401a65 	.word	0x00401a65

00401af8 <__libc_init_array>:
  401af8:	b570      	push	{r4, r5, r6, lr}
  401afa:	4e0d      	ldr	r6, [pc, #52]	; (401b30 <__libc_init_array+0x38>)
  401afc:	4c0d      	ldr	r4, [pc, #52]	; (401b34 <__libc_init_array+0x3c>)
  401afe:	1ba4      	subs	r4, r4, r6
  401b00:	10a4      	asrs	r4, r4, #2
  401b02:	2500      	movs	r5, #0
  401b04:	42a5      	cmp	r5, r4
  401b06:	d109      	bne.n	401b1c <__libc_init_array+0x24>
  401b08:	4e0b      	ldr	r6, [pc, #44]	; (401b38 <__libc_init_array+0x40>)
  401b0a:	4c0c      	ldr	r4, [pc, #48]	; (401b3c <__libc_init_array+0x44>)
  401b0c:	f001 f9c4 	bl	402e98 <_init>
  401b10:	1ba4      	subs	r4, r4, r6
  401b12:	10a4      	asrs	r4, r4, #2
  401b14:	2500      	movs	r5, #0
  401b16:	42a5      	cmp	r5, r4
  401b18:	d105      	bne.n	401b26 <__libc_init_array+0x2e>
  401b1a:	bd70      	pop	{r4, r5, r6, pc}
  401b1c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401b20:	4798      	blx	r3
  401b22:	3501      	adds	r5, #1
  401b24:	e7ee      	b.n	401b04 <__libc_init_array+0xc>
  401b26:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401b2a:	4798      	blx	r3
  401b2c:	3501      	adds	r5, #1
  401b2e:	e7f2      	b.n	401b16 <__libc_init_array+0x1e>
  401b30:	00402ea4 	.word	0x00402ea4
  401b34:	00402ea4 	.word	0x00402ea4
  401b38:	00402ea4 	.word	0x00402ea4
  401b3c:	00402ea8 	.word	0x00402ea8

00401b40 <malloc>:
  401b40:	4b02      	ldr	r3, [pc, #8]	; (401b4c <malloc+0xc>)
  401b42:	4601      	mov	r1, r0
  401b44:	6818      	ldr	r0, [r3, #0]
  401b46:	f000 b859 	b.w	401bfc <_malloc_r>
  401b4a:	bf00      	nop
  401b4c:	20400000 	.word	0x20400000

00401b50 <memset>:
  401b50:	4402      	add	r2, r0
  401b52:	4603      	mov	r3, r0
  401b54:	4293      	cmp	r3, r2
  401b56:	d100      	bne.n	401b5a <memset+0xa>
  401b58:	4770      	bx	lr
  401b5a:	f803 1b01 	strb.w	r1, [r3], #1
  401b5e:	e7f9      	b.n	401b54 <memset+0x4>

00401b60 <_free_r>:
  401b60:	b538      	push	{r3, r4, r5, lr}
  401b62:	4605      	mov	r5, r0
  401b64:	2900      	cmp	r1, #0
  401b66:	d045      	beq.n	401bf4 <_free_r+0x94>
  401b68:	f851 3c04 	ldr.w	r3, [r1, #-4]
  401b6c:	1f0c      	subs	r4, r1, #4
  401b6e:	2b00      	cmp	r3, #0
  401b70:	bfb8      	it	lt
  401b72:	18e4      	addlt	r4, r4, r3
  401b74:	f000 fc82 	bl	40247c <__malloc_lock>
  401b78:	4a1f      	ldr	r2, [pc, #124]	; (401bf8 <_free_r+0x98>)
  401b7a:	6813      	ldr	r3, [r2, #0]
  401b7c:	4610      	mov	r0, r2
  401b7e:	b933      	cbnz	r3, 401b8e <_free_r+0x2e>
  401b80:	6063      	str	r3, [r4, #4]
  401b82:	6014      	str	r4, [r2, #0]
  401b84:	4628      	mov	r0, r5
  401b86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  401b8a:	f000 bc78 	b.w	40247e <__malloc_unlock>
  401b8e:	42a3      	cmp	r3, r4
  401b90:	d90c      	bls.n	401bac <_free_r+0x4c>
  401b92:	6821      	ldr	r1, [r4, #0]
  401b94:	1862      	adds	r2, r4, r1
  401b96:	4293      	cmp	r3, r2
  401b98:	bf04      	itt	eq
  401b9a:	681a      	ldreq	r2, [r3, #0]
  401b9c:	685b      	ldreq	r3, [r3, #4]
  401b9e:	6063      	str	r3, [r4, #4]
  401ba0:	bf04      	itt	eq
  401ba2:	1852      	addeq	r2, r2, r1
  401ba4:	6022      	streq	r2, [r4, #0]
  401ba6:	6004      	str	r4, [r0, #0]
  401ba8:	e7ec      	b.n	401b84 <_free_r+0x24>
  401baa:	4613      	mov	r3, r2
  401bac:	685a      	ldr	r2, [r3, #4]
  401bae:	b10a      	cbz	r2, 401bb4 <_free_r+0x54>
  401bb0:	42a2      	cmp	r2, r4
  401bb2:	d9fa      	bls.n	401baa <_free_r+0x4a>
  401bb4:	6819      	ldr	r1, [r3, #0]
  401bb6:	1858      	adds	r0, r3, r1
  401bb8:	42a0      	cmp	r0, r4
  401bba:	d10b      	bne.n	401bd4 <_free_r+0x74>
  401bbc:	6820      	ldr	r0, [r4, #0]
  401bbe:	4401      	add	r1, r0
  401bc0:	1858      	adds	r0, r3, r1
  401bc2:	4282      	cmp	r2, r0
  401bc4:	6019      	str	r1, [r3, #0]
  401bc6:	d1dd      	bne.n	401b84 <_free_r+0x24>
  401bc8:	6810      	ldr	r0, [r2, #0]
  401bca:	6852      	ldr	r2, [r2, #4]
  401bcc:	605a      	str	r2, [r3, #4]
  401bce:	4401      	add	r1, r0
  401bd0:	6019      	str	r1, [r3, #0]
  401bd2:	e7d7      	b.n	401b84 <_free_r+0x24>
  401bd4:	d902      	bls.n	401bdc <_free_r+0x7c>
  401bd6:	230c      	movs	r3, #12
  401bd8:	602b      	str	r3, [r5, #0]
  401bda:	e7d3      	b.n	401b84 <_free_r+0x24>
  401bdc:	6820      	ldr	r0, [r4, #0]
  401bde:	1821      	adds	r1, r4, r0
  401be0:	428a      	cmp	r2, r1
  401be2:	bf04      	itt	eq
  401be4:	6811      	ldreq	r1, [r2, #0]
  401be6:	6852      	ldreq	r2, [r2, #4]
  401be8:	6062      	str	r2, [r4, #4]
  401bea:	bf04      	itt	eq
  401bec:	1809      	addeq	r1, r1, r0
  401bee:	6021      	streq	r1, [r4, #0]
  401bf0:	605c      	str	r4, [r3, #4]
  401bf2:	e7c7      	b.n	401b84 <_free_r+0x24>
  401bf4:	bd38      	pop	{r3, r4, r5, pc}
  401bf6:	bf00      	nop
  401bf8:	204000b0 	.word	0x204000b0

00401bfc <_malloc_r>:
  401bfc:	b570      	push	{r4, r5, r6, lr}
  401bfe:	1ccd      	adds	r5, r1, #3
  401c00:	f025 0503 	bic.w	r5, r5, #3
  401c04:	3508      	adds	r5, #8
  401c06:	2d0c      	cmp	r5, #12
  401c08:	bf38      	it	cc
  401c0a:	250c      	movcc	r5, #12
  401c0c:	2d00      	cmp	r5, #0
  401c0e:	4606      	mov	r6, r0
  401c10:	db01      	blt.n	401c16 <_malloc_r+0x1a>
  401c12:	42a9      	cmp	r1, r5
  401c14:	d903      	bls.n	401c1e <_malloc_r+0x22>
  401c16:	230c      	movs	r3, #12
  401c18:	6033      	str	r3, [r6, #0]
  401c1a:	2000      	movs	r0, #0
  401c1c:	bd70      	pop	{r4, r5, r6, pc}
  401c1e:	f000 fc2d 	bl	40247c <__malloc_lock>
  401c22:	4a23      	ldr	r2, [pc, #140]	; (401cb0 <_malloc_r+0xb4>)
  401c24:	6814      	ldr	r4, [r2, #0]
  401c26:	4621      	mov	r1, r4
  401c28:	b991      	cbnz	r1, 401c50 <_malloc_r+0x54>
  401c2a:	4c22      	ldr	r4, [pc, #136]	; (401cb4 <_malloc_r+0xb8>)
  401c2c:	6823      	ldr	r3, [r4, #0]
  401c2e:	b91b      	cbnz	r3, 401c38 <_malloc_r+0x3c>
  401c30:	4630      	mov	r0, r6
  401c32:	f000 f8bd 	bl	401db0 <_sbrk_r>
  401c36:	6020      	str	r0, [r4, #0]
  401c38:	4629      	mov	r1, r5
  401c3a:	4630      	mov	r0, r6
  401c3c:	f000 f8b8 	bl	401db0 <_sbrk_r>
  401c40:	1c43      	adds	r3, r0, #1
  401c42:	d126      	bne.n	401c92 <_malloc_r+0x96>
  401c44:	230c      	movs	r3, #12
  401c46:	6033      	str	r3, [r6, #0]
  401c48:	4630      	mov	r0, r6
  401c4a:	f000 fc18 	bl	40247e <__malloc_unlock>
  401c4e:	e7e4      	b.n	401c1a <_malloc_r+0x1e>
  401c50:	680b      	ldr	r3, [r1, #0]
  401c52:	1b5b      	subs	r3, r3, r5
  401c54:	d41a      	bmi.n	401c8c <_malloc_r+0x90>
  401c56:	2b0b      	cmp	r3, #11
  401c58:	d90f      	bls.n	401c7a <_malloc_r+0x7e>
  401c5a:	600b      	str	r3, [r1, #0]
  401c5c:	50cd      	str	r5, [r1, r3]
  401c5e:	18cc      	adds	r4, r1, r3
  401c60:	4630      	mov	r0, r6
  401c62:	f000 fc0c 	bl	40247e <__malloc_unlock>
  401c66:	f104 000b 	add.w	r0, r4, #11
  401c6a:	1d23      	adds	r3, r4, #4
  401c6c:	f020 0007 	bic.w	r0, r0, #7
  401c70:	1ac3      	subs	r3, r0, r3
  401c72:	d01b      	beq.n	401cac <_malloc_r+0xb0>
  401c74:	425a      	negs	r2, r3
  401c76:	50e2      	str	r2, [r4, r3]
  401c78:	bd70      	pop	{r4, r5, r6, pc}
  401c7a:	428c      	cmp	r4, r1
  401c7c:	bf0d      	iteet	eq
  401c7e:	6863      	ldreq	r3, [r4, #4]
  401c80:	684b      	ldrne	r3, [r1, #4]
  401c82:	6063      	strne	r3, [r4, #4]
  401c84:	6013      	streq	r3, [r2, #0]
  401c86:	bf18      	it	ne
  401c88:	460c      	movne	r4, r1
  401c8a:	e7e9      	b.n	401c60 <_malloc_r+0x64>
  401c8c:	460c      	mov	r4, r1
  401c8e:	6849      	ldr	r1, [r1, #4]
  401c90:	e7ca      	b.n	401c28 <_malloc_r+0x2c>
  401c92:	1cc4      	adds	r4, r0, #3
  401c94:	f024 0403 	bic.w	r4, r4, #3
  401c98:	42a0      	cmp	r0, r4
  401c9a:	d005      	beq.n	401ca8 <_malloc_r+0xac>
  401c9c:	1a21      	subs	r1, r4, r0
  401c9e:	4630      	mov	r0, r6
  401ca0:	f000 f886 	bl	401db0 <_sbrk_r>
  401ca4:	3001      	adds	r0, #1
  401ca6:	d0cd      	beq.n	401c44 <_malloc_r+0x48>
  401ca8:	6025      	str	r5, [r4, #0]
  401caa:	e7d9      	b.n	401c60 <_malloc_r+0x64>
  401cac:	bd70      	pop	{r4, r5, r6, pc}
  401cae:	bf00      	nop
  401cb0:	204000b0 	.word	0x204000b0
  401cb4:	204000b4 	.word	0x204000b4

00401cb8 <iprintf>:
  401cb8:	b40f      	push	{r0, r1, r2, r3}
  401cba:	4b0a      	ldr	r3, [pc, #40]	; (401ce4 <iprintf+0x2c>)
  401cbc:	b513      	push	{r0, r1, r4, lr}
  401cbe:	681c      	ldr	r4, [r3, #0]
  401cc0:	b124      	cbz	r4, 401ccc <iprintf+0x14>
  401cc2:	69a3      	ldr	r3, [r4, #24]
  401cc4:	b913      	cbnz	r3, 401ccc <iprintf+0x14>
  401cc6:	4620      	mov	r0, r4
  401cc8:	f000 faea 	bl	4022a0 <__sinit>
  401ccc:	ab05      	add	r3, sp, #20
  401cce:	9a04      	ldr	r2, [sp, #16]
  401cd0:	68a1      	ldr	r1, [r4, #8]
  401cd2:	9301      	str	r3, [sp, #4]
  401cd4:	4620      	mov	r0, r4
  401cd6:	f000 fbfb 	bl	4024d0 <_vfiprintf_r>
  401cda:	b002      	add	sp, #8
  401cdc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  401ce0:	b004      	add	sp, #16
  401ce2:	4770      	bx	lr
  401ce4:	20400000 	.word	0x20400000

00401ce8 <_puts_r>:
  401ce8:	b570      	push	{r4, r5, r6, lr}
  401cea:	460e      	mov	r6, r1
  401cec:	4605      	mov	r5, r0
  401cee:	b118      	cbz	r0, 401cf8 <_puts_r+0x10>
  401cf0:	6983      	ldr	r3, [r0, #24]
  401cf2:	b90b      	cbnz	r3, 401cf8 <_puts_r+0x10>
  401cf4:	f000 fad4 	bl	4022a0 <__sinit>
  401cf8:	69ab      	ldr	r3, [r5, #24]
  401cfa:	68ac      	ldr	r4, [r5, #8]
  401cfc:	b913      	cbnz	r3, 401d04 <_puts_r+0x1c>
  401cfe:	4628      	mov	r0, r5
  401d00:	f000 face 	bl	4022a0 <__sinit>
  401d04:	4b23      	ldr	r3, [pc, #140]	; (401d94 <_puts_r+0xac>)
  401d06:	429c      	cmp	r4, r3
  401d08:	d117      	bne.n	401d3a <_puts_r+0x52>
  401d0a:	686c      	ldr	r4, [r5, #4]
  401d0c:	89a3      	ldrh	r3, [r4, #12]
  401d0e:	071b      	lsls	r3, r3, #28
  401d10:	d51d      	bpl.n	401d4e <_puts_r+0x66>
  401d12:	6923      	ldr	r3, [r4, #16]
  401d14:	b1db      	cbz	r3, 401d4e <_puts_r+0x66>
  401d16:	3e01      	subs	r6, #1
  401d18:	68a3      	ldr	r3, [r4, #8]
  401d1a:	f816 1f01 	ldrb.w	r1, [r6, #1]!
  401d1e:	3b01      	subs	r3, #1
  401d20:	60a3      	str	r3, [r4, #8]
  401d22:	b9e9      	cbnz	r1, 401d60 <_puts_r+0x78>
  401d24:	2b00      	cmp	r3, #0
  401d26:	da2e      	bge.n	401d86 <_puts_r+0x9e>
  401d28:	4622      	mov	r2, r4
  401d2a:	210a      	movs	r1, #10
  401d2c:	4628      	mov	r0, r5
  401d2e:	f000 f905 	bl	401f3c <__swbuf_r>
  401d32:	3001      	adds	r0, #1
  401d34:	d011      	beq.n	401d5a <_puts_r+0x72>
  401d36:	200a      	movs	r0, #10
  401d38:	bd70      	pop	{r4, r5, r6, pc}
  401d3a:	4b17      	ldr	r3, [pc, #92]	; (401d98 <_puts_r+0xb0>)
  401d3c:	429c      	cmp	r4, r3
  401d3e:	d101      	bne.n	401d44 <_puts_r+0x5c>
  401d40:	68ac      	ldr	r4, [r5, #8]
  401d42:	e7e3      	b.n	401d0c <_puts_r+0x24>
  401d44:	4b15      	ldr	r3, [pc, #84]	; (401d9c <_puts_r+0xb4>)
  401d46:	429c      	cmp	r4, r3
  401d48:	bf08      	it	eq
  401d4a:	68ec      	ldreq	r4, [r5, #12]
  401d4c:	e7de      	b.n	401d0c <_puts_r+0x24>
  401d4e:	4621      	mov	r1, r4
  401d50:	4628      	mov	r0, r5
  401d52:	f000 f945 	bl	401fe0 <__swsetup_r>
  401d56:	2800      	cmp	r0, #0
  401d58:	d0dd      	beq.n	401d16 <_puts_r+0x2e>
  401d5a:	f04f 30ff 	mov.w	r0, #4294967295
  401d5e:	bd70      	pop	{r4, r5, r6, pc}
  401d60:	2b00      	cmp	r3, #0
  401d62:	da04      	bge.n	401d6e <_puts_r+0x86>
  401d64:	69a2      	ldr	r2, [r4, #24]
  401d66:	4293      	cmp	r3, r2
  401d68:	db06      	blt.n	401d78 <_puts_r+0x90>
  401d6a:	290a      	cmp	r1, #10
  401d6c:	d004      	beq.n	401d78 <_puts_r+0x90>
  401d6e:	6823      	ldr	r3, [r4, #0]
  401d70:	1c5a      	adds	r2, r3, #1
  401d72:	6022      	str	r2, [r4, #0]
  401d74:	7019      	strb	r1, [r3, #0]
  401d76:	e7cf      	b.n	401d18 <_puts_r+0x30>
  401d78:	4622      	mov	r2, r4
  401d7a:	4628      	mov	r0, r5
  401d7c:	f000 f8de 	bl	401f3c <__swbuf_r>
  401d80:	3001      	adds	r0, #1
  401d82:	d1c9      	bne.n	401d18 <_puts_r+0x30>
  401d84:	e7e9      	b.n	401d5a <_puts_r+0x72>
  401d86:	6823      	ldr	r3, [r4, #0]
  401d88:	200a      	movs	r0, #10
  401d8a:	1c5a      	adds	r2, r3, #1
  401d8c:	6022      	str	r2, [r4, #0]
  401d8e:	7018      	strb	r0, [r3, #0]
  401d90:	bd70      	pop	{r4, r5, r6, pc}
  401d92:	bf00      	nop
  401d94:	00402e24 	.word	0x00402e24
  401d98:	00402e44 	.word	0x00402e44
  401d9c:	00402e04 	.word	0x00402e04

00401da0 <puts>:
  401da0:	4b02      	ldr	r3, [pc, #8]	; (401dac <puts+0xc>)
  401da2:	4601      	mov	r1, r0
  401da4:	6818      	ldr	r0, [r3, #0]
  401da6:	f7ff bf9f 	b.w	401ce8 <_puts_r>
  401daa:	bf00      	nop
  401dac:	20400000 	.word	0x20400000

00401db0 <_sbrk_r>:
  401db0:	b538      	push	{r3, r4, r5, lr}
  401db2:	4c06      	ldr	r4, [pc, #24]	; (401dcc <_sbrk_r+0x1c>)
  401db4:	2300      	movs	r3, #0
  401db6:	4605      	mov	r5, r0
  401db8:	4608      	mov	r0, r1
  401dba:	6023      	str	r3, [r4, #0]
  401dbc:	f7fe feb8 	bl	400b30 <_sbrk>
  401dc0:	1c43      	adds	r3, r0, #1
  401dc2:	d102      	bne.n	401dca <_sbrk_r+0x1a>
  401dc4:	6823      	ldr	r3, [r4, #0]
  401dc6:	b103      	cbz	r3, 401dca <_sbrk_r+0x1a>
  401dc8:	602b      	str	r3, [r5, #0]
  401dca:	bd38      	pop	{r3, r4, r5, pc}
  401dcc:	20400120 	.word	0x20400120

00401dd0 <setbuf>:
  401dd0:	2900      	cmp	r1, #0
  401dd2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401dd6:	bf0c      	ite	eq
  401dd8:	2202      	moveq	r2, #2
  401dda:	2200      	movne	r2, #0
  401ddc:	f000 b800 	b.w	401de0 <setvbuf>

00401de0 <setvbuf>:
  401de0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  401de4:	461d      	mov	r5, r3
  401de6:	4b51      	ldr	r3, [pc, #324]	; (401f2c <setvbuf+0x14c>)
  401de8:	681e      	ldr	r6, [r3, #0]
  401dea:	4604      	mov	r4, r0
  401dec:	460f      	mov	r7, r1
  401dee:	4690      	mov	r8, r2
  401df0:	b126      	cbz	r6, 401dfc <setvbuf+0x1c>
  401df2:	69b3      	ldr	r3, [r6, #24]
  401df4:	b913      	cbnz	r3, 401dfc <setvbuf+0x1c>
  401df6:	4630      	mov	r0, r6
  401df8:	f000 fa52 	bl	4022a0 <__sinit>
  401dfc:	4b4c      	ldr	r3, [pc, #304]	; (401f30 <setvbuf+0x150>)
  401dfe:	429c      	cmp	r4, r3
  401e00:	d152      	bne.n	401ea8 <setvbuf+0xc8>
  401e02:	6874      	ldr	r4, [r6, #4]
  401e04:	f1b8 0f02 	cmp.w	r8, #2
  401e08:	d006      	beq.n	401e18 <setvbuf+0x38>
  401e0a:	f1b8 0f01 	cmp.w	r8, #1
  401e0e:	f200 8089 	bhi.w	401f24 <setvbuf+0x144>
  401e12:	2d00      	cmp	r5, #0
  401e14:	f2c0 8086 	blt.w	401f24 <setvbuf+0x144>
  401e18:	4621      	mov	r1, r4
  401e1a:	4630      	mov	r0, r6
  401e1c:	f000 f9d6 	bl	4021cc <_fflush_r>
  401e20:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401e22:	b141      	cbz	r1, 401e36 <setvbuf+0x56>
  401e24:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401e28:	4299      	cmp	r1, r3
  401e2a:	d002      	beq.n	401e32 <setvbuf+0x52>
  401e2c:	4630      	mov	r0, r6
  401e2e:	f7ff fe97 	bl	401b60 <_free_r>
  401e32:	2300      	movs	r3, #0
  401e34:	6363      	str	r3, [r4, #52]	; 0x34
  401e36:	2300      	movs	r3, #0
  401e38:	61a3      	str	r3, [r4, #24]
  401e3a:	6063      	str	r3, [r4, #4]
  401e3c:	89a3      	ldrh	r3, [r4, #12]
  401e3e:	061b      	lsls	r3, r3, #24
  401e40:	d503      	bpl.n	401e4a <setvbuf+0x6a>
  401e42:	6921      	ldr	r1, [r4, #16]
  401e44:	4630      	mov	r0, r6
  401e46:	f7ff fe8b 	bl	401b60 <_free_r>
  401e4a:	89a3      	ldrh	r3, [r4, #12]
  401e4c:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  401e50:	f023 0303 	bic.w	r3, r3, #3
  401e54:	f1b8 0f02 	cmp.w	r8, #2
  401e58:	81a3      	strh	r3, [r4, #12]
  401e5a:	d05d      	beq.n	401f18 <setvbuf+0x138>
  401e5c:	ab01      	add	r3, sp, #4
  401e5e:	466a      	mov	r2, sp
  401e60:	4621      	mov	r1, r4
  401e62:	4630      	mov	r0, r6
  401e64:	f000 faa6 	bl	4023b4 <__swhatbuf_r>
  401e68:	89a3      	ldrh	r3, [r4, #12]
  401e6a:	4318      	orrs	r0, r3
  401e6c:	81a0      	strh	r0, [r4, #12]
  401e6e:	bb2d      	cbnz	r5, 401ebc <setvbuf+0xdc>
  401e70:	9d00      	ldr	r5, [sp, #0]
  401e72:	4628      	mov	r0, r5
  401e74:	f7ff fe64 	bl	401b40 <malloc>
  401e78:	4607      	mov	r7, r0
  401e7a:	2800      	cmp	r0, #0
  401e7c:	d14e      	bne.n	401f1c <setvbuf+0x13c>
  401e7e:	f8dd 9000 	ldr.w	r9, [sp]
  401e82:	45a9      	cmp	r9, r5
  401e84:	d13c      	bne.n	401f00 <setvbuf+0x120>
  401e86:	f04f 30ff 	mov.w	r0, #4294967295
  401e8a:	89a3      	ldrh	r3, [r4, #12]
  401e8c:	f043 0302 	orr.w	r3, r3, #2
  401e90:	81a3      	strh	r3, [r4, #12]
  401e92:	2300      	movs	r3, #0
  401e94:	60a3      	str	r3, [r4, #8]
  401e96:	f104 0347 	add.w	r3, r4, #71	; 0x47
  401e9a:	6023      	str	r3, [r4, #0]
  401e9c:	6123      	str	r3, [r4, #16]
  401e9e:	2301      	movs	r3, #1
  401ea0:	6163      	str	r3, [r4, #20]
  401ea2:	b003      	add	sp, #12
  401ea4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401ea8:	4b22      	ldr	r3, [pc, #136]	; (401f34 <setvbuf+0x154>)
  401eaa:	429c      	cmp	r4, r3
  401eac:	d101      	bne.n	401eb2 <setvbuf+0xd2>
  401eae:	68b4      	ldr	r4, [r6, #8]
  401eb0:	e7a8      	b.n	401e04 <setvbuf+0x24>
  401eb2:	4b21      	ldr	r3, [pc, #132]	; (401f38 <setvbuf+0x158>)
  401eb4:	429c      	cmp	r4, r3
  401eb6:	bf08      	it	eq
  401eb8:	68f4      	ldreq	r4, [r6, #12]
  401eba:	e7a3      	b.n	401e04 <setvbuf+0x24>
  401ebc:	2f00      	cmp	r7, #0
  401ebe:	d0d8      	beq.n	401e72 <setvbuf+0x92>
  401ec0:	69b3      	ldr	r3, [r6, #24]
  401ec2:	b913      	cbnz	r3, 401eca <setvbuf+0xea>
  401ec4:	4630      	mov	r0, r6
  401ec6:	f000 f9eb 	bl	4022a0 <__sinit>
  401eca:	f1b8 0f01 	cmp.w	r8, #1
  401ece:	bf08      	it	eq
  401ed0:	89a3      	ldrheq	r3, [r4, #12]
  401ed2:	6027      	str	r7, [r4, #0]
  401ed4:	bf04      	itt	eq
  401ed6:	f043 0301 	orreq.w	r3, r3, #1
  401eda:	81a3      	strheq	r3, [r4, #12]
  401edc:	89a3      	ldrh	r3, [r4, #12]
  401ede:	6127      	str	r7, [r4, #16]
  401ee0:	f013 0008 	ands.w	r0, r3, #8
  401ee4:	6165      	str	r5, [r4, #20]
  401ee6:	d01b      	beq.n	401f20 <setvbuf+0x140>
  401ee8:	f013 0001 	ands.w	r0, r3, #1
  401eec:	bf18      	it	ne
  401eee:	426d      	negne	r5, r5
  401ef0:	f04f 0300 	mov.w	r3, #0
  401ef4:	bf1d      	ittte	ne
  401ef6:	60a3      	strne	r3, [r4, #8]
  401ef8:	61a5      	strne	r5, [r4, #24]
  401efa:	4618      	movne	r0, r3
  401efc:	60a5      	streq	r5, [r4, #8]
  401efe:	e7d0      	b.n	401ea2 <setvbuf+0xc2>
  401f00:	4648      	mov	r0, r9
  401f02:	f7ff fe1d 	bl	401b40 <malloc>
  401f06:	4607      	mov	r7, r0
  401f08:	2800      	cmp	r0, #0
  401f0a:	d0bc      	beq.n	401e86 <setvbuf+0xa6>
  401f0c:	89a3      	ldrh	r3, [r4, #12]
  401f0e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  401f12:	81a3      	strh	r3, [r4, #12]
  401f14:	464d      	mov	r5, r9
  401f16:	e7d3      	b.n	401ec0 <setvbuf+0xe0>
  401f18:	2000      	movs	r0, #0
  401f1a:	e7b6      	b.n	401e8a <setvbuf+0xaa>
  401f1c:	46a9      	mov	r9, r5
  401f1e:	e7f5      	b.n	401f0c <setvbuf+0x12c>
  401f20:	60a0      	str	r0, [r4, #8]
  401f22:	e7be      	b.n	401ea2 <setvbuf+0xc2>
  401f24:	f04f 30ff 	mov.w	r0, #4294967295
  401f28:	e7bb      	b.n	401ea2 <setvbuf+0xc2>
  401f2a:	bf00      	nop
  401f2c:	20400000 	.word	0x20400000
  401f30:	00402e24 	.word	0x00402e24
  401f34:	00402e44 	.word	0x00402e44
  401f38:	00402e04 	.word	0x00402e04

00401f3c <__swbuf_r>:
  401f3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401f3e:	460e      	mov	r6, r1
  401f40:	4614      	mov	r4, r2
  401f42:	4605      	mov	r5, r0
  401f44:	b118      	cbz	r0, 401f4e <__swbuf_r+0x12>
  401f46:	6983      	ldr	r3, [r0, #24]
  401f48:	b90b      	cbnz	r3, 401f4e <__swbuf_r+0x12>
  401f4a:	f000 f9a9 	bl	4022a0 <__sinit>
  401f4e:	4b21      	ldr	r3, [pc, #132]	; (401fd4 <__swbuf_r+0x98>)
  401f50:	429c      	cmp	r4, r3
  401f52:	d12a      	bne.n	401faa <__swbuf_r+0x6e>
  401f54:	686c      	ldr	r4, [r5, #4]
  401f56:	69a3      	ldr	r3, [r4, #24]
  401f58:	60a3      	str	r3, [r4, #8]
  401f5a:	89a3      	ldrh	r3, [r4, #12]
  401f5c:	071a      	lsls	r2, r3, #28
  401f5e:	d52e      	bpl.n	401fbe <__swbuf_r+0x82>
  401f60:	6923      	ldr	r3, [r4, #16]
  401f62:	b363      	cbz	r3, 401fbe <__swbuf_r+0x82>
  401f64:	6923      	ldr	r3, [r4, #16]
  401f66:	6820      	ldr	r0, [r4, #0]
  401f68:	1ac0      	subs	r0, r0, r3
  401f6a:	6963      	ldr	r3, [r4, #20]
  401f6c:	b2f6      	uxtb	r6, r6
  401f6e:	4298      	cmp	r0, r3
  401f70:	4637      	mov	r7, r6
  401f72:	db04      	blt.n	401f7e <__swbuf_r+0x42>
  401f74:	4621      	mov	r1, r4
  401f76:	4628      	mov	r0, r5
  401f78:	f000 f928 	bl	4021cc <_fflush_r>
  401f7c:	bb28      	cbnz	r0, 401fca <__swbuf_r+0x8e>
  401f7e:	68a3      	ldr	r3, [r4, #8]
  401f80:	3b01      	subs	r3, #1
  401f82:	60a3      	str	r3, [r4, #8]
  401f84:	6823      	ldr	r3, [r4, #0]
  401f86:	1c5a      	adds	r2, r3, #1
  401f88:	6022      	str	r2, [r4, #0]
  401f8a:	701e      	strb	r6, [r3, #0]
  401f8c:	6963      	ldr	r3, [r4, #20]
  401f8e:	3001      	adds	r0, #1
  401f90:	4298      	cmp	r0, r3
  401f92:	d004      	beq.n	401f9e <__swbuf_r+0x62>
  401f94:	89a3      	ldrh	r3, [r4, #12]
  401f96:	07db      	lsls	r3, r3, #31
  401f98:	d519      	bpl.n	401fce <__swbuf_r+0x92>
  401f9a:	2e0a      	cmp	r6, #10
  401f9c:	d117      	bne.n	401fce <__swbuf_r+0x92>
  401f9e:	4621      	mov	r1, r4
  401fa0:	4628      	mov	r0, r5
  401fa2:	f000 f913 	bl	4021cc <_fflush_r>
  401fa6:	b190      	cbz	r0, 401fce <__swbuf_r+0x92>
  401fa8:	e00f      	b.n	401fca <__swbuf_r+0x8e>
  401faa:	4b0b      	ldr	r3, [pc, #44]	; (401fd8 <__swbuf_r+0x9c>)
  401fac:	429c      	cmp	r4, r3
  401fae:	d101      	bne.n	401fb4 <__swbuf_r+0x78>
  401fb0:	68ac      	ldr	r4, [r5, #8]
  401fb2:	e7d0      	b.n	401f56 <__swbuf_r+0x1a>
  401fb4:	4b09      	ldr	r3, [pc, #36]	; (401fdc <__swbuf_r+0xa0>)
  401fb6:	429c      	cmp	r4, r3
  401fb8:	bf08      	it	eq
  401fba:	68ec      	ldreq	r4, [r5, #12]
  401fbc:	e7cb      	b.n	401f56 <__swbuf_r+0x1a>
  401fbe:	4621      	mov	r1, r4
  401fc0:	4628      	mov	r0, r5
  401fc2:	f000 f80d 	bl	401fe0 <__swsetup_r>
  401fc6:	2800      	cmp	r0, #0
  401fc8:	d0cc      	beq.n	401f64 <__swbuf_r+0x28>
  401fca:	f04f 37ff 	mov.w	r7, #4294967295
  401fce:	4638      	mov	r0, r7
  401fd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401fd2:	bf00      	nop
  401fd4:	00402e24 	.word	0x00402e24
  401fd8:	00402e44 	.word	0x00402e44
  401fdc:	00402e04 	.word	0x00402e04

00401fe0 <__swsetup_r>:
  401fe0:	4b32      	ldr	r3, [pc, #200]	; (4020ac <__swsetup_r+0xcc>)
  401fe2:	b570      	push	{r4, r5, r6, lr}
  401fe4:	681d      	ldr	r5, [r3, #0]
  401fe6:	4606      	mov	r6, r0
  401fe8:	460c      	mov	r4, r1
  401fea:	b125      	cbz	r5, 401ff6 <__swsetup_r+0x16>
  401fec:	69ab      	ldr	r3, [r5, #24]
  401fee:	b913      	cbnz	r3, 401ff6 <__swsetup_r+0x16>
  401ff0:	4628      	mov	r0, r5
  401ff2:	f000 f955 	bl	4022a0 <__sinit>
  401ff6:	4b2e      	ldr	r3, [pc, #184]	; (4020b0 <__swsetup_r+0xd0>)
  401ff8:	429c      	cmp	r4, r3
  401ffa:	d10f      	bne.n	40201c <__swsetup_r+0x3c>
  401ffc:	686c      	ldr	r4, [r5, #4]
  401ffe:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  402002:	b29a      	uxth	r2, r3
  402004:	0715      	lsls	r5, r2, #28
  402006:	d42c      	bmi.n	402062 <__swsetup_r+0x82>
  402008:	06d0      	lsls	r0, r2, #27
  40200a:	d411      	bmi.n	402030 <__swsetup_r+0x50>
  40200c:	2209      	movs	r2, #9
  40200e:	6032      	str	r2, [r6, #0]
  402010:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  402014:	81a3      	strh	r3, [r4, #12]
  402016:	f04f 30ff 	mov.w	r0, #4294967295
  40201a:	bd70      	pop	{r4, r5, r6, pc}
  40201c:	4b25      	ldr	r3, [pc, #148]	; (4020b4 <__swsetup_r+0xd4>)
  40201e:	429c      	cmp	r4, r3
  402020:	d101      	bne.n	402026 <__swsetup_r+0x46>
  402022:	68ac      	ldr	r4, [r5, #8]
  402024:	e7eb      	b.n	401ffe <__swsetup_r+0x1e>
  402026:	4b24      	ldr	r3, [pc, #144]	; (4020b8 <__swsetup_r+0xd8>)
  402028:	429c      	cmp	r4, r3
  40202a:	bf08      	it	eq
  40202c:	68ec      	ldreq	r4, [r5, #12]
  40202e:	e7e6      	b.n	401ffe <__swsetup_r+0x1e>
  402030:	0751      	lsls	r1, r2, #29
  402032:	d512      	bpl.n	40205a <__swsetup_r+0x7a>
  402034:	6b61      	ldr	r1, [r4, #52]	; 0x34
  402036:	b141      	cbz	r1, 40204a <__swsetup_r+0x6a>
  402038:	f104 0344 	add.w	r3, r4, #68	; 0x44
  40203c:	4299      	cmp	r1, r3
  40203e:	d002      	beq.n	402046 <__swsetup_r+0x66>
  402040:	4630      	mov	r0, r6
  402042:	f7ff fd8d 	bl	401b60 <_free_r>
  402046:	2300      	movs	r3, #0
  402048:	6363      	str	r3, [r4, #52]	; 0x34
  40204a:	89a3      	ldrh	r3, [r4, #12]
  40204c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
  402050:	81a3      	strh	r3, [r4, #12]
  402052:	2300      	movs	r3, #0
  402054:	6063      	str	r3, [r4, #4]
  402056:	6923      	ldr	r3, [r4, #16]
  402058:	6023      	str	r3, [r4, #0]
  40205a:	89a3      	ldrh	r3, [r4, #12]
  40205c:	f043 0308 	orr.w	r3, r3, #8
  402060:	81a3      	strh	r3, [r4, #12]
  402062:	6923      	ldr	r3, [r4, #16]
  402064:	b94b      	cbnz	r3, 40207a <__swsetup_r+0x9a>
  402066:	89a3      	ldrh	r3, [r4, #12]
  402068:	f403 7320 	and.w	r3, r3, #640	; 0x280
  40206c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402070:	d003      	beq.n	40207a <__swsetup_r+0x9a>
  402072:	4621      	mov	r1, r4
  402074:	4630      	mov	r0, r6
  402076:	f000 f9c1 	bl	4023fc <__smakebuf_r>
  40207a:	89a2      	ldrh	r2, [r4, #12]
  40207c:	f012 0301 	ands.w	r3, r2, #1
  402080:	d00c      	beq.n	40209c <__swsetup_r+0xbc>
  402082:	2300      	movs	r3, #0
  402084:	60a3      	str	r3, [r4, #8]
  402086:	6963      	ldr	r3, [r4, #20]
  402088:	425b      	negs	r3, r3
  40208a:	61a3      	str	r3, [r4, #24]
  40208c:	6923      	ldr	r3, [r4, #16]
  40208e:	b953      	cbnz	r3, 4020a6 <__swsetup_r+0xc6>
  402090:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  402094:	f013 0080 	ands.w	r0, r3, #128	; 0x80
  402098:	d1ba      	bne.n	402010 <__swsetup_r+0x30>
  40209a:	bd70      	pop	{r4, r5, r6, pc}
  40209c:	0792      	lsls	r2, r2, #30
  40209e:	bf58      	it	pl
  4020a0:	6963      	ldrpl	r3, [r4, #20]
  4020a2:	60a3      	str	r3, [r4, #8]
  4020a4:	e7f2      	b.n	40208c <__swsetup_r+0xac>
  4020a6:	2000      	movs	r0, #0
  4020a8:	e7f7      	b.n	40209a <__swsetup_r+0xba>
  4020aa:	bf00      	nop
  4020ac:	20400000 	.word	0x20400000
  4020b0:	00402e24 	.word	0x00402e24
  4020b4:	00402e44 	.word	0x00402e44
  4020b8:	00402e04 	.word	0x00402e04

004020bc <__sflush_r>:
  4020bc:	898a      	ldrh	r2, [r1, #12]
  4020be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4020c2:	4605      	mov	r5, r0
  4020c4:	0710      	lsls	r0, r2, #28
  4020c6:	460c      	mov	r4, r1
  4020c8:	d45a      	bmi.n	402180 <__sflush_r+0xc4>
  4020ca:	684b      	ldr	r3, [r1, #4]
  4020cc:	2b00      	cmp	r3, #0
  4020ce:	dc05      	bgt.n	4020dc <__sflush_r+0x20>
  4020d0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  4020d2:	2b00      	cmp	r3, #0
  4020d4:	dc02      	bgt.n	4020dc <__sflush_r+0x20>
  4020d6:	2000      	movs	r0, #0
  4020d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4020dc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  4020de:	2e00      	cmp	r6, #0
  4020e0:	d0f9      	beq.n	4020d6 <__sflush_r+0x1a>
  4020e2:	2300      	movs	r3, #0
  4020e4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  4020e8:	682f      	ldr	r7, [r5, #0]
  4020ea:	602b      	str	r3, [r5, #0]
  4020ec:	d033      	beq.n	402156 <__sflush_r+0x9a>
  4020ee:	6d60      	ldr	r0, [r4, #84]	; 0x54
  4020f0:	89a3      	ldrh	r3, [r4, #12]
  4020f2:	075a      	lsls	r2, r3, #29
  4020f4:	d505      	bpl.n	402102 <__sflush_r+0x46>
  4020f6:	6863      	ldr	r3, [r4, #4]
  4020f8:	1ac0      	subs	r0, r0, r3
  4020fa:	6b63      	ldr	r3, [r4, #52]	; 0x34
  4020fc:	b10b      	cbz	r3, 402102 <__sflush_r+0x46>
  4020fe:	6c23      	ldr	r3, [r4, #64]	; 0x40
  402100:	1ac0      	subs	r0, r0, r3
  402102:	2300      	movs	r3, #0
  402104:	4602      	mov	r2, r0
  402106:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  402108:	6a21      	ldr	r1, [r4, #32]
  40210a:	4628      	mov	r0, r5
  40210c:	47b0      	blx	r6
  40210e:	1c43      	adds	r3, r0, #1
  402110:	89a3      	ldrh	r3, [r4, #12]
  402112:	d106      	bne.n	402122 <__sflush_r+0x66>
  402114:	6829      	ldr	r1, [r5, #0]
  402116:	291d      	cmp	r1, #29
  402118:	d84b      	bhi.n	4021b2 <__sflush_r+0xf6>
  40211a:	4a2b      	ldr	r2, [pc, #172]	; (4021c8 <__sflush_r+0x10c>)
  40211c:	40ca      	lsrs	r2, r1
  40211e:	07d6      	lsls	r6, r2, #31
  402120:	d547      	bpl.n	4021b2 <__sflush_r+0xf6>
  402122:	2200      	movs	r2, #0
  402124:	6062      	str	r2, [r4, #4]
  402126:	04d9      	lsls	r1, r3, #19
  402128:	6922      	ldr	r2, [r4, #16]
  40212a:	6022      	str	r2, [r4, #0]
  40212c:	d504      	bpl.n	402138 <__sflush_r+0x7c>
  40212e:	1c42      	adds	r2, r0, #1
  402130:	d101      	bne.n	402136 <__sflush_r+0x7a>
  402132:	682b      	ldr	r3, [r5, #0]
  402134:	b903      	cbnz	r3, 402138 <__sflush_r+0x7c>
  402136:	6560      	str	r0, [r4, #84]	; 0x54
  402138:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40213a:	602f      	str	r7, [r5, #0]
  40213c:	2900      	cmp	r1, #0
  40213e:	d0ca      	beq.n	4020d6 <__sflush_r+0x1a>
  402140:	f104 0344 	add.w	r3, r4, #68	; 0x44
  402144:	4299      	cmp	r1, r3
  402146:	d002      	beq.n	40214e <__sflush_r+0x92>
  402148:	4628      	mov	r0, r5
  40214a:	f7ff fd09 	bl	401b60 <_free_r>
  40214e:	2000      	movs	r0, #0
  402150:	6360      	str	r0, [r4, #52]	; 0x34
  402152:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402156:	6a21      	ldr	r1, [r4, #32]
  402158:	2301      	movs	r3, #1
  40215a:	4628      	mov	r0, r5
  40215c:	47b0      	blx	r6
  40215e:	1c41      	adds	r1, r0, #1
  402160:	d1c6      	bne.n	4020f0 <__sflush_r+0x34>
  402162:	682b      	ldr	r3, [r5, #0]
  402164:	2b00      	cmp	r3, #0
  402166:	d0c3      	beq.n	4020f0 <__sflush_r+0x34>
  402168:	2b1d      	cmp	r3, #29
  40216a:	d001      	beq.n	402170 <__sflush_r+0xb4>
  40216c:	2b16      	cmp	r3, #22
  40216e:	d101      	bne.n	402174 <__sflush_r+0xb8>
  402170:	602f      	str	r7, [r5, #0]
  402172:	e7b0      	b.n	4020d6 <__sflush_r+0x1a>
  402174:	89a3      	ldrh	r3, [r4, #12]
  402176:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40217a:	81a3      	strh	r3, [r4, #12]
  40217c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402180:	690f      	ldr	r7, [r1, #16]
  402182:	2f00      	cmp	r7, #0
  402184:	d0a7      	beq.n	4020d6 <__sflush_r+0x1a>
  402186:	0793      	lsls	r3, r2, #30
  402188:	680e      	ldr	r6, [r1, #0]
  40218a:	bf08      	it	eq
  40218c:	694b      	ldreq	r3, [r1, #20]
  40218e:	600f      	str	r7, [r1, #0]
  402190:	bf18      	it	ne
  402192:	2300      	movne	r3, #0
  402194:	eba6 0807 	sub.w	r8, r6, r7
  402198:	608b      	str	r3, [r1, #8]
  40219a:	f1b8 0f00 	cmp.w	r8, #0
  40219e:	dd9a      	ble.n	4020d6 <__sflush_r+0x1a>
  4021a0:	4643      	mov	r3, r8
  4021a2:	463a      	mov	r2, r7
  4021a4:	6a21      	ldr	r1, [r4, #32]
  4021a6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  4021a8:	4628      	mov	r0, r5
  4021aa:	47b0      	blx	r6
  4021ac:	2800      	cmp	r0, #0
  4021ae:	dc07      	bgt.n	4021c0 <__sflush_r+0x104>
  4021b0:	89a3      	ldrh	r3, [r4, #12]
  4021b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4021b6:	81a3      	strh	r3, [r4, #12]
  4021b8:	f04f 30ff 	mov.w	r0, #4294967295
  4021bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4021c0:	4407      	add	r7, r0
  4021c2:	eba8 0800 	sub.w	r8, r8, r0
  4021c6:	e7e8      	b.n	40219a <__sflush_r+0xde>
  4021c8:	20400001 	.word	0x20400001

004021cc <_fflush_r>:
  4021cc:	b538      	push	{r3, r4, r5, lr}
  4021ce:	690b      	ldr	r3, [r1, #16]
  4021d0:	4605      	mov	r5, r0
  4021d2:	460c      	mov	r4, r1
  4021d4:	b1db      	cbz	r3, 40220e <_fflush_r+0x42>
  4021d6:	b118      	cbz	r0, 4021e0 <_fflush_r+0x14>
  4021d8:	6983      	ldr	r3, [r0, #24]
  4021da:	b90b      	cbnz	r3, 4021e0 <_fflush_r+0x14>
  4021dc:	f000 f860 	bl	4022a0 <__sinit>
  4021e0:	4b0c      	ldr	r3, [pc, #48]	; (402214 <_fflush_r+0x48>)
  4021e2:	429c      	cmp	r4, r3
  4021e4:	d109      	bne.n	4021fa <_fflush_r+0x2e>
  4021e6:	686c      	ldr	r4, [r5, #4]
  4021e8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  4021ec:	b17b      	cbz	r3, 40220e <_fflush_r+0x42>
  4021ee:	4621      	mov	r1, r4
  4021f0:	4628      	mov	r0, r5
  4021f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  4021f6:	f7ff bf61 	b.w	4020bc <__sflush_r>
  4021fa:	4b07      	ldr	r3, [pc, #28]	; (402218 <_fflush_r+0x4c>)
  4021fc:	429c      	cmp	r4, r3
  4021fe:	d101      	bne.n	402204 <_fflush_r+0x38>
  402200:	68ac      	ldr	r4, [r5, #8]
  402202:	e7f1      	b.n	4021e8 <_fflush_r+0x1c>
  402204:	4b05      	ldr	r3, [pc, #20]	; (40221c <_fflush_r+0x50>)
  402206:	429c      	cmp	r4, r3
  402208:	bf08      	it	eq
  40220a:	68ec      	ldreq	r4, [r5, #12]
  40220c:	e7ec      	b.n	4021e8 <_fflush_r+0x1c>
  40220e:	2000      	movs	r0, #0
  402210:	bd38      	pop	{r3, r4, r5, pc}
  402212:	bf00      	nop
  402214:	00402e24 	.word	0x00402e24
  402218:	00402e44 	.word	0x00402e44
  40221c:	00402e04 	.word	0x00402e04

00402220 <_cleanup_r>:
  402220:	4901      	ldr	r1, [pc, #4]	; (402228 <_cleanup_r+0x8>)
  402222:	f000 b8a9 	b.w	402378 <_fwalk_reent>
  402226:	bf00      	nop
  402228:	004021cd 	.word	0x004021cd

0040222c <std.isra.0>:
  40222c:	2300      	movs	r3, #0
  40222e:	b510      	push	{r4, lr}
  402230:	4604      	mov	r4, r0
  402232:	6003      	str	r3, [r0, #0]
  402234:	6043      	str	r3, [r0, #4]
  402236:	6083      	str	r3, [r0, #8]
  402238:	8181      	strh	r1, [r0, #12]
  40223a:	6643      	str	r3, [r0, #100]	; 0x64
  40223c:	81c2      	strh	r2, [r0, #14]
  40223e:	6103      	str	r3, [r0, #16]
  402240:	6143      	str	r3, [r0, #20]
  402242:	6183      	str	r3, [r0, #24]
  402244:	4619      	mov	r1, r3
  402246:	2208      	movs	r2, #8
  402248:	305c      	adds	r0, #92	; 0x5c
  40224a:	f7ff fc81 	bl	401b50 <memset>
  40224e:	4b05      	ldr	r3, [pc, #20]	; (402264 <std.isra.0+0x38>)
  402250:	6263      	str	r3, [r4, #36]	; 0x24
  402252:	4b05      	ldr	r3, [pc, #20]	; (402268 <std.isra.0+0x3c>)
  402254:	62a3      	str	r3, [r4, #40]	; 0x28
  402256:	4b05      	ldr	r3, [pc, #20]	; (40226c <std.isra.0+0x40>)
  402258:	62e3      	str	r3, [r4, #44]	; 0x2c
  40225a:	4b05      	ldr	r3, [pc, #20]	; (402270 <std.isra.0+0x44>)
  40225c:	6224      	str	r4, [r4, #32]
  40225e:	6323      	str	r3, [r4, #48]	; 0x30
  402260:	bd10      	pop	{r4, pc}
  402262:	bf00      	nop
  402264:	00402a29 	.word	0x00402a29
  402268:	00402a4b 	.word	0x00402a4b
  40226c:	00402a83 	.word	0x00402a83
  402270:	00402aa7 	.word	0x00402aa7

00402274 <__sfmoreglue>:
  402274:	b570      	push	{r4, r5, r6, lr}
  402276:	1e4a      	subs	r2, r1, #1
  402278:	2568      	movs	r5, #104	; 0x68
  40227a:	4355      	muls	r5, r2
  40227c:	460e      	mov	r6, r1
  40227e:	f105 0174 	add.w	r1, r5, #116	; 0x74
  402282:	f7ff fcbb 	bl	401bfc <_malloc_r>
  402286:	4604      	mov	r4, r0
  402288:	b140      	cbz	r0, 40229c <__sfmoreglue+0x28>
  40228a:	2100      	movs	r1, #0
  40228c:	e880 0042 	stmia.w	r0, {r1, r6}
  402290:	300c      	adds	r0, #12
  402292:	60a0      	str	r0, [r4, #8]
  402294:	f105 0268 	add.w	r2, r5, #104	; 0x68
  402298:	f7ff fc5a 	bl	401b50 <memset>
  40229c:	4620      	mov	r0, r4
  40229e:	bd70      	pop	{r4, r5, r6, pc}

004022a0 <__sinit>:
  4022a0:	6983      	ldr	r3, [r0, #24]
  4022a2:	b510      	push	{r4, lr}
  4022a4:	4604      	mov	r4, r0
  4022a6:	bb33      	cbnz	r3, 4022f6 <__sinit+0x56>
  4022a8:	6483      	str	r3, [r0, #72]	; 0x48
  4022aa:	64c3      	str	r3, [r0, #76]	; 0x4c
  4022ac:	6503      	str	r3, [r0, #80]	; 0x50
  4022ae:	4b12      	ldr	r3, [pc, #72]	; (4022f8 <__sinit+0x58>)
  4022b0:	4a12      	ldr	r2, [pc, #72]	; (4022fc <__sinit+0x5c>)
  4022b2:	681b      	ldr	r3, [r3, #0]
  4022b4:	6282      	str	r2, [r0, #40]	; 0x28
  4022b6:	4298      	cmp	r0, r3
  4022b8:	bf04      	itt	eq
  4022ba:	2301      	moveq	r3, #1
  4022bc:	6183      	streq	r3, [r0, #24]
  4022be:	f000 f81f 	bl	402300 <__sfp>
  4022c2:	6060      	str	r0, [r4, #4]
  4022c4:	4620      	mov	r0, r4
  4022c6:	f000 f81b 	bl	402300 <__sfp>
  4022ca:	60a0      	str	r0, [r4, #8]
  4022cc:	4620      	mov	r0, r4
  4022ce:	f000 f817 	bl	402300 <__sfp>
  4022d2:	2200      	movs	r2, #0
  4022d4:	60e0      	str	r0, [r4, #12]
  4022d6:	2104      	movs	r1, #4
  4022d8:	6860      	ldr	r0, [r4, #4]
  4022da:	f7ff ffa7 	bl	40222c <std.isra.0>
  4022de:	2201      	movs	r2, #1
  4022e0:	2109      	movs	r1, #9
  4022e2:	68a0      	ldr	r0, [r4, #8]
  4022e4:	f7ff ffa2 	bl	40222c <std.isra.0>
  4022e8:	2202      	movs	r2, #2
  4022ea:	2112      	movs	r1, #18
  4022ec:	68e0      	ldr	r0, [r4, #12]
  4022ee:	f7ff ff9d 	bl	40222c <std.isra.0>
  4022f2:	2301      	movs	r3, #1
  4022f4:	61a3      	str	r3, [r4, #24]
  4022f6:	bd10      	pop	{r4, pc}
  4022f8:	00402e00 	.word	0x00402e00
  4022fc:	00402221 	.word	0x00402221

00402300 <__sfp>:
  402300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402302:	4b1c      	ldr	r3, [pc, #112]	; (402374 <__sfp+0x74>)
  402304:	681e      	ldr	r6, [r3, #0]
  402306:	69b3      	ldr	r3, [r6, #24]
  402308:	4607      	mov	r7, r0
  40230a:	b913      	cbnz	r3, 402312 <__sfp+0x12>
  40230c:	4630      	mov	r0, r6
  40230e:	f7ff ffc7 	bl	4022a0 <__sinit>
  402312:	3648      	adds	r6, #72	; 0x48
  402314:	68b4      	ldr	r4, [r6, #8]
  402316:	6873      	ldr	r3, [r6, #4]
  402318:	3b01      	subs	r3, #1
  40231a:	d503      	bpl.n	402324 <__sfp+0x24>
  40231c:	6833      	ldr	r3, [r6, #0]
  40231e:	b133      	cbz	r3, 40232e <__sfp+0x2e>
  402320:	6836      	ldr	r6, [r6, #0]
  402322:	e7f7      	b.n	402314 <__sfp+0x14>
  402324:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  402328:	b16d      	cbz	r5, 402346 <__sfp+0x46>
  40232a:	3468      	adds	r4, #104	; 0x68
  40232c:	e7f4      	b.n	402318 <__sfp+0x18>
  40232e:	2104      	movs	r1, #4
  402330:	4638      	mov	r0, r7
  402332:	f7ff ff9f 	bl	402274 <__sfmoreglue>
  402336:	6030      	str	r0, [r6, #0]
  402338:	2800      	cmp	r0, #0
  40233a:	d1f1      	bne.n	402320 <__sfp+0x20>
  40233c:	230c      	movs	r3, #12
  40233e:	603b      	str	r3, [r7, #0]
  402340:	4604      	mov	r4, r0
  402342:	4620      	mov	r0, r4
  402344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402346:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40234a:	81e3      	strh	r3, [r4, #14]
  40234c:	2301      	movs	r3, #1
  40234e:	81a3      	strh	r3, [r4, #12]
  402350:	6665      	str	r5, [r4, #100]	; 0x64
  402352:	6025      	str	r5, [r4, #0]
  402354:	60a5      	str	r5, [r4, #8]
  402356:	6065      	str	r5, [r4, #4]
  402358:	6125      	str	r5, [r4, #16]
  40235a:	6165      	str	r5, [r4, #20]
  40235c:	61a5      	str	r5, [r4, #24]
  40235e:	2208      	movs	r2, #8
  402360:	4629      	mov	r1, r5
  402362:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  402366:	f7ff fbf3 	bl	401b50 <memset>
  40236a:	6365      	str	r5, [r4, #52]	; 0x34
  40236c:	63a5      	str	r5, [r4, #56]	; 0x38
  40236e:	64a5      	str	r5, [r4, #72]	; 0x48
  402370:	64e5      	str	r5, [r4, #76]	; 0x4c
  402372:	e7e6      	b.n	402342 <__sfp+0x42>
  402374:	00402e00 	.word	0x00402e00

00402378 <_fwalk_reent>:
  402378:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40237c:	4680      	mov	r8, r0
  40237e:	4689      	mov	r9, r1
  402380:	f100 0448 	add.w	r4, r0, #72	; 0x48
  402384:	2600      	movs	r6, #0
  402386:	b914      	cbnz	r4, 40238e <_fwalk_reent+0x16>
  402388:	4630      	mov	r0, r6
  40238a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40238e:	68a5      	ldr	r5, [r4, #8]
  402390:	6867      	ldr	r7, [r4, #4]
  402392:	3f01      	subs	r7, #1
  402394:	d501      	bpl.n	40239a <_fwalk_reent+0x22>
  402396:	6824      	ldr	r4, [r4, #0]
  402398:	e7f5      	b.n	402386 <_fwalk_reent+0xe>
  40239a:	89ab      	ldrh	r3, [r5, #12]
  40239c:	2b01      	cmp	r3, #1
  40239e:	d907      	bls.n	4023b0 <_fwalk_reent+0x38>
  4023a0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  4023a4:	3301      	adds	r3, #1
  4023a6:	d003      	beq.n	4023b0 <_fwalk_reent+0x38>
  4023a8:	4629      	mov	r1, r5
  4023aa:	4640      	mov	r0, r8
  4023ac:	47c8      	blx	r9
  4023ae:	4306      	orrs	r6, r0
  4023b0:	3568      	adds	r5, #104	; 0x68
  4023b2:	e7ee      	b.n	402392 <_fwalk_reent+0x1a>

004023b4 <__swhatbuf_r>:
  4023b4:	b570      	push	{r4, r5, r6, lr}
  4023b6:	460e      	mov	r6, r1
  4023b8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4023bc:	2900      	cmp	r1, #0
  4023be:	b090      	sub	sp, #64	; 0x40
  4023c0:	4614      	mov	r4, r2
  4023c2:	461d      	mov	r5, r3
  4023c4:	da07      	bge.n	4023d6 <__swhatbuf_r+0x22>
  4023c6:	2300      	movs	r3, #0
  4023c8:	602b      	str	r3, [r5, #0]
  4023ca:	89b3      	ldrh	r3, [r6, #12]
  4023cc:	061a      	lsls	r2, r3, #24
  4023ce:	d410      	bmi.n	4023f2 <__swhatbuf_r+0x3e>
  4023d0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4023d4:	e00e      	b.n	4023f4 <__swhatbuf_r+0x40>
  4023d6:	aa01      	add	r2, sp, #4
  4023d8:	f000 fb8c 	bl	402af4 <_fstat_r>
  4023dc:	2800      	cmp	r0, #0
  4023de:	dbf2      	blt.n	4023c6 <__swhatbuf_r+0x12>
  4023e0:	9a02      	ldr	r2, [sp, #8]
  4023e2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  4023e6:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  4023ea:	425a      	negs	r2, r3
  4023ec:	415a      	adcs	r2, r3
  4023ee:	602a      	str	r2, [r5, #0]
  4023f0:	e7ee      	b.n	4023d0 <__swhatbuf_r+0x1c>
  4023f2:	2340      	movs	r3, #64	; 0x40
  4023f4:	2000      	movs	r0, #0
  4023f6:	6023      	str	r3, [r4, #0]
  4023f8:	b010      	add	sp, #64	; 0x40
  4023fa:	bd70      	pop	{r4, r5, r6, pc}

004023fc <__smakebuf_r>:
  4023fc:	898b      	ldrh	r3, [r1, #12]
  4023fe:	b573      	push	{r0, r1, r4, r5, r6, lr}
  402400:	079d      	lsls	r5, r3, #30
  402402:	4606      	mov	r6, r0
  402404:	460c      	mov	r4, r1
  402406:	d507      	bpl.n	402418 <__smakebuf_r+0x1c>
  402408:	f104 0347 	add.w	r3, r4, #71	; 0x47
  40240c:	6023      	str	r3, [r4, #0]
  40240e:	6123      	str	r3, [r4, #16]
  402410:	2301      	movs	r3, #1
  402412:	6163      	str	r3, [r4, #20]
  402414:	b002      	add	sp, #8
  402416:	bd70      	pop	{r4, r5, r6, pc}
  402418:	ab01      	add	r3, sp, #4
  40241a:	466a      	mov	r2, sp
  40241c:	f7ff ffca 	bl	4023b4 <__swhatbuf_r>
  402420:	9900      	ldr	r1, [sp, #0]
  402422:	4605      	mov	r5, r0
  402424:	4630      	mov	r0, r6
  402426:	f7ff fbe9 	bl	401bfc <_malloc_r>
  40242a:	b948      	cbnz	r0, 402440 <__smakebuf_r+0x44>
  40242c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  402430:	059a      	lsls	r2, r3, #22
  402432:	d4ef      	bmi.n	402414 <__smakebuf_r+0x18>
  402434:	f023 0303 	bic.w	r3, r3, #3
  402438:	f043 0302 	orr.w	r3, r3, #2
  40243c:	81a3      	strh	r3, [r4, #12]
  40243e:	e7e3      	b.n	402408 <__smakebuf_r+0xc>
  402440:	4b0d      	ldr	r3, [pc, #52]	; (402478 <__smakebuf_r+0x7c>)
  402442:	62b3      	str	r3, [r6, #40]	; 0x28
  402444:	89a3      	ldrh	r3, [r4, #12]
  402446:	6020      	str	r0, [r4, #0]
  402448:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40244c:	81a3      	strh	r3, [r4, #12]
  40244e:	9b00      	ldr	r3, [sp, #0]
  402450:	6163      	str	r3, [r4, #20]
  402452:	9b01      	ldr	r3, [sp, #4]
  402454:	6120      	str	r0, [r4, #16]
  402456:	b15b      	cbz	r3, 402470 <__smakebuf_r+0x74>
  402458:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40245c:	4630      	mov	r0, r6
  40245e:	f000 fb5b 	bl	402b18 <_isatty_r>
  402462:	b128      	cbz	r0, 402470 <__smakebuf_r+0x74>
  402464:	89a3      	ldrh	r3, [r4, #12]
  402466:	f023 0303 	bic.w	r3, r3, #3
  40246a:	f043 0301 	orr.w	r3, r3, #1
  40246e:	81a3      	strh	r3, [r4, #12]
  402470:	89a3      	ldrh	r3, [r4, #12]
  402472:	431d      	orrs	r5, r3
  402474:	81a5      	strh	r5, [r4, #12]
  402476:	e7cd      	b.n	402414 <__smakebuf_r+0x18>
  402478:	00402221 	.word	0x00402221

0040247c <__malloc_lock>:
  40247c:	4770      	bx	lr

0040247e <__malloc_unlock>:
  40247e:	4770      	bx	lr

00402480 <__sfputc_r>:
  402480:	6893      	ldr	r3, [r2, #8]
  402482:	3b01      	subs	r3, #1
  402484:	2b00      	cmp	r3, #0
  402486:	b410      	push	{r4}
  402488:	6093      	str	r3, [r2, #8]
  40248a:	da08      	bge.n	40249e <__sfputc_r+0x1e>
  40248c:	6994      	ldr	r4, [r2, #24]
  40248e:	42a3      	cmp	r3, r4
  402490:	db02      	blt.n	402498 <__sfputc_r+0x18>
  402492:	b2cb      	uxtb	r3, r1
  402494:	2b0a      	cmp	r3, #10
  402496:	d102      	bne.n	40249e <__sfputc_r+0x1e>
  402498:	bc10      	pop	{r4}
  40249a:	f7ff bd4f 	b.w	401f3c <__swbuf_r>
  40249e:	6813      	ldr	r3, [r2, #0]
  4024a0:	1c58      	adds	r0, r3, #1
  4024a2:	6010      	str	r0, [r2, #0]
  4024a4:	7019      	strb	r1, [r3, #0]
  4024a6:	b2c8      	uxtb	r0, r1
  4024a8:	bc10      	pop	{r4}
  4024aa:	4770      	bx	lr

004024ac <__sfputs_r>:
  4024ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4024ae:	4606      	mov	r6, r0
  4024b0:	460f      	mov	r7, r1
  4024b2:	4614      	mov	r4, r2
  4024b4:	18d5      	adds	r5, r2, r3
  4024b6:	42ac      	cmp	r4, r5
  4024b8:	d101      	bne.n	4024be <__sfputs_r+0x12>
  4024ba:	2000      	movs	r0, #0
  4024bc:	e007      	b.n	4024ce <__sfputs_r+0x22>
  4024be:	463a      	mov	r2, r7
  4024c0:	f814 1b01 	ldrb.w	r1, [r4], #1
  4024c4:	4630      	mov	r0, r6
  4024c6:	f7ff ffdb 	bl	402480 <__sfputc_r>
  4024ca:	1c43      	adds	r3, r0, #1
  4024cc:	d1f3      	bne.n	4024b6 <__sfputs_r+0xa>
  4024ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

004024d0 <_vfiprintf_r>:
  4024d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4024d4:	b09d      	sub	sp, #116	; 0x74
  4024d6:	460c      	mov	r4, r1
  4024d8:	4617      	mov	r7, r2
  4024da:	9303      	str	r3, [sp, #12]
  4024dc:	4606      	mov	r6, r0
  4024de:	b118      	cbz	r0, 4024e8 <_vfiprintf_r+0x18>
  4024e0:	6983      	ldr	r3, [r0, #24]
  4024e2:	b90b      	cbnz	r3, 4024e8 <_vfiprintf_r+0x18>
  4024e4:	f7ff fedc 	bl	4022a0 <__sinit>
  4024e8:	4b7c      	ldr	r3, [pc, #496]	; (4026dc <_vfiprintf_r+0x20c>)
  4024ea:	429c      	cmp	r4, r3
  4024ec:	d157      	bne.n	40259e <_vfiprintf_r+0xce>
  4024ee:	6874      	ldr	r4, [r6, #4]
  4024f0:	89a3      	ldrh	r3, [r4, #12]
  4024f2:	0718      	lsls	r0, r3, #28
  4024f4:	d55d      	bpl.n	4025b2 <_vfiprintf_r+0xe2>
  4024f6:	6923      	ldr	r3, [r4, #16]
  4024f8:	2b00      	cmp	r3, #0
  4024fa:	d05a      	beq.n	4025b2 <_vfiprintf_r+0xe2>
  4024fc:	2300      	movs	r3, #0
  4024fe:	9309      	str	r3, [sp, #36]	; 0x24
  402500:	2320      	movs	r3, #32
  402502:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  402506:	2330      	movs	r3, #48	; 0x30
  402508:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  40250c:	f04f 0b01 	mov.w	fp, #1
  402510:	46b8      	mov	r8, r7
  402512:	4645      	mov	r5, r8
  402514:	f815 3b01 	ldrb.w	r3, [r5], #1
  402518:	2b00      	cmp	r3, #0
  40251a:	d155      	bne.n	4025c8 <_vfiprintf_r+0xf8>
  40251c:	ebb8 0a07 	subs.w	sl, r8, r7
  402520:	d00b      	beq.n	40253a <_vfiprintf_r+0x6a>
  402522:	4653      	mov	r3, sl
  402524:	463a      	mov	r2, r7
  402526:	4621      	mov	r1, r4
  402528:	4630      	mov	r0, r6
  40252a:	f7ff ffbf 	bl	4024ac <__sfputs_r>
  40252e:	3001      	adds	r0, #1
  402530:	f000 80c4 	beq.w	4026bc <_vfiprintf_r+0x1ec>
  402534:	9b09      	ldr	r3, [sp, #36]	; 0x24
  402536:	4453      	add	r3, sl
  402538:	9309      	str	r3, [sp, #36]	; 0x24
  40253a:	f898 3000 	ldrb.w	r3, [r8]
  40253e:	2b00      	cmp	r3, #0
  402540:	f000 80bc 	beq.w	4026bc <_vfiprintf_r+0x1ec>
  402544:	2300      	movs	r3, #0
  402546:	f04f 32ff 	mov.w	r2, #4294967295
  40254a:	9304      	str	r3, [sp, #16]
  40254c:	9307      	str	r3, [sp, #28]
  40254e:	9205      	str	r2, [sp, #20]
  402550:	9306      	str	r3, [sp, #24]
  402552:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  402556:	931a      	str	r3, [sp, #104]	; 0x68
  402558:	2205      	movs	r2, #5
  40255a:	7829      	ldrb	r1, [r5, #0]
  40255c:	4860      	ldr	r0, [pc, #384]	; (4026e0 <_vfiprintf_r+0x210>)
  40255e:	f000 faff 	bl	402b60 <memchr>
  402562:	f105 0801 	add.w	r8, r5, #1
  402566:	9b04      	ldr	r3, [sp, #16]
  402568:	2800      	cmp	r0, #0
  40256a:	d131      	bne.n	4025d0 <_vfiprintf_r+0x100>
  40256c:	06d9      	lsls	r1, r3, #27
  40256e:	bf44      	itt	mi
  402570:	2220      	movmi	r2, #32
  402572:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  402576:	071a      	lsls	r2, r3, #28
  402578:	bf44      	itt	mi
  40257a:	222b      	movmi	r2, #43	; 0x2b
  40257c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  402580:	782a      	ldrb	r2, [r5, #0]
  402582:	2a2a      	cmp	r2, #42	; 0x2a
  402584:	d02c      	beq.n	4025e0 <_vfiprintf_r+0x110>
  402586:	9a07      	ldr	r2, [sp, #28]
  402588:	2100      	movs	r1, #0
  40258a:	200a      	movs	r0, #10
  40258c:	46a8      	mov	r8, r5
  40258e:	3501      	adds	r5, #1
  402590:	f898 3000 	ldrb.w	r3, [r8]
  402594:	3b30      	subs	r3, #48	; 0x30
  402596:	2b09      	cmp	r3, #9
  402598:	d96d      	bls.n	402676 <_vfiprintf_r+0x1a6>
  40259a:	b371      	cbz	r1, 4025fa <_vfiprintf_r+0x12a>
  40259c:	e026      	b.n	4025ec <_vfiprintf_r+0x11c>
  40259e:	4b51      	ldr	r3, [pc, #324]	; (4026e4 <_vfiprintf_r+0x214>)
  4025a0:	429c      	cmp	r4, r3
  4025a2:	d101      	bne.n	4025a8 <_vfiprintf_r+0xd8>
  4025a4:	68b4      	ldr	r4, [r6, #8]
  4025a6:	e7a3      	b.n	4024f0 <_vfiprintf_r+0x20>
  4025a8:	4b4f      	ldr	r3, [pc, #316]	; (4026e8 <_vfiprintf_r+0x218>)
  4025aa:	429c      	cmp	r4, r3
  4025ac:	bf08      	it	eq
  4025ae:	68f4      	ldreq	r4, [r6, #12]
  4025b0:	e79e      	b.n	4024f0 <_vfiprintf_r+0x20>
  4025b2:	4621      	mov	r1, r4
  4025b4:	4630      	mov	r0, r6
  4025b6:	f7ff fd13 	bl	401fe0 <__swsetup_r>
  4025ba:	2800      	cmp	r0, #0
  4025bc:	d09e      	beq.n	4024fc <_vfiprintf_r+0x2c>
  4025be:	f04f 30ff 	mov.w	r0, #4294967295
  4025c2:	b01d      	add	sp, #116	; 0x74
  4025c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4025c8:	2b25      	cmp	r3, #37	; 0x25
  4025ca:	d0a7      	beq.n	40251c <_vfiprintf_r+0x4c>
  4025cc:	46a8      	mov	r8, r5
  4025ce:	e7a0      	b.n	402512 <_vfiprintf_r+0x42>
  4025d0:	4a43      	ldr	r2, [pc, #268]	; (4026e0 <_vfiprintf_r+0x210>)
  4025d2:	1a80      	subs	r0, r0, r2
  4025d4:	fa0b f000 	lsl.w	r0, fp, r0
  4025d8:	4318      	orrs	r0, r3
  4025da:	9004      	str	r0, [sp, #16]
  4025dc:	4645      	mov	r5, r8
  4025de:	e7bb      	b.n	402558 <_vfiprintf_r+0x88>
  4025e0:	9a03      	ldr	r2, [sp, #12]
  4025e2:	1d11      	adds	r1, r2, #4
  4025e4:	6812      	ldr	r2, [r2, #0]
  4025e6:	9103      	str	r1, [sp, #12]
  4025e8:	2a00      	cmp	r2, #0
  4025ea:	db01      	blt.n	4025f0 <_vfiprintf_r+0x120>
  4025ec:	9207      	str	r2, [sp, #28]
  4025ee:	e004      	b.n	4025fa <_vfiprintf_r+0x12a>
  4025f0:	4252      	negs	r2, r2
  4025f2:	f043 0302 	orr.w	r3, r3, #2
  4025f6:	9207      	str	r2, [sp, #28]
  4025f8:	9304      	str	r3, [sp, #16]
  4025fa:	f898 3000 	ldrb.w	r3, [r8]
  4025fe:	2b2e      	cmp	r3, #46	; 0x2e
  402600:	d110      	bne.n	402624 <_vfiprintf_r+0x154>
  402602:	f898 3001 	ldrb.w	r3, [r8, #1]
  402606:	2b2a      	cmp	r3, #42	; 0x2a
  402608:	f108 0101 	add.w	r1, r8, #1
  40260c:	d137      	bne.n	40267e <_vfiprintf_r+0x1ae>
  40260e:	9b03      	ldr	r3, [sp, #12]
  402610:	1d1a      	adds	r2, r3, #4
  402612:	681b      	ldr	r3, [r3, #0]
  402614:	9203      	str	r2, [sp, #12]
  402616:	2b00      	cmp	r3, #0
  402618:	bfb8      	it	lt
  40261a:	f04f 33ff 	movlt.w	r3, #4294967295
  40261e:	f108 0802 	add.w	r8, r8, #2
  402622:	9305      	str	r3, [sp, #20]
  402624:	4d31      	ldr	r5, [pc, #196]	; (4026ec <_vfiprintf_r+0x21c>)
  402626:	f898 1000 	ldrb.w	r1, [r8]
  40262a:	2203      	movs	r2, #3
  40262c:	4628      	mov	r0, r5
  40262e:	f000 fa97 	bl	402b60 <memchr>
  402632:	b140      	cbz	r0, 402646 <_vfiprintf_r+0x176>
  402634:	2340      	movs	r3, #64	; 0x40
  402636:	1b40      	subs	r0, r0, r5
  402638:	fa03 f000 	lsl.w	r0, r3, r0
  40263c:	9b04      	ldr	r3, [sp, #16]
  40263e:	4303      	orrs	r3, r0
  402640:	9304      	str	r3, [sp, #16]
  402642:	f108 0801 	add.w	r8, r8, #1
  402646:	f898 1000 	ldrb.w	r1, [r8]
  40264a:	4829      	ldr	r0, [pc, #164]	; (4026f0 <_vfiprintf_r+0x220>)
  40264c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  402650:	2206      	movs	r2, #6
  402652:	f108 0701 	add.w	r7, r8, #1
  402656:	f000 fa83 	bl	402b60 <memchr>
  40265a:	2800      	cmp	r0, #0
  40265c:	d034      	beq.n	4026c8 <_vfiprintf_r+0x1f8>
  40265e:	4b25      	ldr	r3, [pc, #148]	; (4026f4 <_vfiprintf_r+0x224>)
  402660:	bb03      	cbnz	r3, 4026a4 <_vfiprintf_r+0x1d4>
  402662:	9b03      	ldr	r3, [sp, #12]
  402664:	3307      	adds	r3, #7
  402666:	f023 0307 	bic.w	r3, r3, #7
  40266a:	3308      	adds	r3, #8
  40266c:	9303      	str	r3, [sp, #12]
  40266e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  402670:	444b      	add	r3, r9
  402672:	9309      	str	r3, [sp, #36]	; 0x24
  402674:	e74c      	b.n	402510 <_vfiprintf_r+0x40>
  402676:	fb00 3202 	mla	r2, r0, r2, r3
  40267a:	2101      	movs	r1, #1
  40267c:	e786      	b.n	40258c <_vfiprintf_r+0xbc>
  40267e:	2300      	movs	r3, #0
  402680:	9305      	str	r3, [sp, #20]
  402682:	4618      	mov	r0, r3
  402684:	250a      	movs	r5, #10
  402686:	4688      	mov	r8, r1
  402688:	3101      	adds	r1, #1
  40268a:	f898 2000 	ldrb.w	r2, [r8]
  40268e:	3a30      	subs	r2, #48	; 0x30
  402690:	2a09      	cmp	r2, #9
  402692:	d903      	bls.n	40269c <_vfiprintf_r+0x1cc>
  402694:	2b00      	cmp	r3, #0
  402696:	d0c5      	beq.n	402624 <_vfiprintf_r+0x154>
  402698:	9005      	str	r0, [sp, #20]
  40269a:	e7c3      	b.n	402624 <_vfiprintf_r+0x154>
  40269c:	fb05 2000 	mla	r0, r5, r0, r2
  4026a0:	2301      	movs	r3, #1
  4026a2:	e7f0      	b.n	402686 <_vfiprintf_r+0x1b6>
  4026a4:	ab03      	add	r3, sp, #12
  4026a6:	9300      	str	r3, [sp, #0]
  4026a8:	4622      	mov	r2, r4
  4026aa:	4b13      	ldr	r3, [pc, #76]	; (4026f8 <_vfiprintf_r+0x228>)
  4026ac:	a904      	add	r1, sp, #16
  4026ae:	4630      	mov	r0, r6
  4026b0:	f3af 8000 	nop.w
  4026b4:	f1b0 3fff 	cmp.w	r0, #4294967295
  4026b8:	4681      	mov	r9, r0
  4026ba:	d1d8      	bne.n	40266e <_vfiprintf_r+0x19e>
  4026bc:	89a3      	ldrh	r3, [r4, #12]
  4026be:	065b      	lsls	r3, r3, #25
  4026c0:	f53f af7d 	bmi.w	4025be <_vfiprintf_r+0xee>
  4026c4:	9809      	ldr	r0, [sp, #36]	; 0x24
  4026c6:	e77c      	b.n	4025c2 <_vfiprintf_r+0xf2>
  4026c8:	ab03      	add	r3, sp, #12
  4026ca:	9300      	str	r3, [sp, #0]
  4026cc:	4622      	mov	r2, r4
  4026ce:	4b0a      	ldr	r3, [pc, #40]	; (4026f8 <_vfiprintf_r+0x228>)
  4026d0:	a904      	add	r1, sp, #16
  4026d2:	4630      	mov	r0, r6
  4026d4:	f000 f888 	bl	4027e8 <_printf_i>
  4026d8:	e7ec      	b.n	4026b4 <_vfiprintf_r+0x1e4>
  4026da:	bf00      	nop
  4026dc:	00402e24 	.word	0x00402e24
  4026e0:	00402e64 	.word	0x00402e64
  4026e4:	00402e44 	.word	0x00402e44
  4026e8:	00402e04 	.word	0x00402e04
  4026ec:	00402e6a 	.word	0x00402e6a
  4026f0:	00402e6e 	.word	0x00402e6e
  4026f4:	00000000 	.word	0x00000000
  4026f8:	004024ad 	.word	0x004024ad

004026fc <_printf_common>:
  4026fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402700:	4691      	mov	r9, r2
  402702:	461f      	mov	r7, r3
  402704:	688a      	ldr	r2, [r1, #8]
  402706:	690b      	ldr	r3, [r1, #16]
  402708:	f8dd 8020 	ldr.w	r8, [sp, #32]
  40270c:	4293      	cmp	r3, r2
  40270e:	bfb8      	it	lt
  402710:	4613      	movlt	r3, r2
  402712:	f8c9 3000 	str.w	r3, [r9]
  402716:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  40271a:	4606      	mov	r6, r0
  40271c:	460c      	mov	r4, r1
  40271e:	b112      	cbz	r2, 402726 <_printf_common+0x2a>
  402720:	3301      	adds	r3, #1
  402722:	f8c9 3000 	str.w	r3, [r9]
  402726:	6823      	ldr	r3, [r4, #0]
  402728:	0699      	lsls	r1, r3, #26
  40272a:	bf42      	ittt	mi
  40272c:	f8d9 3000 	ldrmi.w	r3, [r9]
  402730:	3302      	addmi	r3, #2
  402732:	f8c9 3000 	strmi.w	r3, [r9]
  402736:	6825      	ldr	r5, [r4, #0]
  402738:	f015 0506 	ands.w	r5, r5, #6
  40273c:	d107      	bne.n	40274e <_printf_common+0x52>
  40273e:	f104 0a19 	add.w	sl, r4, #25
  402742:	68e3      	ldr	r3, [r4, #12]
  402744:	f8d9 2000 	ldr.w	r2, [r9]
  402748:	1a9b      	subs	r3, r3, r2
  40274a:	429d      	cmp	r5, r3
  40274c:	db29      	blt.n	4027a2 <_printf_common+0xa6>
  40274e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  402752:	6822      	ldr	r2, [r4, #0]
  402754:	3300      	adds	r3, #0
  402756:	bf18      	it	ne
  402758:	2301      	movne	r3, #1
  40275a:	0692      	lsls	r2, r2, #26
  40275c:	d42e      	bmi.n	4027bc <_printf_common+0xc0>
  40275e:	f104 0243 	add.w	r2, r4, #67	; 0x43
  402762:	4639      	mov	r1, r7
  402764:	4630      	mov	r0, r6
  402766:	47c0      	blx	r8
  402768:	3001      	adds	r0, #1
  40276a:	d021      	beq.n	4027b0 <_printf_common+0xb4>
  40276c:	6823      	ldr	r3, [r4, #0]
  40276e:	68e5      	ldr	r5, [r4, #12]
  402770:	f8d9 2000 	ldr.w	r2, [r9]
  402774:	f003 0306 	and.w	r3, r3, #6
  402778:	2b04      	cmp	r3, #4
  40277a:	bf08      	it	eq
  40277c:	1aad      	subeq	r5, r5, r2
  40277e:	68a3      	ldr	r3, [r4, #8]
  402780:	6922      	ldr	r2, [r4, #16]
  402782:	bf0c      	ite	eq
  402784:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  402788:	2500      	movne	r5, #0
  40278a:	4293      	cmp	r3, r2
  40278c:	bfc4      	itt	gt
  40278e:	1a9b      	subgt	r3, r3, r2
  402790:	18ed      	addgt	r5, r5, r3
  402792:	f04f 0900 	mov.w	r9, #0
  402796:	341a      	adds	r4, #26
  402798:	454d      	cmp	r5, r9
  40279a:	d11b      	bne.n	4027d4 <_printf_common+0xd8>
  40279c:	2000      	movs	r0, #0
  40279e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4027a2:	2301      	movs	r3, #1
  4027a4:	4652      	mov	r2, sl
  4027a6:	4639      	mov	r1, r7
  4027a8:	4630      	mov	r0, r6
  4027aa:	47c0      	blx	r8
  4027ac:	3001      	adds	r0, #1
  4027ae:	d103      	bne.n	4027b8 <_printf_common+0xbc>
  4027b0:	f04f 30ff 	mov.w	r0, #4294967295
  4027b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4027b8:	3501      	adds	r5, #1
  4027ba:	e7c2      	b.n	402742 <_printf_common+0x46>
  4027bc:	18e1      	adds	r1, r4, r3
  4027be:	1c5a      	adds	r2, r3, #1
  4027c0:	2030      	movs	r0, #48	; 0x30
  4027c2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  4027c6:	4422      	add	r2, r4
  4027c8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  4027cc:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  4027d0:	3302      	adds	r3, #2
  4027d2:	e7c4      	b.n	40275e <_printf_common+0x62>
  4027d4:	2301      	movs	r3, #1
  4027d6:	4622      	mov	r2, r4
  4027d8:	4639      	mov	r1, r7
  4027da:	4630      	mov	r0, r6
  4027dc:	47c0      	blx	r8
  4027de:	3001      	adds	r0, #1
  4027e0:	d0e6      	beq.n	4027b0 <_printf_common+0xb4>
  4027e2:	f109 0901 	add.w	r9, r9, #1
  4027e6:	e7d7      	b.n	402798 <_printf_common+0x9c>

004027e8 <_printf_i>:
  4027e8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4027ec:	4617      	mov	r7, r2
  4027ee:	7e0a      	ldrb	r2, [r1, #24]
  4027f0:	b085      	sub	sp, #20
  4027f2:	2a6e      	cmp	r2, #110	; 0x6e
  4027f4:	4698      	mov	r8, r3
  4027f6:	4606      	mov	r6, r0
  4027f8:	460c      	mov	r4, r1
  4027fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4027fc:	f101 0e43 	add.w	lr, r1, #67	; 0x43
  402800:	f000 80bc 	beq.w	40297c <_printf_i+0x194>
  402804:	d81a      	bhi.n	40283c <_printf_i+0x54>
  402806:	2a63      	cmp	r2, #99	; 0x63
  402808:	d02e      	beq.n	402868 <_printf_i+0x80>
  40280a:	d80a      	bhi.n	402822 <_printf_i+0x3a>
  40280c:	2a00      	cmp	r2, #0
  40280e:	f000 80c8 	beq.w	4029a2 <_printf_i+0x1ba>
  402812:	2a58      	cmp	r2, #88	; 0x58
  402814:	f000 808a 	beq.w	40292c <_printf_i+0x144>
  402818:	f104 0542 	add.w	r5, r4, #66	; 0x42
  40281c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  402820:	e02a      	b.n	402878 <_printf_i+0x90>
  402822:	2a64      	cmp	r2, #100	; 0x64
  402824:	d001      	beq.n	40282a <_printf_i+0x42>
  402826:	2a69      	cmp	r2, #105	; 0x69
  402828:	d1f6      	bne.n	402818 <_printf_i+0x30>
  40282a:	6821      	ldr	r1, [r4, #0]
  40282c:	681a      	ldr	r2, [r3, #0]
  40282e:	f011 0f80 	tst.w	r1, #128	; 0x80
  402832:	d023      	beq.n	40287c <_printf_i+0x94>
  402834:	1d11      	adds	r1, r2, #4
  402836:	6019      	str	r1, [r3, #0]
  402838:	6813      	ldr	r3, [r2, #0]
  40283a:	e027      	b.n	40288c <_printf_i+0xa4>
  40283c:	2a73      	cmp	r2, #115	; 0x73
  40283e:	f000 80b4 	beq.w	4029aa <_printf_i+0x1c2>
  402842:	d808      	bhi.n	402856 <_printf_i+0x6e>
  402844:	2a6f      	cmp	r2, #111	; 0x6f
  402846:	d02a      	beq.n	40289e <_printf_i+0xb6>
  402848:	2a70      	cmp	r2, #112	; 0x70
  40284a:	d1e5      	bne.n	402818 <_printf_i+0x30>
  40284c:	680a      	ldr	r2, [r1, #0]
  40284e:	f042 0220 	orr.w	r2, r2, #32
  402852:	600a      	str	r2, [r1, #0]
  402854:	e003      	b.n	40285e <_printf_i+0x76>
  402856:	2a75      	cmp	r2, #117	; 0x75
  402858:	d021      	beq.n	40289e <_printf_i+0xb6>
  40285a:	2a78      	cmp	r2, #120	; 0x78
  40285c:	d1dc      	bne.n	402818 <_printf_i+0x30>
  40285e:	2278      	movs	r2, #120	; 0x78
  402860:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
  402864:	496e      	ldr	r1, [pc, #440]	; (402a20 <_printf_i+0x238>)
  402866:	e064      	b.n	402932 <_printf_i+0x14a>
  402868:	681a      	ldr	r2, [r3, #0]
  40286a:	f101 0542 	add.w	r5, r1, #66	; 0x42
  40286e:	1d11      	adds	r1, r2, #4
  402870:	6019      	str	r1, [r3, #0]
  402872:	6813      	ldr	r3, [r2, #0]
  402874:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  402878:	2301      	movs	r3, #1
  40287a:	e0a3      	b.n	4029c4 <_printf_i+0x1dc>
  40287c:	f011 0f40 	tst.w	r1, #64	; 0x40
  402880:	f102 0104 	add.w	r1, r2, #4
  402884:	6019      	str	r1, [r3, #0]
  402886:	d0d7      	beq.n	402838 <_printf_i+0x50>
  402888:	f9b2 3000 	ldrsh.w	r3, [r2]
  40288c:	2b00      	cmp	r3, #0
  40288e:	da03      	bge.n	402898 <_printf_i+0xb0>
  402890:	222d      	movs	r2, #45	; 0x2d
  402892:	425b      	negs	r3, r3
  402894:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
  402898:	4962      	ldr	r1, [pc, #392]	; (402a24 <_printf_i+0x23c>)
  40289a:	220a      	movs	r2, #10
  40289c:	e017      	b.n	4028ce <_printf_i+0xe6>
  40289e:	6820      	ldr	r0, [r4, #0]
  4028a0:	6819      	ldr	r1, [r3, #0]
  4028a2:	f010 0f80 	tst.w	r0, #128	; 0x80
  4028a6:	d003      	beq.n	4028b0 <_printf_i+0xc8>
  4028a8:	1d08      	adds	r0, r1, #4
  4028aa:	6018      	str	r0, [r3, #0]
  4028ac:	680b      	ldr	r3, [r1, #0]
  4028ae:	e006      	b.n	4028be <_printf_i+0xd6>
  4028b0:	f010 0f40 	tst.w	r0, #64	; 0x40
  4028b4:	f101 0004 	add.w	r0, r1, #4
  4028b8:	6018      	str	r0, [r3, #0]
  4028ba:	d0f7      	beq.n	4028ac <_printf_i+0xc4>
  4028bc:	880b      	ldrh	r3, [r1, #0]
  4028be:	4959      	ldr	r1, [pc, #356]	; (402a24 <_printf_i+0x23c>)
  4028c0:	2a6f      	cmp	r2, #111	; 0x6f
  4028c2:	bf14      	ite	ne
  4028c4:	220a      	movne	r2, #10
  4028c6:	2208      	moveq	r2, #8
  4028c8:	2000      	movs	r0, #0
  4028ca:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  4028ce:	6865      	ldr	r5, [r4, #4]
  4028d0:	60a5      	str	r5, [r4, #8]
  4028d2:	2d00      	cmp	r5, #0
  4028d4:	f2c0 809c 	blt.w	402a10 <_printf_i+0x228>
  4028d8:	6820      	ldr	r0, [r4, #0]
  4028da:	f020 0004 	bic.w	r0, r0, #4
  4028de:	6020      	str	r0, [r4, #0]
  4028e0:	2b00      	cmp	r3, #0
  4028e2:	d13f      	bne.n	402964 <_printf_i+0x17c>
  4028e4:	2d00      	cmp	r5, #0
  4028e6:	f040 8095 	bne.w	402a14 <_printf_i+0x22c>
  4028ea:	4675      	mov	r5, lr
  4028ec:	2a08      	cmp	r2, #8
  4028ee:	d10b      	bne.n	402908 <_printf_i+0x120>
  4028f0:	6823      	ldr	r3, [r4, #0]
  4028f2:	07da      	lsls	r2, r3, #31
  4028f4:	d508      	bpl.n	402908 <_printf_i+0x120>
  4028f6:	6923      	ldr	r3, [r4, #16]
  4028f8:	6862      	ldr	r2, [r4, #4]
  4028fa:	429a      	cmp	r2, r3
  4028fc:	bfde      	ittt	le
  4028fe:	2330      	movle	r3, #48	; 0x30
  402900:	f805 3c01 	strble.w	r3, [r5, #-1]
  402904:	f105 35ff 	addle.w	r5, r5, #4294967295
  402908:	ebae 0305 	sub.w	r3, lr, r5
  40290c:	6123      	str	r3, [r4, #16]
  40290e:	f8cd 8000 	str.w	r8, [sp]
  402912:	463b      	mov	r3, r7
  402914:	aa03      	add	r2, sp, #12
  402916:	4621      	mov	r1, r4
  402918:	4630      	mov	r0, r6
  40291a:	f7ff feef 	bl	4026fc <_printf_common>
  40291e:	3001      	adds	r0, #1
  402920:	d155      	bne.n	4029ce <_printf_i+0x1e6>
  402922:	f04f 30ff 	mov.w	r0, #4294967295
  402926:	b005      	add	sp, #20
  402928:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40292c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
  402930:	493c      	ldr	r1, [pc, #240]	; (402a24 <_printf_i+0x23c>)
  402932:	6822      	ldr	r2, [r4, #0]
  402934:	6818      	ldr	r0, [r3, #0]
  402936:	f012 0f80 	tst.w	r2, #128	; 0x80
  40293a:	f100 0504 	add.w	r5, r0, #4
  40293e:	601d      	str	r5, [r3, #0]
  402940:	d001      	beq.n	402946 <_printf_i+0x15e>
  402942:	6803      	ldr	r3, [r0, #0]
  402944:	e002      	b.n	40294c <_printf_i+0x164>
  402946:	0655      	lsls	r5, r2, #25
  402948:	d5fb      	bpl.n	402942 <_printf_i+0x15a>
  40294a:	8803      	ldrh	r3, [r0, #0]
  40294c:	07d0      	lsls	r0, r2, #31
  40294e:	bf44      	itt	mi
  402950:	f042 0220 	orrmi.w	r2, r2, #32
  402954:	6022      	strmi	r2, [r4, #0]
  402956:	b91b      	cbnz	r3, 402960 <_printf_i+0x178>
  402958:	6822      	ldr	r2, [r4, #0]
  40295a:	f022 0220 	bic.w	r2, r2, #32
  40295e:	6022      	str	r2, [r4, #0]
  402960:	2210      	movs	r2, #16
  402962:	e7b1      	b.n	4028c8 <_printf_i+0xe0>
  402964:	4675      	mov	r5, lr
  402966:	fbb3 f0f2 	udiv	r0, r3, r2
  40296a:	fb02 3310 	mls	r3, r2, r0, r3
  40296e:	5ccb      	ldrb	r3, [r1, r3]
  402970:	f805 3d01 	strb.w	r3, [r5, #-1]!
  402974:	4603      	mov	r3, r0
  402976:	2800      	cmp	r0, #0
  402978:	d1f5      	bne.n	402966 <_printf_i+0x17e>
  40297a:	e7b7      	b.n	4028ec <_printf_i+0x104>
  40297c:	6808      	ldr	r0, [r1, #0]
  40297e:	681a      	ldr	r2, [r3, #0]
  402980:	6949      	ldr	r1, [r1, #20]
  402982:	f010 0f80 	tst.w	r0, #128	; 0x80
  402986:	d004      	beq.n	402992 <_printf_i+0x1aa>
  402988:	1d10      	adds	r0, r2, #4
  40298a:	6018      	str	r0, [r3, #0]
  40298c:	6813      	ldr	r3, [r2, #0]
  40298e:	6019      	str	r1, [r3, #0]
  402990:	e007      	b.n	4029a2 <_printf_i+0x1ba>
  402992:	f010 0f40 	tst.w	r0, #64	; 0x40
  402996:	f102 0004 	add.w	r0, r2, #4
  40299a:	6018      	str	r0, [r3, #0]
  40299c:	6813      	ldr	r3, [r2, #0]
  40299e:	d0f6      	beq.n	40298e <_printf_i+0x1a6>
  4029a0:	8019      	strh	r1, [r3, #0]
  4029a2:	2300      	movs	r3, #0
  4029a4:	6123      	str	r3, [r4, #16]
  4029a6:	4675      	mov	r5, lr
  4029a8:	e7b1      	b.n	40290e <_printf_i+0x126>
  4029aa:	681a      	ldr	r2, [r3, #0]
  4029ac:	1d11      	adds	r1, r2, #4
  4029ae:	6019      	str	r1, [r3, #0]
  4029b0:	6815      	ldr	r5, [r2, #0]
  4029b2:	6862      	ldr	r2, [r4, #4]
  4029b4:	2100      	movs	r1, #0
  4029b6:	4628      	mov	r0, r5
  4029b8:	f000 f8d2 	bl	402b60 <memchr>
  4029bc:	b108      	cbz	r0, 4029c2 <_printf_i+0x1da>
  4029be:	1b40      	subs	r0, r0, r5
  4029c0:	6060      	str	r0, [r4, #4]
  4029c2:	6863      	ldr	r3, [r4, #4]
  4029c4:	6123      	str	r3, [r4, #16]
  4029c6:	2300      	movs	r3, #0
  4029c8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  4029cc:	e79f      	b.n	40290e <_printf_i+0x126>
  4029ce:	6923      	ldr	r3, [r4, #16]
  4029d0:	462a      	mov	r2, r5
  4029d2:	4639      	mov	r1, r7
  4029d4:	4630      	mov	r0, r6
  4029d6:	47c0      	blx	r8
  4029d8:	3001      	adds	r0, #1
  4029da:	d0a2      	beq.n	402922 <_printf_i+0x13a>
  4029dc:	6823      	ldr	r3, [r4, #0]
  4029de:	079b      	lsls	r3, r3, #30
  4029e0:	d507      	bpl.n	4029f2 <_printf_i+0x20a>
  4029e2:	2500      	movs	r5, #0
  4029e4:	f104 0919 	add.w	r9, r4, #25
  4029e8:	68e3      	ldr	r3, [r4, #12]
  4029ea:	9a03      	ldr	r2, [sp, #12]
  4029ec:	1a9b      	subs	r3, r3, r2
  4029ee:	429d      	cmp	r5, r3
  4029f0:	db05      	blt.n	4029fe <_printf_i+0x216>
  4029f2:	68e0      	ldr	r0, [r4, #12]
  4029f4:	9b03      	ldr	r3, [sp, #12]
  4029f6:	4298      	cmp	r0, r3
  4029f8:	bfb8      	it	lt
  4029fa:	4618      	movlt	r0, r3
  4029fc:	e793      	b.n	402926 <_printf_i+0x13e>
  4029fe:	2301      	movs	r3, #1
  402a00:	464a      	mov	r2, r9
  402a02:	4639      	mov	r1, r7
  402a04:	4630      	mov	r0, r6
  402a06:	47c0      	blx	r8
  402a08:	3001      	adds	r0, #1
  402a0a:	d08a      	beq.n	402922 <_printf_i+0x13a>
  402a0c:	3501      	adds	r5, #1
  402a0e:	e7eb      	b.n	4029e8 <_printf_i+0x200>
  402a10:	2b00      	cmp	r3, #0
  402a12:	d1a7      	bne.n	402964 <_printf_i+0x17c>
  402a14:	780b      	ldrb	r3, [r1, #0]
  402a16:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  402a1a:	f104 0542 	add.w	r5, r4, #66	; 0x42
  402a1e:	e765      	b.n	4028ec <_printf_i+0x104>
  402a20:	00402e86 	.word	0x00402e86
  402a24:	00402e75 	.word	0x00402e75

00402a28 <__sread>:
  402a28:	b510      	push	{r4, lr}
  402a2a:	460c      	mov	r4, r1
  402a2c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402a30:	f000 f8e6 	bl	402c00 <_read_r>
  402a34:	2800      	cmp	r0, #0
  402a36:	bfab      	itete	ge
  402a38:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  402a3a:	89a3      	ldrhlt	r3, [r4, #12]
  402a3c:	181b      	addge	r3, r3, r0
  402a3e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  402a42:	bfac      	ite	ge
  402a44:	6563      	strge	r3, [r4, #84]	; 0x54
  402a46:	81a3      	strhlt	r3, [r4, #12]
  402a48:	bd10      	pop	{r4, pc}

00402a4a <__swrite>:
  402a4a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402a4e:	461f      	mov	r7, r3
  402a50:	898b      	ldrh	r3, [r1, #12]
  402a52:	05db      	lsls	r3, r3, #23
  402a54:	4605      	mov	r5, r0
  402a56:	460c      	mov	r4, r1
  402a58:	4616      	mov	r6, r2
  402a5a:	d505      	bpl.n	402a68 <__swrite+0x1e>
  402a5c:	2302      	movs	r3, #2
  402a5e:	2200      	movs	r2, #0
  402a60:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402a64:	f000 f868 	bl	402b38 <_lseek_r>
  402a68:	89a3      	ldrh	r3, [r4, #12]
  402a6a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  402a6e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  402a72:	81a3      	strh	r3, [r4, #12]
  402a74:	4632      	mov	r2, r6
  402a76:	463b      	mov	r3, r7
  402a78:	4628      	mov	r0, r5
  402a7a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  402a7e:	f000 b817 	b.w	402ab0 <_write_r>

00402a82 <__sseek>:
  402a82:	b510      	push	{r4, lr}
  402a84:	460c      	mov	r4, r1
  402a86:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402a8a:	f000 f855 	bl	402b38 <_lseek_r>
  402a8e:	1c43      	adds	r3, r0, #1
  402a90:	89a3      	ldrh	r3, [r4, #12]
  402a92:	bf15      	itete	ne
  402a94:	6560      	strne	r0, [r4, #84]	; 0x54
  402a96:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  402a9a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  402a9e:	81a3      	strheq	r3, [r4, #12]
  402aa0:	bf18      	it	ne
  402aa2:	81a3      	strhne	r3, [r4, #12]
  402aa4:	bd10      	pop	{r4, pc}

00402aa6 <__sclose>:
  402aa6:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402aaa:	f000 b813 	b.w	402ad4 <_close_r>
	...

00402ab0 <_write_r>:
  402ab0:	b538      	push	{r3, r4, r5, lr}
  402ab2:	4c07      	ldr	r4, [pc, #28]	; (402ad0 <_write_r+0x20>)
  402ab4:	4605      	mov	r5, r0
  402ab6:	4608      	mov	r0, r1
  402ab8:	4611      	mov	r1, r2
  402aba:	2200      	movs	r2, #0
  402abc:	6022      	str	r2, [r4, #0]
  402abe:	461a      	mov	r2, r3
  402ac0:	f7fe ffbc 	bl	401a3c <_write>
  402ac4:	1c43      	adds	r3, r0, #1
  402ac6:	d102      	bne.n	402ace <_write_r+0x1e>
  402ac8:	6823      	ldr	r3, [r4, #0]
  402aca:	b103      	cbz	r3, 402ace <_write_r+0x1e>
  402acc:	602b      	str	r3, [r5, #0]
  402ace:	bd38      	pop	{r3, r4, r5, pc}
  402ad0:	20400120 	.word	0x20400120

00402ad4 <_close_r>:
  402ad4:	b538      	push	{r3, r4, r5, lr}
  402ad6:	4c06      	ldr	r4, [pc, #24]	; (402af0 <_close_r+0x1c>)
  402ad8:	2300      	movs	r3, #0
  402ada:	4605      	mov	r5, r0
  402adc:	4608      	mov	r0, r1
  402ade:	6023      	str	r3, [r4, #0]
  402ae0:	f7fe f838 	bl	400b54 <_close>
  402ae4:	1c43      	adds	r3, r0, #1
  402ae6:	d102      	bne.n	402aee <_close_r+0x1a>
  402ae8:	6823      	ldr	r3, [r4, #0]
  402aea:	b103      	cbz	r3, 402aee <_close_r+0x1a>
  402aec:	602b      	str	r3, [r5, #0]
  402aee:	bd38      	pop	{r3, r4, r5, pc}
  402af0:	20400120 	.word	0x20400120

00402af4 <_fstat_r>:
  402af4:	b538      	push	{r3, r4, r5, lr}
  402af6:	4c07      	ldr	r4, [pc, #28]	; (402b14 <_fstat_r+0x20>)
  402af8:	2300      	movs	r3, #0
  402afa:	4605      	mov	r5, r0
  402afc:	4608      	mov	r0, r1
  402afe:	4611      	mov	r1, r2
  402b00:	6023      	str	r3, [r4, #0]
  402b02:	f7fe f82a 	bl	400b5a <_fstat>
  402b06:	1c43      	adds	r3, r0, #1
  402b08:	d102      	bne.n	402b10 <_fstat_r+0x1c>
  402b0a:	6823      	ldr	r3, [r4, #0]
  402b0c:	b103      	cbz	r3, 402b10 <_fstat_r+0x1c>
  402b0e:	602b      	str	r3, [r5, #0]
  402b10:	bd38      	pop	{r3, r4, r5, pc}
  402b12:	bf00      	nop
  402b14:	20400120 	.word	0x20400120

00402b18 <_isatty_r>:
  402b18:	b538      	push	{r3, r4, r5, lr}
  402b1a:	4c06      	ldr	r4, [pc, #24]	; (402b34 <_isatty_r+0x1c>)
  402b1c:	2300      	movs	r3, #0
  402b1e:	4605      	mov	r5, r0
  402b20:	4608      	mov	r0, r1
  402b22:	6023      	str	r3, [r4, #0]
  402b24:	f7fe f81e 	bl	400b64 <_isatty>
  402b28:	1c43      	adds	r3, r0, #1
  402b2a:	d102      	bne.n	402b32 <_isatty_r+0x1a>
  402b2c:	6823      	ldr	r3, [r4, #0]
  402b2e:	b103      	cbz	r3, 402b32 <_isatty_r+0x1a>
  402b30:	602b      	str	r3, [r5, #0]
  402b32:	bd38      	pop	{r3, r4, r5, pc}
  402b34:	20400120 	.word	0x20400120

00402b38 <_lseek_r>:
  402b38:	b538      	push	{r3, r4, r5, lr}
  402b3a:	4c07      	ldr	r4, [pc, #28]	; (402b58 <_lseek_r+0x20>)
  402b3c:	4605      	mov	r5, r0
  402b3e:	4608      	mov	r0, r1
  402b40:	4611      	mov	r1, r2
  402b42:	2200      	movs	r2, #0
  402b44:	6022      	str	r2, [r4, #0]
  402b46:	461a      	mov	r2, r3
  402b48:	f7fe f80e 	bl	400b68 <_lseek>
  402b4c:	1c43      	adds	r3, r0, #1
  402b4e:	d102      	bne.n	402b56 <_lseek_r+0x1e>
  402b50:	6823      	ldr	r3, [r4, #0]
  402b52:	b103      	cbz	r3, 402b56 <_lseek_r+0x1e>
  402b54:	602b      	str	r3, [r5, #0]
  402b56:	bd38      	pop	{r3, r4, r5, pc}
  402b58:	20400120 	.word	0x20400120
  402b5c:	00000000 	.word	0x00000000

00402b60 <memchr>:
  402b60:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  402b64:	2a10      	cmp	r2, #16
  402b66:	db2b      	blt.n	402bc0 <memchr+0x60>
  402b68:	f010 0f07 	tst.w	r0, #7
  402b6c:	d008      	beq.n	402b80 <memchr+0x20>
  402b6e:	f810 3b01 	ldrb.w	r3, [r0], #1
  402b72:	3a01      	subs	r2, #1
  402b74:	428b      	cmp	r3, r1
  402b76:	d02d      	beq.n	402bd4 <memchr+0x74>
  402b78:	f010 0f07 	tst.w	r0, #7
  402b7c:	b342      	cbz	r2, 402bd0 <memchr+0x70>
  402b7e:	d1f6      	bne.n	402b6e <memchr+0xe>
  402b80:	b4f0      	push	{r4, r5, r6, r7}
  402b82:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  402b86:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  402b8a:	f022 0407 	bic.w	r4, r2, #7
  402b8e:	f07f 0700 	mvns.w	r7, #0
  402b92:	2300      	movs	r3, #0
  402b94:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  402b98:	3c08      	subs	r4, #8
  402b9a:	ea85 0501 	eor.w	r5, r5, r1
  402b9e:	ea86 0601 	eor.w	r6, r6, r1
  402ba2:	fa85 f547 	uadd8	r5, r5, r7
  402ba6:	faa3 f587 	sel	r5, r3, r7
  402baa:	fa86 f647 	uadd8	r6, r6, r7
  402bae:	faa5 f687 	sel	r6, r5, r7
  402bb2:	b98e      	cbnz	r6, 402bd8 <memchr+0x78>
  402bb4:	d1ee      	bne.n	402b94 <memchr+0x34>
  402bb6:	bcf0      	pop	{r4, r5, r6, r7}
  402bb8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  402bbc:	f002 0207 	and.w	r2, r2, #7
  402bc0:	b132      	cbz	r2, 402bd0 <memchr+0x70>
  402bc2:	f810 3b01 	ldrb.w	r3, [r0], #1
  402bc6:	3a01      	subs	r2, #1
  402bc8:	ea83 0301 	eor.w	r3, r3, r1
  402bcc:	b113      	cbz	r3, 402bd4 <memchr+0x74>
  402bce:	d1f8      	bne.n	402bc2 <memchr+0x62>
  402bd0:	2000      	movs	r0, #0
  402bd2:	4770      	bx	lr
  402bd4:	3801      	subs	r0, #1
  402bd6:	4770      	bx	lr
  402bd8:	2d00      	cmp	r5, #0
  402bda:	bf06      	itte	eq
  402bdc:	4635      	moveq	r5, r6
  402bde:	3803      	subeq	r0, #3
  402be0:	3807      	subne	r0, #7
  402be2:	f015 0f01 	tst.w	r5, #1
  402be6:	d107      	bne.n	402bf8 <memchr+0x98>
  402be8:	3001      	adds	r0, #1
  402bea:	f415 7f80 	tst.w	r5, #256	; 0x100
  402bee:	bf02      	ittt	eq
  402bf0:	3001      	addeq	r0, #1
  402bf2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  402bf6:	3001      	addeq	r0, #1
  402bf8:	bcf0      	pop	{r4, r5, r6, r7}
  402bfa:	3801      	subs	r0, #1
  402bfc:	4770      	bx	lr
  402bfe:	bf00      	nop

00402c00 <_read_r>:
  402c00:	b538      	push	{r3, r4, r5, lr}
  402c02:	4c07      	ldr	r4, [pc, #28]	; (402c20 <_read_r+0x20>)
  402c04:	4605      	mov	r5, r0
  402c06:	4608      	mov	r0, r1
  402c08:	4611      	mov	r1, r2
  402c0a:	2200      	movs	r2, #0
  402c0c:	6022      	str	r2, [r4, #0]
  402c0e:	461a      	mov	r2, r3
  402c10:	f7fe ff02 	bl	401a18 <_read>
  402c14:	1c43      	adds	r3, r0, #1
  402c16:	d102      	bne.n	402c1e <_read_r+0x1e>
  402c18:	6823      	ldr	r3, [r4, #0]
  402c1a:	b103      	cbz	r3, 402c1e <_read_r+0x1e>
  402c1c:	602b      	str	r3, [r5, #0]
  402c1e:	bd38      	pop	{r3, r4, r5, pc}
  402c20:	20400120 	.word	0x20400120
  402c24:	682f2e2e 	.word	0x682f2e2e
  402c28:	732f6c61 	.word	0x732f6c61
  402c2c:	682f6372 	.word	0x682f6372
  402c30:	695f6c61 	.word	0x695f6c61
  402c34:	6d5f6332 	.word	0x6d5f6332
  402c38:	6e79735f 	.word	0x6e79735f
  402c3c:	00632e63 	.word	0x00632e63
  402c40:	682f2e2e 	.word	0x682f2e2e
  402c44:	732f6c61 	.word	0x732f6c61
  402c48:	682f6372 	.word	0x682f6372
  402c4c:	695f6c61 	.word	0x695f6c61
  402c50:	00632e6f 	.word	0x00632e6f
  402c54:	682f2e2e 	.word	0x682f2e2e
  402c58:	732f6c61 	.word	0x732f6c61
  402c5c:	682f6372 	.word	0x682f6372
  402c60:	705f6c61 	.word	0x705f6c61
  402c64:	632e6d77 	.word	0x632e6d77
  402c68:	00000000 	.word	0x00000000
  402c6c:	682f2e2e 	.word	0x682f2e2e
  402c70:	732f6c61 	.word	0x732f6c61
  402c74:	682f6372 	.word	0x682f6372
  402c78:	735f6c61 	.word	0x735f6c61
  402c7c:	6d5f6970 	.word	0x6d5f6970
  402c80:	6e79735f 	.word	0x6e79735f
  402c84:	00632e63 	.word	0x00632e63
  402c88:	682f2e2e 	.word	0x682f2e2e
  402c8c:	732f6c61 	.word	0x732f6c61
  402c90:	682f6372 	.word	0x682f6372
  402c94:	755f6c61 	.word	0x755f6c61
  402c98:	74726173 	.word	0x74726173
  402c9c:	6e79735f 	.word	0x6e79735f
  402ca0:	00632e63 	.word	0x00632e63

00402ca4 <_ext_irq>:
  402ca4:	00000000 00000020 00000020 00000020     .... ... ... ...
	...
  402cbc:	00000020 00000001 00000002 00000002      ...............
  402ccc:	00000002 00000000 00000000 00000002     ................

00402cdc <_pio_irq_n>:
  402cdc:	100c0b0a 00000011 682f2e2e 702f6c70     ........../hpl/p
  402cec:	682f6f69 705f6c70 655f6f69 632e7478     io/hpl_pio_ext.c
  402cfc:	00000000                                ....

00402d00 <_pwms>:
  402d00:	40020000 0000001f 00010001 00000001     ...@............
  402d10:	00000001 000000ff 00000000 00000004     ................
	...
  402d2c:	00000001 00402d3c 00000000 204000a0     ....<-@.......@ 

00402d3c <_ch_cfg0>:
  402d3c:	00000000 0000020a 00000400 00000200     ................
  402d4c:	682f2e2e 702f6c70 682f6d77 705f6c70     ../hpl/pwm/hpl_p
  402d5c:	632e6d77 00000000                       wm.c....

00402d64 <spi_regs>:
  402d64:	00000000 80000000 00000001 0496fa02     ................
  402d74:	0000ffff 682f2e2e 732f6c70 682f6970     ....../hpl/spi/h
  402d84:	735f6c70 632e6970 00000000              pl_spi.c....

00402d90 <_i2cm_sync_cfgs>:
  402d90:	40018000 00000020 00000000 00000000     ...@ ...........
  402da0:	0002baba 000249f0 682f2e2e 742f6c70     .....I..../hpl/t
  402db0:	73686977 6c70682f 6977745f 632e7368     wihs/hpl_twihs.c
  402dc0:	00000000                                ....

00402dc4 <_usarts>:
  402dc4:	00000001 001008c0 000100f4 682f2e2e     ............../h
  402dd4:	752f6c70 74726173 6c70682f 6173755f     pl/usart/hpl_usa
  402de4:	632e7472 00000000 bbccddee 000000aa     rt.c............
  402df4:	78323025 00000020 0000000d              %02x .......

00402e00 <_global_impure_ptr>:
  402e00:	20400004                                ..@ 

00402e04 <__sf_fake_stderr>:
	...

00402e24 <__sf_fake_stdin>:
	...

00402e44 <__sf_fake_stdout>:
	...
  402e64:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
  402e74:	32313000 36353433 41393837 45444342     .0123456789ABCDE
  402e84:	31300046 35343332 39383736 64636261     F.0123456789abcd
  402e94:	00006665                                ef..

00402e98 <_init>:
  402e98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402e9a:	bf00      	nop
  402e9c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402e9e:	bc08      	pop	{r3}
  402ea0:	469e      	mov	lr, r3
  402ea2:	4770      	bx	lr

00402ea4 <__init_array_start>:
  402ea4:	0040018d 	.word	0x0040018d

00402ea8 <_fini>:
  402ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402eaa:	bf00      	nop
  402eac:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402eae:	bc08      	pop	{r3}
  402eb0:	469e      	mov	lr, r3
  402eb2:	4770      	bx	lr

00402eb4 <__fini_array_start>:
  402eb4:	00400169 	.word	0x00400169
