
RobotFirmwarev12.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002da4  00400000  00400000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000064  20400000  00402da4  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000bc  20400064  00402e08  00020064  2**2
                  ALLOC
  3 .heap         00000200  20400120  00402ec4  00020064  2**0
                  ALLOC
  4 .stack        00000400  20400320  004030c4  00020064  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  00020064  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  00020092  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001bb15  00000000  00000000  000200eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003d1f  00000000  00000000  0003bc00  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00009da9  00000000  00000000  0003f91f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000bf0  00000000  00000000  000496c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000ac8  00000000  00000000  0004a2b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00043906  00000000  00000000  0004ad80  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   000188f5  00000000  00000000  0008e686  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00150e95  00000000  00000000  000a6f7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000025b8  00000000  00000000  001f7e10  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	20 07 40 20 ed 01 40 00 e9 01 40 00 e9 01 40 00      .@ ..@...@...@.
  400010:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
	...
  40002c:	e9 01 40 00 e9 01 40 00 00 00 00 00 e9 01 40 00     ..@...@.......@.
  40003c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40004c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40005c:	e9 01 40 00 e9 01 40 00 00 00 00 00 61 0d 40 00     ..@...@.....a.@.
  40006c:	55 0d 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     U.@...@...@...@.
  40007c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40008c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40009c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ac:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000bc:	99 0e 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000cc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000dc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000ec:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  4000fc:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40010c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 00 00 00 00     ..@...@...@.....
  40011c:	00 00 00 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ......@...@...@.
  40012c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40013c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40014c:	e9 01 40 00 e9 01 40 00 e9 01 40 00 e9 01 40 00     ..@...@...@...@.
  40015c:	e9 01 40 00 e9 01 40 00 e9 01 40 00                 ..@...@...@.

00400168 <__do_global_dtors_aux>:
  400168:	b510      	push	{r4, lr}
  40016a:	4c05      	ldr	r4, [pc, #20]	; (400180 <__do_global_dtors_aux+0x18>)
  40016c:	7823      	ldrb	r3, [r4, #0]
  40016e:	b933      	cbnz	r3, 40017e <__do_global_dtors_aux+0x16>
  400170:	4b04      	ldr	r3, [pc, #16]	; (400184 <__do_global_dtors_aux+0x1c>)
  400172:	b113      	cbz	r3, 40017a <__do_global_dtors_aux+0x12>
  400174:	4804      	ldr	r0, [pc, #16]	; (400188 <__do_global_dtors_aux+0x20>)
  400176:	f3af 8000 	nop.w
  40017a:	2301      	movs	r3, #1
  40017c:	7023      	strb	r3, [r4, #0]
  40017e:	bd10      	pop	{r4, pc}
  400180:	20400064 	.word	0x20400064
  400184:	00000000 	.word	0x00000000
  400188:	00402da4 	.word	0x00402da4

0040018c <frame_dummy>:
  40018c:	4b0c      	ldr	r3, [pc, #48]	; (4001c0 <frame_dummy+0x34>)
  40018e:	b143      	cbz	r3, 4001a2 <frame_dummy+0x16>
  400190:	480c      	ldr	r0, [pc, #48]	; (4001c4 <frame_dummy+0x38>)
  400192:	490d      	ldr	r1, [pc, #52]	; (4001c8 <frame_dummy+0x3c>)
  400194:	b510      	push	{r4, lr}
  400196:	f3af 8000 	nop.w
  40019a:	480c      	ldr	r0, [pc, #48]	; (4001cc <frame_dummy+0x40>)
  40019c:	6803      	ldr	r3, [r0, #0]
  40019e:	b923      	cbnz	r3, 4001aa <frame_dummy+0x1e>
  4001a0:	bd10      	pop	{r4, pc}
  4001a2:	480a      	ldr	r0, [pc, #40]	; (4001cc <frame_dummy+0x40>)
  4001a4:	6803      	ldr	r3, [r0, #0]
  4001a6:	b933      	cbnz	r3, 4001b6 <frame_dummy+0x2a>
  4001a8:	4770      	bx	lr
  4001aa:	4b09      	ldr	r3, [pc, #36]	; (4001d0 <frame_dummy+0x44>)
  4001ac:	2b00      	cmp	r3, #0
  4001ae:	d0f7      	beq.n	4001a0 <frame_dummy+0x14>
  4001b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  4001b4:	4718      	bx	r3
  4001b6:	4b06      	ldr	r3, [pc, #24]	; (4001d0 <frame_dummy+0x44>)
  4001b8:	2b00      	cmp	r3, #0
  4001ba:	d0f5      	beq.n	4001a8 <frame_dummy+0x1c>
  4001bc:	4718      	bx	r3
  4001be:	bf00      	nop
  4001c0:	00000000 	.word	0x00000000
  4001c4:	00402da4 	.word	0x00402da4
  4001c8:	20400068 	.word	0x20400068
  4001cc:	00402da4 	.word	0x00402da4
  4001d0:	00000000 	.word	0x00000000

004001d4 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
  4001d4:	b508      	push	{r3, lr}
	system_init();
  4001d6:	4b02      	ldr	r3, [pc, #8]	; (4001e0 <atmel_start_init+0xc>)
  4001d8:	4798      	blx	r3
	stdio_redirect_init();
  4001da:	4b02      	ldr	r3, [pc, #8]	; (4001e4 <atmel_start_init+0x10>)
  4001dc:	4798      	blx	r3
  4001de:	bd08      	pop	{r3, pc}
  4001e0:	004004a9 	.word	0x004004a9
  4001e4:	00401a91 	.word	0x00401a91

004001e8 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4001e8:	e7fe      	b.n	4001e8 <Dummy_Handler>
	...

004001ec <Reset_Handler>:
{
  4001ec:	b508      	push	{r3, lr}
        if (pSrc != pDest) {
  4001ee:	4b10      	ldr	r3, [pc, #64]	; (400230 <Reset_Handler+0x44>)
  4001f0:	4a10      	ldr	r2, [pc, #64]	; (400234 <Reset_Handler+0x48>)
  4001f2:	429a      	cmp	r2, r3
  4001f4:	d009      	beq.n	40020a <Reset_Handler+0x1e>
  4001f6:	4b0e      	ldr	r3, [pc, #56]	; (400230 <Reset_Handler+0x44>)
  4001f8:	4a0e      	ldr	r2, [pc, #56]	; (400234 <Reset_Handler+0x48>)
  4001fa:	e003      	b.n	400204 <Reset_Handler+0x18>
                        *pDest++ = *pSrc++;
  4001fc:	6811      	ldr	r1, [r2, #0]
  4001fe:	6019      	str	r1, [r3, #0]
  400200:	3304      	adds	r3, #4
  400202:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
  400204:	490c      	ldr	r1, [pc, #48]	; (400238 <Reset_Handler+0x4c>)
  400206:	428b      	cmp	r3, r1
  400208:	d3f8      	bcc.n	4001fc <Reset_Handler+0x10>
                        *pDest++ = *pSrc++;
  40020a:	4b0c      	ldr	r3, [pc, #48]	; (40023c <Reset_Handler+0x50>)
  40020c:	e002      	b.n	400214 <Reset_Handler+0x28>
                *pDest++ = 0;
  40020e:	2200      	movs	r2, #0
  400210:	601a      	str	r2, [r3, #0]
  400212:	3304      	adds	r3, #4
        for (pDest = &_szero; pDest < &_ezero;) {
  400214:	4a0a      	ldr	r2, [pc, #40]	; (400240 <Reset_Handler+0x54>)
  400216:	4293      	cmp	r3, r2
  400218:	d3f9      	bcc.n	40020e <Reset_Handler+0x22>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  40021a:	4a0a      	ldr	r2, [pc, #40]	; (400244 <Reset_Handler+0x58>)
  40021c:	4b0a      	ldr	r3, [pc, #40]	; (400248 <Reset_Handler+0x5c>)
  40021e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  400222:	6093      	str	r3, [r2, #8]
        __libc_init_array();
  400224:	4b09      	ldr	r3, [pc, #36]	; (40024c <Reset_Handler+0x60>)
  400226:	4798      	blx	r3
        main();
  400228:	4b09      	ldr	r3, [pc, #36]	; (400250 <Reset_Handler+0x64>)
  40022a:	4798      	blx	r3
  40022c:	e7fe      	b.n	40022c <Reset_Handler+0x40>
  40022e:	bf00      	nop
  400230:	20400000 	.word	0x20400000
  400234:	00402da4 	.word	0x00402da4
  400238:	20400064 	.word	0x20400064
  40023c:	20400064 	.word	0x20400064
  400240:	20400120 	.word	0x20400120
  400244:	e000ed00 	.word	0xe000ed00
  400248:	00400000 	.word	0x00400000
  40024c:	00401ab1 	.word	0x00401ab1
  400250:	004016f1 	.word	0x004016f1

00400254 <EXTERNAL_IRQ_1_init>:
	((Pio *)hw)->PIO_ODR = ~data;
}

static inline void hri_pio_clear_OSR_reg(const void *const hw, hri_pio_osr_reg_t mask)
{
	((Pio *)hw)->PIO_ODR = mask;
  400254:	4b03      	ldr	r3, [pc, #12]	; (400264 <EXTERNAL_IRQ_1_init+0x10>)
  400256:	2202      	movs	r2, #2
  400258:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = ~data;
}

static inline void hri_pio_clear_PUSR_reg(const void *const hw, hri_pio_pusr_reg_t mask)
{
	((Pio *)hw)->PIO_PUDR = mask;
  40025a:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = ~data;
}

static inline void hri_pio_clear_PPDSR_reg(const void *const hw, hri_pio_ppdsr_reg_t mask)
{
	((Pio *)hw)->PIO_PPDDR = mask;
  40025c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400260:	601a      	str	r2, [r3, #0]
  400262:	4770      	bx	lr
  400264:	400e1000 	.word	0x400e1000

00400268 <EXTERNAL_IRQ_0_init>:
	((Pio *)hw)->PIO_ODR = mask;
  400268:	4b03      	ldr	r3, [pc, #12]	; (400278 <EXTERNAL_IRQ_0_init+0x10>)
  40026a:	2220      	movs	r2, #32
  40026c:	615a      	str	r2, [r3, #20]
	((Pio *)hw)->PIO_PUDR = mask;
  40026e:	661a      	str	r2, [r3, #96]	; 0x60
	((Pio *)hw)->PIO_PPDDR = mask;
  400270:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	((Pio *)hw)->PIO_PER = mask;
  400274:	601a      	str	r2, [r3, #0]
  400276:	4770      	bx	lr
  400278:	400e0e00 	.word	0x400e0e00

0040027c <PWM_0_PORT_init>:
}

static inline void hri_pio_set_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  40027c:	4b06      	ldr	r3, [pc, #24]	; (400298 <PWM_0_PORT_init+0x1c>)
  40027e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400280:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
  400284:	671a      	str	r2, [r3, #112]	; 0x70
}

static inline void hri_pio_clear_ABCDSR_reg(const void *const hw, uint8_t index, hri_pio_abcdsr_reg_t mask)
{
	PIO_CRITICAL_SECTION_ENTER();
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400286:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400288:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
  40028c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40028e:	f44f 6200 	mov.w	r2, #2048	; 0x800
  400292:	605a      	str	r2, [r3, #4]
  400294:	4770      	bx	lr
  400296:	bf00      	nop
  400298:	400e1400 	.word	0x400e1400

0040029c <PWM_0_CLOCK_init>:
}

static inline hri_pmc_pcsr0_reg_t hri_pmc_get_PCSR0_reg(const void *const hw, hri_pmc_pcsr0_reg_t mask)
{
	uint32_t tmp;
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40029c:	4b04      	ldr	r3, [pc, #16]	; (4002b0 <PWM_0_CLOCK_init+0x14>)
  40029e:	699b      	ldr	r3, [r3, #24]
 *
 */
static inline void _pmc_enable_periph_clock(uint32_t periph_id)
{
	if (periph_id < 32) {
		if (!hri_pmc_get_PCSR0_reg(PMC, (1 << periph_id))) {
  4002a0:	2b00      	cmp	r3, #0
  4002a2:	db03      	blt.n	4002ac <PWM_0_CLOCK_init+0x10>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4002a4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  4002a8:	4b01      	ldr	r3, [pc, #4]	; (4002b0 <PWM_0_CLOCK_init+0x14>)
  4002aa:	611a      	str	r2, [r3, #16]
  4002ac:	4770      	bx	lr
  4002ae:	bf00      	nop
  4002b0:	400e0600 	.word	0x400e0600

004002b4 <PWM_0_init>:
{
	_pmc_enable_periph_clock(ID_PWM0);
}

void PWM_0_init(void)
{
  4002b4:	b508      	push	{r3, lr}
	PWM_0_CLOCK_init();
  4002b6:	4b06      	ldr	r3, [pc, #24]	; (4002d0 <PWM_0_init+0x1c>)
  4002b8:	4798      	blx	r3
	PWM_0_PORT_init();
  4002ba:	4b06      	ldr	r3, [pc, #24]	; (4002d4 <PWM_0_init+0x20>)
  4002bc:	4798      	blx	r3
	pwm_init(&PWM_0, PWM0, _pwm_get_pwm());
  4002be:	4b06      	ldr	r3, [pc, #24]	; (4002d8 <PWM_0_init+0x24>)
  4002c0:	4798      	blx	r3
  4002c2:	4602      	mov	r2, r0
  4002c4:	4905      	ldr	r1, [pc, #20]	; (4002dc <PWM_0_init+0x28>)
  4002c6:	4806      	ldr	r0, [pc, #24]	; (4002e0 <PWM_0_init+0x2c>)
  4002c8:	4b06      	ldr	r3, [pc, #24]	; (4002e4 <PWM_0_init+0x30>)
  4002ca:	4798      	blx	r3
  4002cc:	bd08      	pop	{r3, pc}
  4002ce:	bf00      	nop
  4002d0:	0040029d 	.word	0x0040029d
  4002d4:	0040027d 	.word	0x0040027d
  4002d8:	00401059 	.word	0x00401059
  4002dc:	40020000 	.word	0x40020000
  4002e0:	204000b8 	.word	0x204000b8
  4002e4:	00400755 	.word	0x00400755

004002e8 <SPI_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  4002e8:	4b11      	ldr	r3, [pc, #68]	; (400330 <SPI_0_PORT_init+0x48>)
  4002ea:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4002ec:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  4002f0:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4002f2:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4002f4:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  4002f8:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4002fa:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  4002fe:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400300:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400302:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
  400306:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400308:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40030a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  40030e:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400310:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400314:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400316:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400318:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
  40031c:	671a      	str	r2, [r3, #112]	; 0x70
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40031e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400320:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
  400324:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400326:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  40032a:	605a      	str	r2, [r3, #4]
  40032c:	4770      	bx	lr
  40032e:	bf00      	nop
  400330:	400e1400 	.word	0x400e1400

00400334 <SPI_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  400334:	4b04      	ldr	r3, [pc, #16]	; (400348 <SPI_0_CLOCK_init+0x14>)
  400336:	699b      	ldr	r3, [r3, #24]
  400338:	f413 1f00 	tst.w	r3, #2097152	; 0x200000
  40033c:	d103      	bne.n	400346 <SPI_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  40033e:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400342:	4b01      	ldr	r3, [pc, #4]	; (400348 <SPI_0_CLOCK_init+0x14>)
  400344:	611a      	str	r2, [r3, #16]
  400346:	4770      	bx	lr
  400348:	400e0600 	.word	0x400e0600

0040034c <SPI_0_init>:
{
	_pmc_enable_periph_clock(ID_SPI0);
}

void SPI_0_init(void)
{
  40034c:	b510      	push	{r4, lr}
	SPI_0_CLOCK_init();
  40034e:	4b08      	ldr	r3, [pc, #32]	; (400370 <SPI_0_init+0x24>)
  400350:	4798      	blx	r3
	spi_m_sync_set_func_ptr(&SPI_0, _spi_get_spi_m_sync());
  400352:	4b08      	ldr	r3, [pc, #32]	; (400374 <SPI_0_init+0x28>)
  400354:	4798      	blx	r3
  400356:	4c08      	ldr	r4, [pc, #32]	; (400378 <SPI_0_init+0x2c>)
  400358:	4601      	mov	r1, r0
  40035a:	4620      	mov	r0, r4
  40035c:	4b07      	ldr	r3, [pc, #28]	; (40037c <SPI_0_init+0x30>)
  40035e:	4798      	blx	r3
	spi_m_sync_init(&SPI_0, SPI0);
  400360:	4907      	ldr	r1, [pc, #28]	; (400380 <SPI_0_init+0x34>)
  400362:	4620      	mov	r0, r4
  400364:	4b07      	ldr	r3, [pc, #28]	; (400384 <SPI_0_init+0x38>)
  400366:	4798      	blx	r3
	SPI_0_PORT_init();
  400368:	4b07      	ldr	r3, [pc, #28]	; (400388 <SPI_0_init+0x3c>)
  40036a:	4798      	blx	r3
  40036c:	bd10      	pop	{r4, pc}
  40036e:	bf00      	nop
  400370:	00400335 	.word	0x00400335
  400374:	00401259 	.word	0x00401259
  400378:	204000e0 	.word	0x204000e0
  40037c:	004007d5 	.word	0x004007d5
  400380:	40008000 	.word	0x40008000
  400384:	004007f5 	.word	0x004007f5
  400388:	004002e9 	.word	0x004002e9

0040038c <I2C_0_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  40038c:	4b0a      	ldr	r3, [pc, #40]	; (4003b8 <I2C_0_PORT_init+0x2c>)
  40038e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400390:	f022 0210 	bic.w	r2, r2, #16
  400394:	671a      	str	r2, [r3, #112]	; 0x70
  400396:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400398:	f022 0210 	bic.w	r2, r2, #16
  40039c:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  40039e:	2210      	movs	r2, #16
  4003a0:	605a      	str	r2, [r3, #4]
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  4003a2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4003a4:	f022 0208 	bic.w	r2, r2, #8
  4003a8:	671a      	str	r2, [r3, #112]	; 0x70
  4003aa:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4003ac:	f022 0208 	bic.w	r2, r2, #8
  4003b0:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  4003b2:	2208      	movs	r2, #8
  4003b4:	605a      	str	r2, [r3, #4]
  4003b6:	4770      	bx	lr
  4003b8:	400e0e00 	.word	0x400e0e00

004003bc <I2C_0_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4003bc:	4b04      	ldr	r3, [pc, #16]	; (4003d0 <I2C_0_CLOCK_init+0x14>)
  4003be:	699b      	ldr	r3, [r3, #24]
  4003c0:	f413 2f00 	tst.w	r3, #524288	; 0x80000
  4003c4:	d103      	bne.n	4003ce <I2C_0_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4003c6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  4003ca:	4b01      	ldr	r3, [pc, #4]	; (4003d0 <I2C_0_CLOCK_init+0x14>)
  4003cc:	611a      	str	r2, [r3, #16]
  4003ce:	4770      	bx	lr
  4003d0:	400e0600 	.word	0x400e0600

004003d4 <I2C_0_init>:
{
	_pmc_enable_periph_clock(ID_TWIHS0);
}

void I2C_0_init(void)
{
  4003d4:	b508      	push	{r3, lr}
	I2C_0_CLOCK_init();
  4003d6:	4b04      	ldr	r3, [pc, #16]	; (4003e8 <I2C_0_init+0x14>)
  4003d8:	4798      	blx	r3

	i2c_m_sync_init(&I2C_0, TWIHS0);
  4003da:	4904      	ldr	r1, [pc, #16]	; (4003ec <I2C_0_init+0x18>)
  4003dc:	4804      	ldr	r0, [pc, #16]	; (4003f0 <I2C_0_init+0x1c>)
  4003de:	4b05      	ldr	r3, [pc, #20]	; (4003f4 <I2C_0_init+0x20>)
  4003e0:	4798      	blx	r3

	I2C_0_PORT_init();
  4003e2:	4b05      	ldr	r3, [pc, #20]	; (4003f8 <I2C_0_init+0x24>)
  4003e4:	4798      	blx	r3
  4003e6:	bd08      	pop	{r3, pc}
  4003e8:	004003bd 	.word	0x004003bd
  4003ec:	40018000 	.word	0x40018000
  4003f0:	204000f8 	.word	0x204000f8
  4003f4:	004006a1 	.word	0x004006a1
  4003f8:	0040038d 	.word	0x0040038d

004003fc <delay_driver_init>:
}

void delay_driver_init(void)
{
  4003fc:	b508      	push	{r3, lr}
	delay_init(SysTick);
  4003fe:	4802      	ldr	r0, [pc, #8]	; (400408 <delay_driver_init+0xc>)
  400400:	4b02      	ldr	r3, [pc, #8]	; (40040c <delay_driver_init+0x10>)
  400402:	4798      	blx	r3
  400404:	bd08      	pop	{r3, pc}
  400406:	bf00      	nop
  400408:	e000e010 	.word	0xe000e010
  40040c:	00400595 	.word	0x00400595

00400410 <TARGET_IO_PORT_init>:
	((Pio *)hw)->PIO_ABCDSR[index] &= ~mask;
  400410:	4b0f      	ldr	r3, [pc, #60]	; (400450 <TARGET_IO_PORT_init+0x40>)
  400412:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  400414:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400418:	671a      	str	r2, [r3, #112]	; 0x70
  40041a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40041c:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  400420:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400422:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  400426:	605a      	str	r2, [r3, #4]
}

static inline void hri_matrix_set_CCFG_SYSIO_reg(const void *const hw, hri_matrix_ccfg_sysio_reg_t mask)
{
	MATRIX_CRITICAL_SECTION_ENTER();
	((Matrix *)hw)->CCFG_SYSIO |= mask;
  400428:	4a0a      	ldr	r2, [pc, #40]	; (400454 <TARGET_IO_PORT_init+0x44>)
  40042a:	f8d2 3114 	ldr.w	r3, [r2, #276]	; 0x114
  40042e:	f043 0310 	orr.w	r3, r3, #16
  400432:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
	((Pio *)hw)->PIO_ABCDSR[index] |= mask;
  400436:	4b08      	ldr	r3, [pc, #32]	; (400458 <TARGET_IO_PORT_init+0x48>)
  400438:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40043a:	f042 0210 	orr.w	r2, r2, #16
  40043e:	671a      	str	r2, [r3, #112]	; 0x70
  400440:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  400442:	f042 0210 	orr.w	r2, r2, #16
  400446:	675a      	str	r2, [r3, #116]	; 0x74
	((Pio *)hw)->PIO_PDR = mask;
  400448:	2210      	movs	r2, #16
  40044a:	605a      	str	r2, [r3, #4]
  40044c:	4770      	bx	lr
  40044e:	bf00      	nop
  400450:	400e0e00 	.word	0x400e0e00
  400454:	40088000 	.word	0x40088000
  400458:	400e1000 	.word	0x400e1000

0040045c <TARGET_IO_CLOCK_init>:
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  40045c:	4b04      	ldr	r3, [pc, #16]	; (400470 <TARGET_IO_CLOCK_init+0x14>)
  40045e:	699b      	ldr	r3, [r3, #24]
  400460:	f413 4f80 	tst.w	r3, #16384	; 0x4000
  400464:	d103      	bne.n	40046e <TARGET_IO_CLOCK_init+0x12>
	((Pmc *)hw)->PMC_PCER0 = mask;
  400466:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  40046a:	4b01      	ldr	r3, [pc, #4]	; (400470 <TARGET_IO_CLOCK_init+0x14>)
  40046c:	611a      	str	r2, [r3, #16]
  40046e:	4770      	bx	lr
  400470:	400e0600 	.word	0x400e0600

00400474 <TARGET_IO_init>:
{
	_pmc_enable_periph_clock(ID_USART1);
}

void TARGET_IO_init(void)
{
  400474:	b508      	push	{r3, lr}
	TARGET_IO_CLOCK_init();
  400476:	4b06      	ldr	r3, [pc, #24]	; (400490 <TARGET_IO_init+0x1c>)
  400478:	4798      	blx	r3
	TARGET_IO_PORT_init();
  40047a:	4b06      	ldr	r3, [pc, #24]	; (400494 <TARGET_IO_init+0x20>)
  40047c:	4798      	blx	r3
	usart_sync_init(&TARGET_IO, USART1, _usart_get_usart_sync());
  40047e:	4b06      	ldr	r3, [pc, #24]	; (400498 <TARGET_IO_init+0x24>)
  400480:	4798      	blx	r3
  400482:	4602      	mov	r2, r0
  400484:	4905      	ldr	r1, [pc, #20]	; (40049c <TARGET_IO_init+0x28>)
  400486:	4806      	ldr	r0, [pc, #24]	; (4004a0 <TARGET_IO_init+0x2c>)
  400488:	4b06      	ldr	r3, [pc, #24]	; (4004a4 <TARGET_IO_init+0x30>)
  40048a:	4798      	blx	r3
  40048c:	bd08      	pop	{r3, pc}
  40048e:	bf00      	nop
  400490:	0040045d 	.word	0x0040045d
  400494:	00400411 	.word	0x00400411
  400498:	004016b9 	.word	0x004016b9
  40049c:	40028000 	.word	0x40028000
  4004a0:	204000d4 	.word	0x204000d4
  4004a4:	00400a21 	.word	0x00400a21

004004a8 <system_init>:
}

void system_init(void)
{
  4004a8:	b508      	push	{r3, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
  4004aa:	4b27      	ldr	r3, [pc, #156]	; (400548 <system_init+0xa0>)
  4004ac:	4798      	blx	r3
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004ae:	4b27      	ldr	r3, [pc, #156]	; (40054c <system_init+0xa4>)
  4004b0:	699b      	ldr	r3, [r3, #24]
  4004b2:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4004b6:	d103      	bne.n	4004c0 <system_init+0x18>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004b8:	f44f 6280 	mov.w	r2, #1024	; 0x400
  4004bc:	4b23      	ldr	r3, [pc, #140]	; (40054c <system_init+0xa4>)
  4004be:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004c0:	4b22      	ldr	r3, [pc, #136]	; (40054c <system_init+0xa4>)
  4004c2:	699b      	ldr	r3, [r3, #24]
  4004c4:	f413 6f00 	tst.w	r3, #2048	; 0x800
  4004c8:	d103      	bne.n	4004d2 <system_init+0x2a>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004ca:	f44f 6200 	mov.w	r2, #2048	; 0x800
  4004ce:	4b1f      	ldr	r3, [pc, #124]	; (40054c <system_init+0xa4>)
  4004d0:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004d2:	4b1e      	ldr	r3, [pc, #120]	; (40054c <system_init+0xa4>)
  4004d4:	699b      	ldr	r3, [r3, #24]
  4004d6:	f413 5f80 	tst.w	r3, #4096	; 0x1000
  4004da:	d103      	bne.n	4004e4 <system_init+0x3c>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004dc:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  4004e0:	4b1a      	ldr	r3, [pc, #104]	; (40054c <system_init+0xa4>)
  4004e2:	611a      	str	r2, [r3, #16]
	tmp = ((Pmc *)hw)->PMC_PCSR0;
  4004e4:	4b19      	ldr	r3, [pc, #100]	; (40054c <system_init+0xa4>)
  4004e6:	699b      	ldr	r3, [r3, #24]
  4004e8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  4004ec:	d103      	bne.n	4004f6 <system_init+0x4e>
	((Pmc *)hw)->PMC_PCER0 = mask;
  4004ee:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  4004f2:	4b16      	ldr	r3, [pc, #88]	; (40054c <system_init+0xa4>)
  4004f4:	611a      	str	r2, [r3, #16]
}

static inline void hri_wdt_set_MR_WDDIS_bit(const void *const hw)
{
	WDT_CRITICAL_SECTION_ENTER();
	((Wdt *)hw)->WDT_MR |= WDT_MR_WDDIS;
  4004f6:	4a16      	ldr	r2, [pc, #88]	; (400550 <system_init+0xa8>)
  4004f8:	6853      	ldr	r3, [r2, #4]
  4004fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  4004fe:	6053      	str	r3, [r2, #4]
	((Pio *)hw)->PIO_SODR = mask;
  400500:	4b14      	ldr	r3, [pc, #80]	; (400554 <system_init+0xac>)
  400502:	2201      	movs	r2, #1
  400504:	631a      	str	r2, [r3, #48]	; 0x30
	((Pio *)hw)->PIO_OER = mask;
  400506:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400508:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  40050a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
  40050e:	f44f 7200 	mov.w	r2, #512	; 0x200
  400512:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400514:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400516:	601a      	str	r2, [r3, #0]
	((Pio *)hw)->PIO_CODR = mask;
  400518:	f503 7300 	add.w	r3, r3, #512	; 0x200
  40051c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  400520:	635a      	str	r2, [r3, #52]	; 0x34
	((Pio *)hw)->PIO_OER = mask;
  400522:	611a      	str	r2, [r3, #16]
	((Pio *)hw)->PIO_PER = mask;
  400524:	601a      	str	r2, [r3, #0]
	// Set pin direction to output
	gpio_set_pin_direction(RF24_CE, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(RF24_CE, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_1_init();
  400526:	4b0c      	ldr	r3, [pc, #48]	; (400558 <system_init+0xb0>)
  400528:	4798      	blx	r3
	EXTERNAL_IRQ_0_init();
  40052a:	4b0c      	ldr	r3, [pc, #48]	; (40055c <system_init+0xb4>)
  40052c:	4798      	blx	r3

	PWM_0_init();
  40052e:	4b0c      	ldr	r3, [pc, #48]	; (400560 <system_init+0xb8>)
  400530:	4798      	blx	r3

	SPI_0_init();
  400532:	4b0c      	ldr	r3, [pc, #48]	; (400564 <system_init+0xbc>)
  400534:	4798      	blx	r3

	I2C_0_init();
  400536:	4b0c      	ldr	r3, [pc, #48]	; (400568 <system_init+0xc0>)
  400538:	4798      	blx	r3

	delay_driver_init();
  40053a:	4b0c      	ldr	r3, [pc, #48]	; (40056c <system_init+0xc4>)
  40053c:	4798      	blx	r3

	TARGET_IO_init();
  40053e:	4b0c      	ldr	r3, [pc, #48]	; (400570 <system_init+0xc8>)
  400540:	4798      	blx	r3

	ext_irq_init();
  400542:	4b0c      	ldr	r3, [pc, #48]	; (400574 <system_init+0xcc>)
  400544:	4798      	blx	r3
  400546:	bd08      	pop	{r3, pc}
  400548:	00400ae5 	.word	0x00400ae5
  40054c:	400e0600 	.word	0x400e0600
  400550:	400e1850 	.word	0x400e1850
  400554:	400e0e00 	.word	0x400e0e00
  400558:	00400255 	.word	0x00400255
  40055c:	00400269 	.word	0x00400269
  400560:	004002b5 	.word	0x004002b5
  400564:	0040034d 	.word	0x0040034d
  400568:	004003d5 	.word	0x004003d5
  40056c:	004003fd 	.word	0x004003fd
  400570:	00400475 	.word	0x00400475
  400574:	0040060d 	.word	0x0040060d

00400578 <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  400578:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
  40057c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  40057e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  400580:	f3bf 8f5f 	dmb	sy
  400584:	4770      	bx	lr

00400586 <atomic_leave_critical>:
  400586:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
  40058a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
  40058c:	f383 8810 	msr	PRIMASK, r3
  400590:	4770      	bx	lr
	...

00400594 <delay_init>:

/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
  400594:	b508      	push	{r3, lr}
	_delay_init(hardware = hw);
  400596:	4b02      	ldr	r3, [pc, #8]	; (4005a0 <delay_init+0xc>)
  400598:	6018      	str	r0, [r3, #0]
  40059a:	4b02      	ldr	r3, [pc, #8]	; (4005a4 <delay_init+0x10>)
  40059c:	4798      	blx	r3
  40059e:	bd08      	pop	{r3, pc}
  4005a0:	20400080 	.word	0x20400080
  4005a4:	00401271 	.word	0x00401271

004005a8 <delay_us>:

/**
 * \brief Perform delay in us
 */
void delay_us(const uint16_t us)
{
  4005a8:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_us(us));
  4005aa:	4b04      	ldr	r3, [pc, #16]	; (4005bc <delay_us+0x14>)
  4005ac:	681c      	ldr	r4, [r3, #0]
  4005ae:	4b04      	ldr	r3, [pc, #16]	; (4005c0 <delay_us+0x18>)
  4005b0:	4798      	blx	r3
  4005b2:	4601      	mov	r1, r0
  4005b4:	4620      	mov	r0, r4
  4005b6:	4b03      	ldr	r3, [pc, #12]	; (4005c4 <delay_us+0x1c>)
  4005b8:	4798      	blx	r3
  4005ba:	bd10      	pop	{r4, pc}
  4005bc:	20400080 	.word	0x20400080
  4005c0:	00400ad9 	.word	0x00400ad9
  4005c4:	0040127d 	.word	0x0040127d

004005c8 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
  4005c8:	b538      	push	{r3, r4, r5, lr}
	uint8_t lower = 0, middle, upper = EXT_IRQ_AMOUNT;
  4005ca:	2502      	movs	r5, #2
  4005cc:	2400      	movs	r4, #0

	while (upper >= lower) {
  4005ce:	e007      	b.n	4005e0 <process_ext_irq+0x18>
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
			if (ext_irqs[middle].cb) {
  4005d0:	4a0d      	ldr	r2, [pc, #52]	; (400608 <process_ext_irq+0x40>)
  4005d2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
  4005d6:	b1b3      	cbz	r3, 400606 <process_ext_irq+0x3e>
				ext_irqs[middle].cb();
  4005d8:	4798      	blx	r3
  4005da:	bd38      	pop	{r3, r4, r5, pc}
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
		} else {
			upper = middle - 1;
  4005dc:	3a01      	subs	r2, #1
  4005de:	b2d5      	uxtb	r5, r2
	while (upper >= lower) {
  4005e0:	42ac      	cmp	r4, r5
  4005e2:	d810      	bhi.n	400606 <process_ext_irq+0x3e>
		middle = (upper + lower) >> 1;
  4005e4:	192b      	adds	r3, r5, r4
  4005e6:	105b      	asrs	r3, r3, #1
  4005e8:	b2da      	uxtb	r2, r3
		if (middle >= EXT_IRQ_AMOUNT) {
  4005ea:	2a01      	cmp	r2, #1
  4005ec:	d80b      	bhi.n	400606 <process_ext_irq+0x3e>
  4005ee:	4613      	mov	r3, r2
		if (ext_irqs[middle].pin == pin) {
  4005f0:	4905      	ldr	r1, [pc, #20]	; (400608 <process_ext_irq+0x40>)
  4005f2:	eb01 01c2 	add.w	r1, r1, r2, lsl #3
  4005f6:	6849      	ldr	r1, [r1, #4]
  4005f8:	4281      	cmp	r1, r0
  4005fa:	d0e9      	beq.n	4005d0 <process_ext_irq+0x8>
		if (ext_irqs[middle].pin < pin) {
  4005fc:	4281      	cmp	r1, r0
  4005fe:	d2ed      	bcs.n	4005dc <process_ext_irq+0x14>
			lower = middle + 1;
  400600:	3201      	adds	r2, #1
  400602:	b2d4      	uxtb	r4, r2
  400604:	e7ec      	b.n	4005e0 <process_ext_irq+0x18>
  400606:	bd38      	pop	{r3, r4, r5, pc}
  400608:	20400084 	.word	0x20400084

0040060c <ext_irq_init>:
{
  40060c:	b508      	push	{r3, lr}
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  40060e:	2300      	movs	r3, #0
  400610:	e00a      	b.n	400628 <ext_irq_init+0x1c>
		ext_irqs[i].pin = 0xFFFFFFFF;
  400612:	4a08      	ldr	r2, [pc, #32]	; (400634 <ext_irq_init+0x28>)
  400614:	eb02 01c3 	add.w	r1, r2, r3, lsl #3
  400618:	f04f 30ff 	mov.w	r0, #4294967295
  40061c:	6048      	str	r0, [r1, #4]
		ext_irqs[i].cb  = NULL;
  40061e:	2100      	movs	r1, #0
  400620:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
	for (i = 0; i < EXT_IRQ_AMOUNT; i++) {
  400624:	3301      	adds	r3, #1
  400626:	b29b      	uxth	r3, r3
  400628:	2b01      	cmp	r3, #1
  40062a:	d9f2      	bls.n	400612 <ext_irq_init+0x6>
	return _ext_irq_init(process_ext_irq);
  40062c:	4802      	ldr	r0, [pc, #8]	; (400638 <ext_irq_init+0x2c>)
  40062e:	4b03      	ldr	r3, [pc, #12]	; (40063c <ext_irq_init+0x30>)
  400630:	4798      	blx	r3
}
  400632:	bd08      	pop	{r3, pc}
  400634:	20400084 	.word	0x20400084
  400638:	004005c9 	.word	0x004005c9
  40063c:	00400d6d 	.word	0x00400d6d

00400640 <i2c_m_sync_write>:

/**
 * \brief Sync version of I2C I/O write
 */
static int32_t i2c_m_sync_write(struct io_descriptor *io, const uint8_t *buf, const uint16_t n)
{
  400640:	b510      	push	{r4, lr}
  400642:	b084      	sub	sp, #16
	struct i2c_m_sync_desc *i2c = CONTAINER_OF(io, struct i2c_m_sync_desc, io);
	struct _i2c_m_msg       msg;
	int32_t                 ret;

	msg.addr   = i2c->slave_addr;
  400644:	8903      	ldrh	r3, [r0, #8]
  400646:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  40064a:	4614      	mov	r4, r2
  40064c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP;
  40064e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400652:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
  400656:	9103      	str	r1, [sp, #12]

	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400658:	a901      	add	r1, sp, #4
  40065a:	3814      	subs	r0, #20
  40065c:	4b03      	ldr	r3, [pc, #12]	; (40066c <i2c_m_sync_write+0x2c>)
  40065e:	4798      	blx	r3

	if (ret) {
  400660:	b910      	cbnz	r0, 400668 <i2c_m_sync_write+0x28>
		return ret;
	}

	return n;
}
  400662:	4620      	mov	r0, r4
  400664:	b004      	add	sp, #16
  400666:	bd10      	pop	{r4, pc}
		return ret;
  400668:	4604      	mov	r4, r0
  40066a:	e7fa      	b.n	400662 <i2c_m_sync_write+0x22>
  40066c:	0040133d 	.word	0x0040133d

00400670 <i2c_m_sync_read>:
{
  400670:	b510      	push	{r4, lr}
  400672:	b084      	sub	sp, #16
	msg.addr   = i2c->slave_addr;
  400674:	8903      	ldrh	r3, [r0, #8]
  400676:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
  40067a:	4614      	mov	r4, r2
  40067c:	9202      	str	r2, [sp, #8]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
  40067e:	f248 0301 	movw	r3, #32769	; 0x8001
  400682:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
  400686:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_sync_transfer(&i2c->device, &msg);
  400688:	a901      	add	r1, sp, #4
  40068a:	3814      	subs	r0, #20
  40068c:	4b03      	ldr	r3, [pc, #12]	; (40069c <i2c_m_sync_read+0x2c>)
  40068e:	4798      	blx	r3
	if (ret) {
  400690:	b910      	cbnz	r0, 400698 <i2c_m_sync_read+0x28>
}
  400692:	4620      	mov	r0, r4
  400694:	b004      	add	sp, #16
  400696:	bd10      	pop	{r4, pc}
		return ret;
  400698:	4604      	mov	r4, r0
  40069a:	e7fa      	b.n	400692 <i2c_m_sync_read+0x22>
  40069c:	0040133d 	.word	0x0040133d

004006a0 <i2c_m_sync_init>:

/**
 * \brief Sync version of i2c initialize
 */
int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c, void *hw)
{
  4006a0:	b538      	push	{r3, r4, r5, lr}
  4006a2:	460d      	mov	r5, r1
	int32_t init_status;
	ASSERT(i2c);
  4006a4:	4604      	mov	r4, r0
  4006a6:	225e      	movs	r2, #94	; 0x5e
  4006a8:	4908      	ldr	r1, [pc, #32]	; (4006cc <i2c_m_sync_init+0x2c>)
  4006aa:	3000      	adds	r0, #0
  4006ac:	bf18      	it	ne
  4006ae:	2001      	movne	r0, #1
  4006b0:	4b07      	ldr	r3, [pc, #28]	; (4006d0 <i2c_m_sync_init+0x30>)
  4006b2:	4798      	blx	r3

	init_status = _i2c_m_sync_init(&i2c->device, hw);
  4006b4:	4629      	mov	r1, r5
  4006b6:	4620      	mov	r0, r4
  4006b8:	4b06      	ldr	r3, [pc, #24]	; (4006d4 <i2c_m_sync_init+0x34>)
  4006ba:	4798      	blx	r3
	if (init_status) {
  4006bc:	4603      	mov	r3, r0
  4006be:	b918      	cbnz	r0, 4006c8 <i2c_m_sync_init+0x28>
		return init_status;
	}

	/* Init I/O */
	i2c->io.read  = i2c_m_sync_read;
  4006c0:	4a05      	ldr	r2, [pc, #20]	; (4006d8 <i2c_m_sync_init+0x38>)
  4006c2:	61a2      	str	r2, [r4, #24]
	i2c->io.write = i2c_m_sync_write;
  4006c4:	4a05      	ldr	r2, [pc, #20]	; (4006dc <i2c_m_sync_init+0x3c>)
  4006c6:	6162      	str	r2, [r4, #20]

	return ERR_NONE;
}
  4006c8:	4618      	mov	r0, r3
  4006ca:	bd38      	pop	{r3, r4, r5, pc}
  4006cc:	00402b14 	.word	0x00402b14
  4006d0:	00400a95 	.word	0x00400a95
  4006d4:	004012f5 	.word	0x004012f5
  4006d8:	00400671 	.word	0x00400671
  4006dc:	00400641 	.word	0x00400641

004006e0 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  4006e0:	b570      	push	{r4, r5, r6, lr}
  4006e2:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  4006e4:	4604      	mov	r4, r0
  4006e6:	460d      	mov	r5, r1
  4006e8:	2800      	cmp	r0, #0
  4006ea:	bf18      	it	ne
  4006ec:	2900      	cmpne	r1, #0
  4006ee:	bf14      	ite	ne
  4006f0:	2001      	movne	r0, #1
  4006f2:	2000      	moveq	r0, #0
  4006f4:	2234      	movs	r2, #52	; 0x34
  4006f6:	4904      	ldr	r1, [pc, #16]	; (400708 <io_write+0x28>)
  4006f8:	4b04      	ldr	r3, [pc, #16]	; (40070c <io_write+0x2c>)
  4006fa:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
  4006fc:	6823      	ldr	r3, [r4, #0]
  4006fe:	4632      	mov	r2, r6
  400700:	4629      	mov	r1, r5
  400702:	4620      	mov	r0, r4
  400704:	4798      	blx	r3
}
  400706:	bd70      	pop	{r4, r5, r6, pc}
  400708:	00402b30 	.word	0x00402b30
  40070c:	00400a95 	.word	0x00400a95

00400710 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  400710:	b570      	push	{r4, r5, r6, lr}
  400712:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
  400714:	4604      	mov	r4, r0
  400716:	460d      	mov	r5, r1
  400718:	2800      	cmp	r0, #0
  40071a:	bf18      	it	ne
  40071c:	2900      	cmpne	r1, #0
  40071e:	bf14      	ite	ne
  400720:	2001      	movne	r0, #1
  400722:	2000      	moveq	r0, #0
  400724:	223d      	movs	r2, #61	; 0x3d
  400726:	4904      	ldr	r1, [pc, #16]	; (400738 <io_read+0x28>)
  400728:	4b04      	ldr	r3, [pc, #16]	; (40073c <io_read+0x2c>)
  40072a:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
  40072c:	6863      	ldr	r3, [r4, #4]
  40072e:	4632      	mov	r2, r6
  400730:	4629      	mov	r1, r5
  400732:	4620      	mov	r0, r4
  400734:	4798      	blx	r3
}
  400736:	bd70      	pop	{r4, r5, r6, pc}
  400738:	00402b30 	.word	0x00402b30
  40073c:	00400a95 	.word	0x00400a95

00400740 <pwm_period_expired>:

/**
 * \internal Process interrupts caused by period experied
 */
static void pwm_period_expired(struct _pwm_device *device)
{
  400740:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.period) {
  400742:	6943      	ldr	r3, [r0, #20]
  400744:	b103      	cbz	r3, 400748 <pwm_period_expired+0x8>
		descr->pwm_cb.period(descr);
  400746:	4798      	blx	r3
  400748:	bd08      	pop	{r3, pc}

0040074a <pwm_detect_fault>:

/**
 * \internal Process interrupts caused by pwm fault
 */
static void pwm_detect_fault(struct _pwm_device *device)
{
  40074a:	b508      	push	{r3, lr}
	struct pwm_descriptor *const descr = CONTAINER_OF(device, struct pwm_descriptor, device);

	if (descr->pwm_cb.error) {
  40074c:	6983      	ldr	r3, [r0, #24]
  40074e:	b103      	cbz	r3, 400752 <pwm_detect_fault+0x8>
		descr->pwm_cb.error(descr);
  400750:	4798      	blx	r3
  400752:	bd08      	pop	{r3, pc}

00400754 <pwm_init>:
{
  400754:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400756:	4604      	mov	r4, r0
  400758:	460d      	mov	r5, r1
  40075a:	2800      	cmp	r0, #0
  40075c:	bf18      	it	ne
  40075e:	2900      	cmpne	r1, #0
  400760:	bf14      	ite	ne
  400762:	2001      	movne	r0, #1
  400764:	2000      	moveq	r0, #0
  400766:	2233      	movs	r2, #51	; 0x33
  400768:	4906      	ldr	r1, [pc, #24]	; (400784 <pwm_init+0x30>)
  40076a:	4b07      	ldr	r3, [pc, #28]	; (400788 <pwm_init+0x34>)
  40076c:	4798      	blx	r3
	_pwm_init(&descr->device, hw);
  40076e:	4629      	mov	r1, r5
  400770:	4620      	mov	r0, r4
  400772:	4b06      	ldr	r3, [pc, #24]	; (40078c <pwm_init+0x38>)
  400774:	4798      	blx	r3
	descr->device.callback.pwm_period_cb = pwm_period_expired;
  400776:	4b06      	ldr	r3, [pc, #24]	; (400790 <pwm_init+0x3c>)
  400778:	6023      	str	r3, [r4, #0]
	descr->device.callback.pwm_error_cb  = pwm_detect_fault;
  40077a:	4b06      	ldr	r3, [pc, #24]	; (400794 <pwm_init+0x40>)
  40077c:	6063      	str	r3, [r4, #4]
}
  40077e:	2000      	movs	r0, #0
  400780:	bd38      	pop	{r3, r4, r5, pc}
  400782:	bf00      	nop
  400784:	00402b44 	.word	0x00402b44
  400788:	00400a95 	.word	0x00400a95
  40078c:	00400ead 	.word	0x00400ead
  400790:	00400741 	.word	0x00400741
  400794:	0040074b 	.word	0x0040074b

00400798 <pwm_enable>:
{
  400798:	b510      	push	{r4, lr}
	ASSERT(descr);
  40079a:	4604      	mov	r4, r0
  40079c:	224a      	movs	r2, #74	; 0x4a
  40079e:	4909      	ldr	r1, [pc, #36]	; (4007c4 <pwm_enable+0x2c>)
  4007a0:	3000      	adds	r0, #0
  4007a2:	bf18      	it	ne
  4007a4:	2001      	movne	r0, #1
  4007a6:	4b08      	ldr	r3, [pc, #32]	; (4007c8 <pwm_enable+0x30>)
  4007a8:	4798      	blx	r3
	if (_pwm_is_enabled(&descr->device)) {
  4007aa:	4620      	mov	r0, r4
  4007ac:	4b07      	ldr	r3, [pc, #28]	; (4007cc <pwm_enable+0x34>)
  4007ae:	4798      	blx	r3
  4007b0:	b920      	cbnz	r0, 4007bc <pwm_enable+0x24>
	_pwm_enable(&descr->device);
  4007b2:	4620      	mov	r0, r4
  4007b4:	4b06      	ldr	r3, [pc, #24]	; (4007d0 <pwm_enable+0x38>)
  4007b6:	4798      	blx	r3
	return ERR_NONE;
  4007b8:	2000      	movs	r0, #0
  4007ba:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
  4007bc:	f06f 0010 	mvn.w	r0, #16
}
  4007c0:	bd10      	pop	{r4, pc}
  4007c2:	bf00      	nop
  4007c4:	00402b44 	.word	0x00402b44
  4007c8:	00400a95 	.word	0x00400a95
  4007cc:	00401029 	.word	0x00401029
  4007d0:	00400fe5 	.word	0x00400fe5

004007d4 <spi_m_sync_set_func_ptr>:

/**
 *  \brief Initialize the SPI HAL instance function pointer for HPL APIs.
 */
void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi, void *const func)
{
  4007d4:	b538      	push	{r3, r4, r5, lr}
  4007d6:	460d      	mov	r5, r1
	ASSERT(spi);
  4007d8:	4604      	mov	r4, r0
  4007da:	2239      	movs	r2, #57	; 0x39
  4007dc:	4903      	ldr	r1, [pc, #12]	; (4007ec <spi_m_sync_set_func_ptr+0x18>)
  4007de:	3000      	adds	r0, #0
  4007e0:	bf18      	it	ne
  4007e2:	2001      	movne	r0, #1
  4007e4:	4b02      	ldr	r3, [pc, #8]	; (4007f0 <spi_m_sync_set_func_ptr+0x1c>)
  4007e6:	4798      	blx	r3
	spi->func = (struct _spi_m_sync_hpl_interface *)func;
  4007e8:	6025      	str	r5, [r4, #0]
  4007ea:	bd38      	pop	{r3, r4, r5, pc}
  4007ec:	00402b5c 	.word	0x00402b5c
  4007f0:	00400a95 	.word	0x00400a95

004007f4 <spi_m_sync_init>:
}

int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi, void *const hw)
{
  4007f4:	b538      	push	{r3, r4, r5, lr}
	int32_t rc = 0;
	ASSERT(spi && hw);
  4007f6:	4604      	mov	r4, r0
  4007f8:	460d      	mov	r5, r1
  4007fa:	2800      	cmp	r0, #0
  4007fc:	bf18      	it	ne
  4007fe:	2900      	cmpne	r1, #0
  400800:	bf14      	ite	ne
  400802:	2001      	movne	r0, #1
  400804:	2000      	moveq	r0, #0
  400806:	2240      	movs	r2, #64	; 0x40
  400808:	4909      	ldr	r1, [pc, #36]	; (400830 <spi_m_sync_init+0x3c>)
  40080a:	4b0a      	ldr	r3, [pc, #40]	; (400834 <spi_m_sync_init+0x40>)
  40080c:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
  40080e:	4620      	mov	r0, r4
  400810:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_sync_init(&spi->dev, hw);
  400814:	4629      	mov	r1, r5
  400816:	4b08      	ldr	r3, [pc, #32]	; (400838 <spi_m_sync_init+0x44>)
  400818:	4798      	blx	r3

	if (rc < 0) {
  40081a:	2800      	cmp	r0, #0
  40081c:	db07      	blt.n	40082e <spi_m_sync_init+0x3a>
		return rc;
	}

	spi->flags    = SPI_DEACTIVATE_NEXT;
  40081e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400822:	82a3      	strh	r3, [r4, #20]
	spi->io.read  = _spi_m_sync_io_read;
  400824:	4b05      	ldr	r3, [pc, #20]	; (40083c <spi_m_sync_init+0x48>)
  400826:	6123      	str	r3, [r4, #16]
	spi->io.write = _spi_m_sync_io_write;
  400828:	4b05      	ldr	r3, [pc, #20]	; (400840 <spi_m_sync_init+0x4c>)
  40082a:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
  40082c:	2000      	movs	r0, #0
}
  40082e:	bd38      	pop	{r3, r4, r5, pc}
  400830:	00402b5c 	.word	0x00402b5c
  400834:	00400a95 	.word	0x00400a95
  400838:	0040107d 	.word	0x0040107d
  40083c:	004008e9 	.word	0x004008e9
  400840:	004008ad 	.word	0x004008ad

00400844 <spi_m_sync_enable>:
	ASSERT(spi);
	_spi_m_sync_deinit(&spi->dev);
}

void spi_m_sync_enable(struct spi_m_sync_descriptor *spi)
{
  400844:	b510      	push	{r4, lr}
	ASSERT(spi);
  400846:	4604      	mov	r4, r0
  400848:	2257      	movs	r2, #87	; 0x57
  40084a:	4905      	ldr	r1, [pc, #20]	; (400860 <spi_m_sync_enable+0x1c>)
  40084c:	3000      	adds	r0, #0
  40084e:	bf18      	it	ne
  400850:	2001      	movne	r0, #1
  400852:	4b04      	ldr	r3, [pc, #16]	; (400864 <spi_m_sync_enable+0x20>)
  400854:	4798      	blx	r3
	_spi_m_sync_enable(&spi->dev);
  400856:	1d20      	adds	r0, r4, #4
  400858:	4b03      	ldr	r3, [pc, #12]	; (400868 <spi_m_sync_enable+0x24>)
  40085a:	4798      	blx	r3
  40085c:	bd10      	pop	{r4, pc}
  40085e:	bf00      	nop
  400860:	00402b5c 	.word	0x00402b5c
  400864:	00400a95 	.word	0x00400a95
  400868:	00401125 	.word	0x00401125

0040086c <spi_m_sync_transfer>:

	return spi_m_sync_transfer(spi, &xfer);
}

int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi, const struct spi_xfer *p_xfer)
{
  40086c:	b530      	push	{r4, r5, lr}
  40086e:	b085      	sub	sp, #20
	struct spi_msg msg;

	ASSERT(spi && p_xfer);
  400870:	4605      	mov	r5, r0
  400872:	460c      	mov	r4, r1
  400874:	2800      	cmp	r0, #0
  400876:	bf18      	it	ne
  400878:	2900      	cmpne	r1, #0
  40087a:	bf14      	ite	ne
  40087c:	2001      	movne	r0, #1
  40087e:	2000      	moveq	r0, #0
  400880:	22b3      	movs	r2, #179	; 0xb3
  400882:	4907      	ldr	r1, [pc, #28]	; (4008a0 <spi_m_sync_transfer+0x34>)
  400884:	4b07      	ldr	r3, [pc, #28]	; (4008a4 <spi_m_sync_transfer+0x38>)
  400886:	4798      	blx	r3

	msg.txbuf = p_xfer->txbuf;
  400888:	6823      	ldr	r3, [r4, #0]
  40088a:	9301      	str	r3, [sp, #4]
	msg.rxbuf = p_xfer->rxbuf;
  40088c:	6863      	ldr	r3, [r4, #4]
  40088e:	9302      	str	r3, [sp, #8]
	msg.size  = p_xfer->size;
  400890:	68a3      	ldr	r3, [r4, #8]
  400892:	9303      	str	r3, [sp, #12]
	return _spi_m_sync_trans(&spi->dev, &msg);
  400894:	a901      	add	r1, sp, #4
  400896:	1d28      	adds	r0, r5, #4
  400898:	4b03      	ldr	r3, [pc, #12]	; (4008a8 <spi_m_sync_transfer+0x3c>)
  40089a:	4798      	blx	r3
}
  40089c:	b005      	add	sp, #20
  40089e:	bd30      	pop	{r4, r5, pc}
  4008a0:	00402b5c 	.word	0x00402b5c
  4008a4:	00400a95 	.word	0x00400a95
  4008a8:	00401159 	.word	0x00401159

004008ac <_spi_m_sync_io_write>:
{
  4008ac:	b570      	push	{r4, r5, r6, lr}
  4008ae:	b084      	sub	sp, #16
  4008b0:	460e      	mov	r6, r1
  4008b2:	4615      	mov	r5, r2
	ASSERT(io);
  4008b4:	4604      	mov	r4, r0
  4008b6:	22a3      	movs	r2, #163	; 0xa3
  4008b8:	4908      	ldr	r1, [pc, #32]	; (4008dc <_spi_m_sync_io_write+0x30>)
  4008ba:	3000      	adds	r0, #0
  4008bc:	bf18      	it	ne
  4008be:	2001      	movne	r0, #1
  4008c0:	4b07      	ldr	r3, [pc, #28]	; (4008e0 <_spi_m_sync_io_write+0x34>)
  4008c2:	4798      	blx	r3
	xfer.rxbuf = 0;
  4008c4:	2300      	movs	r3, #0
  4008c6:	9302      	str	r3, [sp, #8]
	xfer.txbuf = (uint8_t *)buf;
  4008c8:	9601      	str	r6, [sp, #4]
	xfer.size  = length;
  4008ca:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  4008cc:	a901      	add	r1, sp, #4
  4008ce:	f1a4 000c 	sub.w	r0, r4, #12
  4008d2:	4b04      	ldr	r3, [pc, #16]	; (4008e4 <_spi_m_sync_io_write+0x38>)
  4008d4:	4798      	blx	r3
}
  4008d6:	b004      	add	sp, #16
  4008d8:	bd70      	pop	{r4, r5, r6, pc}
  4008da:	bf00      	nop
  4008dc:	00402b5c 	.word	0x00402b5c
  4008e0:	00400a95 	.word	0x00400a95
  4008e4:	0040086d 	.word	0x0040086d

004008e8 <_spi_m_sync_io_read>:
{
  4008e8:	b570      	push	{r4, r5, r6, lr}
  4008ea:	b084      	sub	sp, #16
  4008ec:	460e      	mov	r6, r1
  4008ee:	4615      	mov	r5, r2
	ASSERT(io);
  4008f0:	4604      	mov	r4, r0
  4008f2:	2287      	movs	r2, #135	; 0x87
  4008f4:	4908      	ldr	r1, [pc, #32]	; (400918 <_spi_m_sync_io_read+0x30>)
  4008f6:	3000      	adds	r0, #0
  4008f8:	bf18      	it	ne
  4008fa:	2001      	movne	r0, #1
  4008fc:	4b07      	ldr	r3, [pc, #28]	; (40091c <_spi_m_sync_io_read+0x34>)
  4008fe:	4798      	blx	r3
	xfer.rxbuf = buf;
  400900:	9602      	str	r6, [sp, #8]
	xfer.txbuf = 0;
  400902:	2300      	movs	r3, #0
  400904:	9301      	str	r3, [sp, #4]
	xfer.size  = length;
  400906:	9503      	str	r5, [sp, #12]
	return spi_m_sync_transfer(spi, &xfer);
  400908:	a901      	add	r1, sp, #4
  40090a:	f1a4 000c 	sub.w	r0, r4, #12
  40090e:	4b04      	ldr	r3, [pc, #16]	; (400920 <_spi_m_sync_io_read+0x38>)
  400910:	4798      	blx	r3
}
  400912:	b004      	add	sp, #16
  400914:	bd70      	pop	{r4, r5, r6, pc}
  400916:	bf00      	nop
  400918:	00402b5c 	.word	0x00402b5c
  40091c:	00400a95 	.word	0x00400a95
  400920:	0040086d 	.word	0x0040086d

00400924 <spi_m_sync_get_io_descriptor>:

int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *const spi, struct io_descriptor **io)
{
  400924:	b538      	push	{r3, r4, r5, lr}
	ASSERT(spi && io);
  400926:	4604      	mov	r4, r0
  400928:	460d      	mov	r5, r1
  40092a:	2800      	cmp	r0, #0
  40092c:	bf18      	it	ne
  40092e:	2900      	cmpne	r1, #0
  400930:	bf14      	ite	ne
  400932:	2001      	movne	r0, #1
  400934:	2000      	moveq	r0, #0
  400936:	22bd      	movs	r2, #189	; 0xbd
  400938:	4903      	ldr	r1, [pc, #12]	; (400948 <spi_m_sync_get_io_descriptor+0x24>)
  40093a:	4b04      	ldr	r3, [pc, #16]	; (40094c <spi_m_sync_get_io_descriptor+0x28>)
  40093c:	4798      	blx	r3
	*io = &spi->io;
  40093e:	340c      	adds	r4, #12
  400940:	602c      	str	r4, [r5, #0]
	return 0;
}
  400942:	2000      	movs	r0, #0
  400944:	bd38      	pop	{r3, r4, r5, pc}
  400946:	bf00      	nop
  400948:	00402b5c 	.word	0x00402b5c
  40094c:	00400a95 	.word	0x00400a95

00400950 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
  400950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400952:	4616      	mov	r6, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  400954:	4605      	mov	r5, r0
  400956:	460f      	mov	r7, r1
  400958:	2800      	cmp	r0, #0
  40095a:	bf18      	it	ne
  40095c:	2900      	cmpne	r1, #0
  40095e:	d002      	beq.n	400966 <usart_sync_write+0x16>
  400960:	bb0a      	cbnz	r2, 4009a6 <usart_sync_write+0x56>
  400962:	2000      	movs	r0, #0
  400964:	e000      	b.n	400968 <usart_sync_write+0x18>
  400966:	2000      	movs	r0, #0
  400968:	22f1      	movs	r2, #241	; 0xf1
  40096a:	4910      	ldr	r1, [pc, #64]	; (4009ac <usart_sync_write+0x5c>)
  40096c:	4b10      	ldr	r3, [pc, #64]	; (4009b0 <usart_sync_write+0x60>)
  40096e:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
  400970:	f105 0408 	add.w	r4, r5, #8
  400974:	4620      	mov	r0, r4
  400976:	4b0f      	ldr	r3, [pc, #60]	; (4009b4 <usart_sync_write+0x64>)
  400978:	4798      	blx	r3
  40097a:	2800      	cmp	r0, #0
  40097c:	d0f8      	beq.n	400970 <usart_sync_write+0x20>
  40097e:	2500      	movs	r5, #0
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
  400980:	5d79      	ldrb	r1, [r7, r5]
  400982:	4620      	mov	r0, r4
  400984:	4b0c      	ldr	r3, [pc, #48]	; (4009b8 <usart_sync_write+0x68>)
  400986:	4798      	blx	r3
		while (!_usart_sync_is_ready_to_send(&descr->device))
  400988:	4620      	mov	r0, r4
  40098a:	4b0a      	ldr	r3, [pc, #40]	; (4009b4 <usart_sync_write+0x64>)
  40098c:	4798      	blx	r3
  40098e:	2800      	cmp	r0, #0
  400990:	d0fa      	beq.n	400988 <usart_sync_write+0x38>
			;
	} while (++offset < length);
  400992:	3501      	adds	r5, #1
  400994:	42b5      	cmp	r5, r6
  400996:	d3f3      	bcc.n	400980 <usart_sync_write+0x30>
	while (!_usart_sync_is_transmit_done(&descr->device))
  400998:	4620      	mov	r0, r4
  40099a:	4b08      	ldr	r3, [pc, #32]	; (4009bc <usart_sync_write+0x6c>)
  40099c:	4798      	blx	r3
  40099e:	2800      	cmp	r0, #0
  4009a0:	d0fa      	beq.n	400998 <usart_sync_write+0x48>
		;
	return (int32_t)offset;
}
  4009a2:	4628      	mov	r0, r5
  4009a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(io_descr && buf && length);
  4009a6:	2001      	movs	r0, #1
  4009a8:	e7de      	b.n	400968 <usart_sync_write+0x18>
  4009aa:	bf00      	nop
  4009ac:	00402b78 	.word	0x00402b78
  4009b0:	00400a95 	.word	0x00400a95
  4009b4:	00401641 	.word	0x00401641
  4009b8:	004015f9 	.word	0x004015f9
  4009bc:	00401669 	.word	0x00401669

004009c0 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
  4009c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4009c4:	4617      	mov	r7, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
  4009c6:	4605      	mov	r5, r0
  4009c8:	4688      	mov	r8, r1
  4009ca:	2800      	cmp	r0, #0
  4009cc:	bf18      	it	ne
  4009ce:	2900      	cmpne	r1, #0
  4009d0:	d002      	beq.n	4009d8 <usart_sync_read+0x18>
  4009d2:	b9d2      	cbnz	r2, 400a0a <usart_sync_read+0x4a>
  4009d4:	2000      	movs	r0, #0
  4009d6:	e000      	b.n	4009da <usart_sync_read+0x1a>
  4009d8:	2000      	movs	r0, #0
  4009da:	f44f 7286 	mov.w	r2, #268	; 0x10c
  4009de:	490c      	ldr	r1, [pc, #48]	; (400a10 <usart_sync_read+0x50>)
  4009e0:	4b0c      	ldr	r3, [pc, #48]	; (400a14 <usart_sync_read+0x54>)
  4009e2:	4798      	blx	r3
	uint32_t                      offset = 0;
  4009e4:	2600      	movs	r6, #0
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
  4009e6:	f105 0408 	add.w	r4, r5, #8
  4009ea:	4620      	mov	r0, r4
  4009ec:	4b0a      	ldr	r3, [pc, #40]	; (400a18 <usart_sync_read+0x58>)
  4009ee:	4798      	blx	r3
  4009f0:	2800      	cmp	r0, #0
  4009f2:	d0f8      	beq.n	4009e6 <usart_sync_read+0x26>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
  4009f4:	4620      	mov	r0, r4
  4009f6:	4b09      	ldr	r3, [pc, #36]	; (400a1c <usart_sync_read+0x5c>)
  4009f8:	4798      	blx	r3
  4009fa:	f808 0006 	strb.w	r0, [r8, r6]
	} while (++offset < length);
  4009fe:	3601      	adds	r6, #1
  400a00:	42be      	cmp	r6, r7
  400a02:	d3f0      	bcc.n	4009e6 <usart_sync_read+0x26>

	return (int32_t)offset;
}
  400a04:	4630      	mov	r0, r6
  400a06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(io_descr && buf && length);
  400a0a:	2001      	movs	r0, #1
  400a0c:	e7e5      	b.n	4009da <usart_sync_read+0x1a>
  400a0e:	bf00      	nop
  400a10:	00402b78 	.word	0x00402b78
  400a14:	00400a95 	.word	0x00400a95
  400a18:	00401691 	.word	0x00401691
  400a1c:	0040161d 	.word	0x0040161d

00400a20 <usart_sync_init>:
{
  400a20:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr && hw);
  400a22:	4604      	mov	r4, r0
  400a24:	460d      	mov	r5, r1
  400a26:	2800      	cmp	r0, #0
  400a28:	bf18      	it	ne
  400a2a:	2900      	cmpne	r1, #0
  400a2c:	bf14      	ite	ne
  400a2e:	2001      	movne	r0, #1
  400a30:	2000      	moveq	r0, #0
  400a32:	2234      	movs	r2, #52	; 0x34
  400a34:	4907      	ldr	r1, [pc, #28]	; (400a54 <usart_sync_init+0x34>)
  400a36:	4b08      	ldr	r3, [pc, #32]	; (400a58 <usart_sync_init+0x38>)
  400a38:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
  400a3a:	4629      	mov	r1, r5
  400a3c:	f104 0008 	add.w	r0, r4, #8
  400a40:	4b06      	ldr	r3, [pc, #24]	; (400a5c <usart_sync_init+0x3c>)
  400a42:	4798      	blx	r3
	if (init_status) {
  400a44:	4603      	mov	r3, r0
  400a46:	b918      	cbnz	r0, 400a50 <usart_sync_init+0x30>
	descr->io.read  = usart_sync_read;
  400a48:	4a05      	ldr	r2, [pc, #20]	; (400a60 <usart_sync_init+0x40>)
  400a4a:	6062      	str	r2, [r4, #4]
	descr->io.write = usart_sync_write;
  400a4c:	4a05      	ldr	r2, [pc, #20]	; (400a64 <usart_sync_init+0x44>)
  400a4e:	6022      	str	r2, [r4, #0]
}
  400a50:	4618      	mov	r0, r3
  400a52:	bd38      	pop	{r3, r4, r5, pc}
  400a54:	00402b78 	.word	0x00402b78
  400a58:	00400a95 	.word	0x00400a95
  400a5c:	0040158d 	.word	0x0040158d
  400a60:	004009c1 	.word	0x004009c1
  400a64:	00400951 	.word	0x00400951

00400a68 <usart_sync_enable>:
{
  400a68:	b510      	push	{r4, lr}
	ASSERT(descr);
  400a6a:	4604      	mov	r4, r0
  400a6c:	2253      	movs	r2, #83	; 0x53
  400a6e:	4906      	ldr	r1, [pc, #24]	; (400a88 <usart_sync_enable+0x20>)
  400a70:	3000      	adds	r0, #0
  400a72:	bf18      	it	ne
  400a74:	2001      	movne	r0, #1
  400a76:	4b05      	ldr	r3, [pc, #20]	; (400a8c <usart_sync_enable+0x24>)
  400a78:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
  400a7a:	f104 0008 	add.w	r0, r4, #8
  400a7e:	4b04      	ldr	r3, [pc, #16]	; (400a90 <usart_sync_enable+0x28>)
  400a80:	4798      	blx	r3
}
  400a82:	2000      	movs	r0, #0
  400a84:	bd10      	pop	{r4, pc}
  400a86:	bf00      	nop
  400a88:	00402b78 	.word	0x00402b78
  400a8c:	00400a95 	.word	0x00400a95
  400a90:	004015c5 	.word	0x004015c5

00400a94 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
  400a94:	b900      	cbnz	r0, 400a98 <assert+0x4>
		__asm("BKPT #0");
  400a96:	be00      	bkpt	0x0000
  400a98:	4770      	bx	lr
	...

00400a9c <_sbrk>:

/**
 * \brief Replacement of C library of _sbrk
 */
extern caddr_t _sbrk(int incr)
{
  400a9c:	4603      	mov	r3, r0
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
  400a9e:	4a06      	ldr	r2, [pc, #24]	; (400ab8 <_sbrk+0x1c>)
  400aa0:	6812      	ldr	r2, [r2, #0]
  400aa2:	b122      	cbz	r2, 400aae <_sbrk+0x12>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;
  400aa4:	4a04      	ldr	r2, [pc, #16]	; (400ab8 <_sbrk+0x1c>)
  400aa6:	6810      	ldr	r0, [r2, #0]

	heap += incr;
  400aa8:	4403      	add	r3, r0
  400aaa:	6013      	str	r3, [r2, #0]

	return (caddr_t)prev_heap;
}
  400aac:	4770      	bx	lr
		heap = (unsigned char *)&_end;
  400aae:	4903      	ldr	r1, [pc, #12]	; (400abc <_sbrk+0x20>)
  400ab0:	4a01      	ldr	r2, [pc, #4]	; (400ab8 <_sbrk+0x1c>)
  400ab2:	6011      	str	r1, [r2, #0]
  400ab4:	e7f6      	b.n	400aa4 <_sbrk+0x8>
  400ab6:	bf00      	nop
  400ab8:	20400094 	.word	0x20400094
  400abc:	20400720 	.word	0x20400720

00400ac0 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
  400ac0:	f04f 30ff 	mov.w	r0, #4294967295
  400ac4:	4770      	bx	lr

00400ac6 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
  400ac6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  400aca:	604b      	str	r3, [r1, #4]

	return 0;
}
  400acc:	2000      	movs	r0, #0
  400ace:	4770      	bx	lr

00400ad0 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
  400ad0:	2001      	movs	r0, #1
  400ad2:	4770      	bx	lr

00400ad4 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
  400ad4:	2000      	movs	r0, #0
  400ad6:	4770      	bx	lr

00400ad8 <_get_cycles_for_us>:
 * \brief Retrieve the amount of cycles to delay for the given amount of us
 */
uint32_t _get_cycles_for_us(const uint16_t us)
{
	return _get_cycles_for_us_internal(us, CONF_HCLK_FREQUENCY, HCLK_FREQ_POWER);
}
  400ad8:	f44f 7396 	mov.w	r3, #300	; 0x12c
  400adc:	fb03 f000 	mul.w	r0, r3, r0
  400ae0:	4770      	bx	lr
	...

00400ae4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
  400ae4:	b500      	push	{lr}
  400ae6:	b083      	sub	sp, #12
/**
 * \brief Enable FPU
 */
static inline void _fpu_enable(void)
{
	CRITICAL_SECTION_ENTER()
  400ae8:	a801      	add	r0, sp, #4
  400aea:	4b0e      	ldr	r3, [pc, #56]	; (400b24 <_init_chip+0x40>)
  400aec:	4798      	blx	r3
	/** Set bits 20-23 to enable CP10 and CP11 coprocessors */
	SCB->CPACR |= (0xFu << 20);
  400aee:	4a0e      	ldr	r2, [pc, #56]	; (400b28 <_init_chip+0x44>)
  400af0:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
  400af4:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  400af8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
  400afc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400b00:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	CRITICAL_SECTION_LEAVE()
  400b04:	a801      	add	r0, sp, #4
  400b06:	4b09      	ldr	r3, [pc, #36]	; (400b2c <_init_chip+0x48>)
  400b08:	4798      	blx	r3

static inline void hri_efc_write_EEFC_FMR_FWS_bf(const void *const hw, hri_efc_eefc_fmr_reg_t data)
{
	uint32_t tmp;
	EFC_CRITICAL_SECTION_ENTER();
	tmp = ((Efc *)hw)->EEFC_FMR;
  400b0a:	4a09      	ldr	r2, [pc, #36]	; (400b30 <_init_chip+0x4c>)
  400b0c:	6813      	ldr	r3, [r2, #0]
	tmp &= ~EEFC_FMR_FWS_Msk;
  400b0e:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
	tmp |= EEFC_FMR_FWS(data);
  400b12:	f443 63c0 	orr.w	r3, r3, #1536	; 0x600
	((Efc *)hw)->EEFC_FMR = tmp;
  400b16:	6013      	str	r3, [r2, #0]
#if CONF_DMA_ENABLE
	_pmc_enable_periph_clock(ID_XDMAC);
	_dma_init();

#endif
	_pmc_init();
  400b18:	4b06      	ldr	r3, [pc, #24]	; (400b34 <_init_chip+0x50>)
  400b1a:	4798      	blx	r3
}
  400b1c:	b003      	add	sp, #12
  400b1e:	f85d fb04 	ldr.w	pc, [sp], #4
  400b22:	bf00      	nop
  400b24:	00400579 	.word	0x00400579
  400b28:	e000ed00 	.word	0xe000ed00
  400b2c:	00400587 	.word	0x00400587
  400b30:	400e0c00 	.word	0x400e0c00
  400b34:	00400e31 	.word	0x00400e31

00400b38 <_ffs>:
};
#endif

/* Find the first bit set */
static int _ffs(uint32_t *v, uint8_t len)
{
  400b38:	b430      	push	{r4, r5}
	uint32_t i, j, bit;

	for (i = 0; i < len; i++) {
  400b3a:	2500      	movs	r5, #0
  400b3c:	428d      	cmp	r5, r1
  400b3e:	d210      	bcs.n	400b62 <_ffs+0x2a>
  400b40:	2201      	movs	r2, #1
  400b42:	2300      	movs	r3, #0
		bit = 1;
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400b44:	2b1f      	cmp	r3, #31
  400b46:	d80a      	bhi.n	400b5e <_ffs+0x26>
			if (v[i] & bit) {
  400b48:	f850 4025 	ldr.w	r4, [r0, r5, lsl #2]
  400b4c:	4222      	tst	r2, r4
  400b4e:	d102      	bne.n	400b56 <_ffs+0x1e>
				return i * 32 + j;
			}
			bit <<= 1;
  400b50:	0052      	lsls	r2, r2, #1
		for (j = 0; j < sizeof(uint32_t) * 8; j++) {
  400b52:	3301      	adds	r3, #1
  400b54:	e7f6      	b.n	400b44 <_ffs+0xc>
				return i * 32 + j;
  400b56:	eb03 1045 	add.w	r0, r3, r5, lsl #5
		}
	}

	return -1;
}
  400b5a:	bc30      	pop	{r4, r5}
  400b5c:	4770      	bx	lr
	for (i = 0; i < len; i++) {
  400b5e:	3501      	adds	r5, #1
  400b60:	e7ec      	b.n	400b3c <_ffs+0x4>
	return -1;
  400b62:	f04f 30ff 	mov.w	r0, #4294967295
  400b66:	e7f8      	b.n	400b5a <_ffs+0x22>

00400b68 <_ext_irq_handler>:

/**
 * \brief External interrupt handler
 */
static void _ext_irq_handler(void)
{
  400b68:	b510      	push	{r4, lr}
  400b6a:	b086      	sub	sp, #24
	uint32_t flag_total = 0, flags[5] = {
  400b6c:	2300      	movs	r3, #0
  400b6e:	9301      	str	r3, [sp, #4]
  400b70:	9302      	str	r3, [sp, #8]
  400b72:	9303      	str	r3, [sp, #12]
  400b74:	9304      	str	r3, [sp, #16]
  400b76:	9305      	str	r3, [sp, #20]
	                             0,
	                         };
	int pos;

	ASSERT(callback);
  400b78:	4b21      	ldr	r3, [pc, #132]	; (400c00 <_ext_irq_handler+0x98>)
  400b7a:	6818      	ldr	r0, [r3, #0]
  400b7c:	22f8      	movs	r2, #248	; 0xf8
  400b7e:	4921      	ldr	r1, [pc, #132]	; (400c04 <_ext_irq_handler+0x9c>)
  400b80:	3000      	adds	r0, #0
  400b82:	bf18      	it	ne
  400b84:	2001      	movne	r0, #1
  400b86:	4b20      	ldr	r3, [pc, #128]	; (400c08 <_ext_irq_handler+0xa0>)
  400b88:	4798      	blx	r3
	return ((Pio *)hw)->PIO_ISR;
  400b8a:	4b20      	ldr	r3, [pc, #128]	; (400c0c <_ext_irq_handler+0xa4>)
  400b8c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400b8e:	6c9b      	ldr	r3, [r3, #72]	; 0x48

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	flags[0] = hri_pio_read_ISR_reg(PIOA);
	flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400b90:	4013      	ands	r3, r2
  400b92:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400b94:	491e      	ldr	r1, [pc, #120]	; (400c10 <_ext_irq_handler+0xa8>)
  400b96:	6cca      	ldr	r2, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400b98:	6c89      	ldr	r1, [r1, #72]	; 0x48
	flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	flags[1] = hri_pio_read_ISR_reg(PIOB);
	flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400b9a:	400a      	ands	r2, r1
  400b9c:	9202      	str	r2, [sp, #8]
	flag_total |= flags[1];
  400b9e:	4313      	orrs	r3, r2
	flags[4] = hri_pio_read_ISR_reg(PIOE);
	flags[4] &= hri_pio_read_IMR_reg(PIOE);
	flag_total |= flags[4];
#endif

	while (flag_total) {
  400ba0:	e025      	b.n	400bee <_ext_irq_handler+0x86>
		pos = _ffs(flags, 5);
		while (-1 != pos) {
			callback(pos);
  400ba2:	4b17      	ldr	r3, [pc, #92]	; (400c00 <_ext_irq_handler+0x98>)
  400ba4:	681b      	ldr	r3, [r3, #0]
  400ba6:	4620      	mov	r0, r4
  400ba8:	4798      	blx	r3

			flags[pos >> 5] &= ~(1 << (pos & 31));
  400baa:	1163      	asrs	r3, r4, #5
  400bac:	f004 041f 	and.w	r4, r4, #31
  400bb0:	2201      	movs	r2, #1
  400bb2:	fa02 f404 	lsl.w	r4, r2, r4
  400bb6:	aa06      	add	r2, sp, #24
  400bb8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
  400bbc:	f853 2c14 	ldr.w	r2, [r3, #-20]
  400bc0:	ea22 0204 	bic.w	r2, r2, r4
  400bc4:	f843 2c14 	str.w	r2, [r3, #-20]
			pos = _ffs(flags, 5);
  400bc8:	2105      	movs	r1, #5
  400bca:	a801      	add	r0, sp, #4
  400bcc:	4b11      	ldr	r3, [pc, #68]	; (400c14 <_ext_irq_handler+0xac>)
  400bce:	4798      	blx	r3
  400bd0:	4604      	mov	r4, r0
		while (-1 != pos) {
  400bd2:	f1b4 3fff 	cmp.w	r4, #4294967295
  400bd6:	d1e4      	bne.n	400ba2 <_ext_irq_handler+0x3a>
	return ((Pio *)hw)->PIO_ISR;
  400bd8:	4a0c      	ldr	r2, [pc, #48]	; (400c0c <_ext_irq_handler+0xa4>)
  400bda:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400bdc:	6c93      	ldr	r3, [r2, #72]	; 0x48
		}
		flag_total = 0;

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
		flags[0] = hri_pio_read_ISR_reg(PIOA);
		flags[0] &= hri_pio_read_IMR_reg(PIOA);
  400bde:	400b      	ands	r3, r1
  400be0:	9301      	str	r3, [sp, #4]
	return ((Pio *)hw)->PIO_ISR;
  400be2:	490b      	ldr	r1, [pc, #44]	; (400c10 <_ext_irq_handler+0xa8>)
  400be4:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
	return ((Pio *)hw)->PIO_IMR;
  400be6:	6c8a      	ldr	r2, [r1, #72]	; 0x48
		flag_total |= flags[0];
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
		flags[1] = hri_pio_read_ISR_reg(PIOB);
		flags[1] &= hri_pio_read_IMR_reg(PIOB);
  400be8:	4002      	ands	r2, r0
  400bea:	9202      	str	r2, [sp, #8]
		flag_total |= flags[1];
  400bec:	4313      	orrs	r3, r2
	while (flag_total) {
  400bee:	b12b      	cbz	r3, 400bfc <_ext_irq_handler+0x94>
		pos = _ffs(flags, 5);
  400bf0:	2105      	movs	r1, #5
  400bf2:	a801      	add	r0, sp, #4
  400bf4:	4b07      	ldr	r3, [pc, #28]	; (400c14 <_ext_irq_handler+0xac>)
  400bf6:	4798      	blx	r3
  400bf8:	4604      	mov	r4, r0
		while (-1 != pos) {
  400bfa:	e7ea      	b.n	400bd2 <_ext_irq_handler+0x6a>
		flags[4] = hri_pio_read_ISR_reg(PIOE);
		flags[4] &= hri_pio_read_IMR_reg(PIOE);
		flag_total |= flags[4];
#endif
	}
}
  400bfc:	b006      	add	sp, #24
  400bfe:	bd10      	pop	{r4, pc}
  400c00:	20400098 	.word	0x20400098
  400c04:	00402bd4 	.word	0x00402bd4
  400c08:	00400a95 	.word	0x00400a95
  400c0c:	400e0e00 	.word	0x400e0e00
  400c10:	400e1000 	.word	0x400e1000
  400c14:	00400b39 	.word	0x00400b39

00400c18 <_pio_get_hardware_index>:
{
  400c18:	b510      	push	{r4, lr}
	ASSERT(hw);
  400c1a:	4604      	mov	r4, r0
  400c1c:	22d2      	movs	r2, #210	; 0xd2
  400c1e:	4905      	ldr	r1, [pc, #20]	; (400c34 <_pio_get_hardware_index+0x1c>)
  400c20:	3000      	adds	r0, #0
  400c22:	bf18      	it	ne
  400c24:	2001      	movne	r0, #1
  400c26:	4b04      	ldr	r3, [pc, #16]	; (400c38 <_pio_get_hardware_index+0x20>)
  400c28:	4798      	blx	r3
	return ((uint32_t)hw - (uint32_t)PIOA) >> 9;
  400c2a:	4804      	ldr	r0, [pc, #16]	; (400c3c <_pio_get_hardware_index+0x24>)
  400c2c:	4420      	add	r0, r4
}
  400c2e:	f3c0 2047 	ubfx	r0, r0, #9, #8
  400c32:	bd10      	pop	{r4, pc}
  400c34:	00402bd4 	.word	0x00402bd4
  400c38:	00400a95 	.word	0x00400a95
  400c3c:	bff1f200 	.word	0xbff1f200

00400c40 <_pio_get_index>:
{
  400c40:	b510      	push	{r4, lr}
	ASSERT(hw);
  400c42:	4604      	mov	r4, r0
  400c44:	22e0      	movs	r2, #224	; 0xe0
  400c46:	490d      	ldr	r1, [pc, #52]	; (400c7c <_pio_get_index+0x3c>)
  400c48:	3000      	adds	r0, #0
  400c4a:	bf18      	it	ne
  400c4c:	2001      	movne	r0, #1
  400c4e:	4b0c      	ldr	r3, [pc, #48]	; (400c80 <_pio_get_index+0x40>)
  400c50:	4798      	blx	r3
	uint8_t offset = _pio_get_hardware_index(hw);
  400c52:	4620      	mov	r0, r4
  400c54:	4b0b      	ldr	r3, [pc, #44]	; (400c84 <_pio_get_index+0x44>)
  400c56:	4798      	blx	r3
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400c58:	2300      	movs	r3, #0
  400c5a:	2b01      	cmp	r3, #1
  400c5c:	d80b      	bhi.n	400c76 <_pio_get_index+0x36>
		if (_ext_irq[i].number == offset) {
  400c5e:	ebc3 01c3 	rsb	r1, r3, r3, lsl #3
  400c62:	008a      	lsls	r2, r1, #2
  400c64:	4908      	ldr	r1, [pc, #32]	; (400c88 <_pio_get_index+0x48>)
  400c66:	5c8a      	ldrb	r2, [r1, r2]
  400c68:	4290      	cmp	r0, r2
  400c6a:	d002      	beq.n	400c72 <_pio_get_index+0x32>
	for (i = 0; i < ARRAY_SIZE(_ext_irq); i++) {
  400c6c:	3301      	adds	r3, #1
  400c6e:	b2db      	uxtb	r3, r3
  400c70:	e7f3      	b.n	400c5a <_pio_get_index+0x1a>
			return i;
  400c72:	b258      	sxtb	r0, r3
  400c74:	bd10      	pop	{r4, pc}
	return ERR_INVALID_DATA;
  400c76:	f04f 30ff 	mov.w	r0, #4294967295
}
  400c7a:	bd10      	pop	{r4, pc}
  400c7c:	00402bd4 	.word	0x00402bd4
  400c80:	00400a95 	.word	0x00400a95
  400c84:	00400c19 	.word	0x00400c19
  400c88:	00402b94 	.word	0x00402b94

00400c8c <_pio_init>:
 * \return The status of instance initial
 * \retval ERR_NONE Initial status OK
 * \retval ERR_DENIED No need to initial
 */
static int32_t _pio_init(void *const hw)
{
  400c8c:	b538      	push	{r3, r4, r5, lr}
	int8_t i;

	ASSERT(hw);
  400c8e:	4604      	mov	r4, r0
  400c90:	f240 1259 	movw	r2, #345	; 0x159
  400c94:	4929      	ldr	r1, [pc, #164]	; (400d3c <_pio_init+0xb0>)
  400c96:	3000      	adds	r0, #0
  400c98:	bf18      	it	ne
  400c9a:	2001      	movne	r0, #1
  400c9c:	4b28      	ldr	r3, [pc, #160]	; (400d40 <_pio_init+0xb4>)
  400c9e:	4798      	blx	r3

	i = _pio_get_index(hw);
  400ca0:	4620      	mov	r0, r4
  400ca2:	4b28      	ldr	r3, [pc, #160]	; (400d44 <_pio_init+0xb8>)
  400ca4:	4798      	blx	r3
	if (i < 0) {
  400ca6:	2800      	cmp	r0, #0
  400ca8:	db43      	blt.n	400d32 <_pio_init+0xa6>
		return ERR_DENIED;
	}

	hri_pio_set_AIMMR_reg(hw, _ext_irq[i].add_irq_enable);
  400caa:	4d27      	ldr	r5, [pc, #156]	; (400d48 <_pio_init+0xbc>)
  400cac:	00c2      	lsls	r2, r0, #3
  400cae:	1a11      	subs	r1, r2, r0
  400cb0:	008b      	lsls	r3, r1, #2
  400cb2:	442b      	add	r3, r5
  400cb4:	6899      	ldr	r1, [r3, #8]
	((Pio *)hw)->PIO_AIMER = mask;
  400cb6:	f8c4 10b0 	str.w	r1, [r4, #176]	; 0xb0
	hri_pio_clear_ELSR_reg(hw, _ext_irq[i].esr);
  400cba:	68d9      	ldr	r1, [r3, #12]
	((Pio *)hw)->PIO_ESR = mask;
  400cbc:	f8c4 10c0 	str.w	r1, [r4, #192]	; 0xc0
	hri_pio_set_ELSR_reg(hw, _ext_irq[i].lsr);
  400cc0:	6919      	ldr	r1, [r3, #16]
	((Pio *)hw)->PIO_LSR = mask;
  400cc2:	f8c4 10c4 	str.w	r1, [r4, #196]	; 0xc4
	hri_pio_clear_FRLHSR_reg(hw, _ext_irq[i].fellsr);
  400cc6:	699b      	ldr	r3, [r3, #24]
	((Pio *)hw)->PIO_FELLSR = mask;
  400cc8:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
	hri_pio_set_FRLHSR_reg(hw, _ext_irq[i].rehlsr);
  400ccc:	1a10      	subs	r0, r2, r0
  400cce:	0083      	lsls	r3, r0, #2
  400cd0:	442b      	add	r3, r5
  400cd2:	695b      	ldr	r3, [r3, #20]
	((Pio *)hw)->PIO_REHLSR = mask;
  400cd4:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4

	i = _pio_irq_n[_pio_get_hardware_index(hw)];
  400cd8:	4620      	mov	r0, r4
  400cda:	4b1c      	ldr	r3, [pc, #112]	; (400d4c <_pio_init+0xc0>)
  400cdc:	4798      	blx	r3
  400cde:	4428      	add	r0, r5
  400ce0:	f990 3038 	ldrsb.w	r3, [r0, #56]	; 0x38
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400ce4:	2b00      	cmp	r3, #0
  400ce6:	db0c      	blt.n	400d02 <_pio_init+0x76>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400ce8:	095a      	lsrs	r2, r3, #5
  400cea:	f003 001f 	and.w	r0, r3, #31
  400cee:	2101      	movs	r1, #1
  400cf0:	4081      	lsls	r1, r0
  400cf2:	3220      	adds	r2, #32
  400cf4:	4816      	ldr	r0, [pc, #88]	; (400d50 <_pio_init+0xc4>)
  400cf6:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  400cfa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400cfe:	f3bf 8f6f 	isb	sy
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  400d02:	2b00      	cmp	r3, #0
  400d04:	db08      	blt.n	400d18 <_pio_init+0x8c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400d06:	095a      	lsrs	r2, r3, #5
  400d08:	f003 001f 	and.w	r0, r3, #31
  400d0c:	2101      	movs	r1, #1
  400d0e:	4081      	lsls	r1, r0
  400d10:	3260      	adds	r2, #96	; 0x60
  400d12:	480f      	ldr	r0, [pc, #60]	; (400d50 <_pio_init+0xc4>)
  400d14:	f840 1022 	str.w	r1, [r0, r2, lsl #2]
  if ((int32_t)(IRQn) >= 0)
  400d18:	2b00      	cmp	r3, #0
  400d1a:	db0d      	blt.n	400d38 <_pio_init+0xac>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400d1c:	0959      	lsrs	r1, r3, #5
  400d1e:	f003 031f 	and.w	r3, r3, #31
  400d22:	2201      	movs	r2, #1
  400d24:	fa02 f303 	lsl.w	r3, r2, r3
  400d28:	4a09      	ldr	r2, [pc, #36]	; (400d50 <_pio_init+0xc4>)
  400d2a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
	NVIC_DisableIRQ((IRQn_Type)i);
	NVIC_ClearPendingIRQ((IRQn_Type)i);
	NVIC_EnableIRQ((IRQn_Type)i);

	return ERR_NONE;
  400d2e:	2000      	movs	r0, #0
  400d30:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
  400d32:	f06f 0010 	mvn.w	r0, #16
  400d36:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NONE;
  400d38:	2000      	movs	r0, #0
}
  400d3a:	bd38      	pop	{r3, r4, r5, pc}
  400d3c:	00402bd4 	.word	0x00402bd4
  400d40:	00400a95 	.word	0x00400a95
  400d44:	00400c41 	.word	0x00400c41
  400d48:	00402b94 	.word	0x00402b94
  400d4c:	00400c19 	.word	0x00400c19
  400d50:	e000e100 	.word	0xe000e100

00400d54 <PIOB_Handler>:
{
  400d54:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400d56:	4b01      	ldr	r3, [pc, #4]	; (400d5c <PIOB_Handler+0x8>)
  400d58:	4798      	blx	r3
  400d5a:	bd08      	pop	{r3, pc}
  400d5c:	00400b69 	.word	0x00400b69

00400d60 <PIOA_Handler>:
{
  400d60:	b508      	push	{r3, lr}
	_ext_irq_handler();
  400d62:	4b01      	ldr	r3, [pc, #4]	; (400d68 <PIOA_Handler+0x8>)
  400d64:	4798      	blx	r3
  400d66:	bd08      	pop	{r3, pc}
  400d68:	00400b69 	.word	0x00400b69

00400d6c <_ext_irq_init>:

int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
  400d6c:	b538      	push	{r3, r4, r5, lr}
  400d6e:	4605      	mov	r5, r0

#if CONF_EXTIRQ_0_ENABLE == 1 && defined(PIOA)
	_pio_init(PIOA);
  400d70:	4804      	ldr	r0, [pc, #16]	; (400d84 <_ext_irq_init+0x18>)
  400d72:	4c05      	ldr	r4, [pc, #20]	; (400d88 <_ext_irq_init+0x1c>)
  400d74:	47a0      	blx	r4
#endif

#if CONF_EXTIRQ_1_ENABLE == 1 && defined(PIOB)
	_pio_init(PIOB);
  400d76:	4805      	ldr	r0, [pc, #20]	; (400d8c <_ext_irq_init+0x20>)
  400d78:	47a0      	blx	r4

#if CONF_EXTIRQ_4_ENABLE == 1 && defined(PIOE)
	_pio_init(PIOE);
#endif

	callback = cb;
  400d7a:	4b05      	ldr	r3, [pc, #20]	; (400d90 <_ext_irq_init+0x24>)
  400d7c:	601d      	str	r5, [r3, #0]

	return ERR_NONE;
}
  400d7e:	2000      	movs	r0, #0
  400d80:	bd38      	pop	{r3, r4, r5, pc}
  400d82:	bf00      	nop
  400d84:	400e0e00 	.word	0x400e0e00
  400d88:	00400c8d 	.word	0x00400c8d
  400d8c:	400e1000 	.word	0x400e1000
  400d90:	20400098 	.word	0x20400098

00400d94 <_pmc_init_sources>:
	PMC_CRITICAL_SECTION_LEAVE();
}

static inline hri_pmc_ckgr_mor_reg_t hri_pmc_read_CKGR_MOR_reg(const void *const hw)
{
	return ((Pmc *)hw)->CKGR_MOR;
  400d94:	490e      	ldr	r1, [pc, #56]	; (400dd0 <_pmc_init_sources+0x3c>)
  400d96:	6a0a      	ldr	r2, [r1, #32]
	/* Enable Main XTAL oscillator */
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTEN;
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY | CKGR_MOR_MOSCSEL;
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
#else
	data = hri_pmc_read_CKGR_MOR_reg(PMC) & ~CKGR_MOR_MOSCXTBY;
  400d98:	f022 0202 	bic.w	r2, r2, #2
	data |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(CONF_XOSC20M_STARTUP_TIME);
  400d9c:	4b0d      	ldr	r3, [pc, #52]	; (400dd4 <_pmc_init_sources+0x40>)
  400d9e:	4313      	orrs	r3, r2
	((Pmc *)hw)->CKGR_MOR = data;
  400da0:	620b      	str	r3, [r1, #32]
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MOSCXTS) > 0;
  400da2:	4b0b      	ldr	r3, [pc, #44]	; (400dd0 <_pmc_init_sources+0x3c>)
  400da4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	hri_pmc_write_CKGR_MOR_reg(PMC, data);
	while (!hri_pmc_get_SR_MOSCXTS_bit(PMC)) {
  400da6:	f013 0f01 	tst.w	r3, #1
  400daa:	d0fa      	beq.n	400da2 <_pmc_init_sources+0xe>
	((Pmc *)hw)->CKGR_MOR |= mask;
  400dac:	4b08      	ldr	r3, [pc, #32]	; (400dd0 <_pmc_init_sources+0x3c>)
  400dae:	6a19      	ldr	r1, [r3, #32]
  400db0:	4a09      	ldr	r2, [pc, #36]	; (400dd8 <_pmc_init_sources+0x44>)
  400db2:	430a      	orrs	r2, r1
  400db4:	621a      	str	r2, [r3, #32]

static inline void hri_pmc_write_CKGR_PLLAR_MULA_bf(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->CKGR_PLLAR;
  400db6:	6a99      	ldr	r1, [r3, #40]	; 0x28
	tmp &= ~CKGR_PLLAR_MULA_Msk;
  400db8:	4a08      	ldr	r2, [pc, #32]	; (400ddc <_pmc_init_sources+0x48>)
  400dba:	400a      	ands	r2, r1
	tmp |= CKGR_PLLAR_MULA(data);
	((Pmc *)hw)->CKGR_PLLAR = tmp;
  400dbc:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline void hri_pmc_write_CKGR_PLLAR_reg(const void *const hw, hri_pmc_ckgr_pllar_reg_t data)
{
	PMC_CRITICAL_SECTION_ENTER();
	((Pmc *)hw)->CKGR_PLLAR = data;
  400dbe:	4a08      	ldr	r2, [pc, #32]	; (400de0 <_pmc_init_sources+0x4c>)
  400dc0:	629a      	str	r2, [r3, #40]	; 0x28
	return (((Pmc *)hw)->PMC_SR & PMC_SR_LOCKA) > 0;
  400dc2:	4b03      	ldr	r3, [pc, #12]	; (400dd0 <_pmc_init_sources+0x3c>)
  400dc4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
#if (CONF_PLLACK_ENABLE == 1)
	data = CKGR_PLLAR_MULA(CONF_PLLACK_MUL - 1) | CKGR_PLLAR_DIVA(CONF_PLLACK_DIV) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
	/* Stop PLL first */
	hri_pmc_write_CKGR_PLLAR_MULA_bf(PMC, 0);
	hri_pmc_write_CKGR_PLLAR_reg(PMC, (CKGR_PLLAR_ONE | data));
	while (!hri_pmc_get_SR_LOCKA_bit(PMC)) {
  400dc6:	f013 0f02 	tst.w	r3, #2
  400dca:	d0fa      	beq.n	400dc2 <_pmc_init_sources+0x2e>
#if (CONF_CLK_CFDEN_ENABLE == 1)
	/* Enable main clock failure detection */
	hri_pmc_set_CKGR_MOR_CFDEN_bit(PMC);
#endif
#endif
}
  400dcc:	4770      	bx	lr
  400dce:	bf00      	nop
  400dd0:	400e0600 	.word	0x400e0600
  400dd4:	00373e01 	.word	0x00373e01
  400dd8:	01370000 	.word	0x01370000
  400ddc:	f800ffff 	.word	0xf800ffff
  400de0:	20183f01 	.word	0x20183f01

00400de4 <_pmc_init_master_clock>:

static inline void hri_pmc_write_MCKR_PRES_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400de4:	4a11      	ldr	r2, [pc, #68]	; (400e2c <_pmc_init_master_clock+0x48>)
  400de6:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_PRES_Msk;
  400de8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
	tmp |= PMC_MCKR_PRES(data);
	((Pmc *)hw)->PMC_MCKR = tmp;
  400dec:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400dee:	4b0f      	ldr	r3, [pc, #60]	; (400e2c <_pmc_init_master_clock+0x48>)
  400df0:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
		/* Wait until master clock is ready */
	}
#elif ((CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_PLLACK) || (CONF_CLK_GEN_MCKR_SRC == CLK_SRC_OPTION_UPLLCKDIV))
	hri_pmc_write_MCKR_PRES_bf(PMC, CONF_MCKR_PRESC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400df2:	f013 0f08 	tst.w	r3, #8
  400df6:	d0fa      	beq.n	400dee <_pmc_init_master_clock+0xa>

static inline void hri_pmc_write_MCKR_MDIV_bf(const void *const hw, hri_pmc_mckr_reg_t data)
{
	uint32_t tmp;
	PMC_CRITICAL_SECTION_ENTER();
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400df8:	4a0c      	ldr	r2, [pc, #48]	; (400e2c <_pmc_init_master_clock+0x48>)
  400dfa:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_MDIV_Msk;
  400dfc:	f423 7340 	bic.w	r3, r3, #768	; 0x300
	tmp |= PMC_MCKR_MDIV(data);
  400e00:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Pmc *)hw)->PMC_MCKR = tmp;
  400e04:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400e06:	4b09      	ldr	r3, [pc, #36]	; (400e2c <_pmc_init_master_clock+0x48>)
  400e08:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_MDIV_bf(PMC, CONF_MCK_DIV);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400e0a:	f013 0f08 	tst.w	r3, #8
  400e0e:	d0fa      	beq.n	400e06 <_pmc_init_master_clock+0x22>
	tmp = ((Pmc *)hw)->PMC_MCKR;
  400e10:	4a06      	ldr	r2, [pc, #24]	; (400e2c <_pmc_init_master_clock+0x48>)
  400e12:	6b13      	ldr	r3, [r2, #48]	; 0x30
	tmp &= ~PMC_MCKR_CSS_Msk;
  400e14:	f023 0303 	bic.w	r3, r3, #3
	tmp |= PMC_MCKR_CSS(data);
  400e18:	f043 0302 	orr.w	r3, r3, #2
	((Pmc *)hw)->PMC_MCKR = tmp;
  400e1c:	6313      	str	r3, [r2, #48]	; 0x30
	return (((Pmc *)hw)->PMC_SR & PMC_SR_MCKRDY) > 0;
  400e1e:	4b03      	ldr	r3, [pc, #12]	; (400e2c <_pmc_init_master_clock+0x48>)
  400e20:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Wait until master clock is ready */
	}
	hri_pmc_write_MCKR_CSS_bf(PMC, CONF_CLK_GEN_MCKR_SRC);
	while (!hri_pmc_get_SR_MCKRDY_bit(PMC)) {
  400e22:	f013 0f08 	tst.w	r3, #8
  400e26:	d0fa      	beq.n	400e1e <_pmc_init_master_clock+0x3a>
		/* Wait until master clock is ready */
	}
#endif
#endif
}
  400e28:	4770      	bx	lr
  400e2a:	bf00      	nop
  400e2c:	400e0600 	.word	0x400e0600

00400e30 <_pmc_init>:
/**
 * \brief Initializes cortex M7 core clock
 *
 */
void _pmc_init(void)
{
  400e30:	b508      	push	{r3, lr}
	_pmc_init_sources();
  400e32:	4b02      	ldr	r3, [pc, #8]	; (400e3c <_pmc_init+0xc>)
  400e34:	4798      	blx	r3
	_pmc_init_master_clock();
  400e36:	4b02      	ldr	r3, [pc, #8]	; (400e40 <_pmc_init+0x10>)
  400e38:	4798      	blx	r3
  400e3a:	bd08      	pop	{r3, pc}
  400e3c:	00400d95 	.word	0x00400d95
  400e40:	00400de5 	.word	0x00400de5

00400e44 <_pwm_get_cfg>:
 */
static const struct _pwm_cfg *_pwm_get_cfg(void *const hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  400e44:	2300      	movs	r3, #0
  400e46:	b10b      	cbz	r3, 400e4c <_pwm_get_cfg+0x8>
		if (_pwms[i].hw == hw) {
			return (_pwms + i);
		}
	}

	return NULL;
  400e48:	2000      	movs	r0, #0
}
  400e4a:	4770      	bx	lr
		if (_pwms[i].hw == hw) {
  400e4c:	ebc3 1103 	rsb	r1, r3, r3, lsl #4
  400e50:	008a      	lsls	r2, r1, #2
  400e52:	4906      	ldr	r1, [pc, #24]	; (400e6c <_pwm_get_cfg+0x28>)
  400e54:	588a      	ldr	r2, [r1, r2]
  400e56:	4282      	cmp	r2, r0
  400e58:	d002      	beq.n	400e60 <_pwm_get_cfg+0x1c>
	for (i = 0; i < ARRAY_SIZE(_pwms); i++) {
  400e5a:	3301      	adds	r3, #1
  400e5c:	b2db      	uxtb	r3, r3
  400e5e:	e7f2      	b.n	400e46 <_pwm_get_cfg+0x2>
			return (_pwms + i);
  400e60:	ebc3 1303 	rsb	r3, r3, r3, lsl #4
  400e64:	009a      	lsls	r2, r3, #2
  400e66:	4608      	mov	r0, r1
  400e68:	4410      	add	r0, r2
  400e6a:	4770      	bx	lr
  400e6c:	00402bf0 	.word	0x00402bf0

00400e70 <_pwm_init_irq_param>:
/**
 * \brief Init irq param with the given pwm hardware instance
 */
static void _pwm_init_irq_param(const void *const hw, struct _pwm_device *dev)
{
	if (hw == PWM0) {
  400e70:	4b03      	ldr	r3, [pc, #12]	; (400e80 <_pwm_init_irq_param+0x10>)
  400e72:	4298      	cmp	r0, r3
  400e74:	d000      	beq.n	400e78 <_pwm_init_irq_param+0x8>
  400e76:	4770      	bx	lr
		_pwm0_dev = dev;
  400e78:	4b02      	ldr	r3, [pc, #8]	; (400e84 <_pwm_init_irq_param+0x14>)
  400e7a:	6019      	str	r1, [r3, #0]
	}
}
  400e7c:	e7fb      	b.n	400e76 <_pwm_init_irq_param+0x6>
  400e7e:	bf00      	nop
  400e80:	40020000 	.word	0x40020000
  400e84:	2040009c 	.word	0x2040009c

00400e88 <_pwm_interrupt_handler>:
 * \internal interrupt handler for PWM
 *
 * \param[in] instance PWM instance number
 */
static void _pwm_interrupt_handler(struct _pwm_device *device)
{
  400e88:	b508      	push	{r3, lr}
	if (hri_pwm_read_ISR1_reg(device->hw)) {
  400e8a:	6903      	ldr	r3, [r0, #16]
	return tmp;
}

static inline hri_pwm_isr1_reg_t hri_pwm_read_ISR1_reg(const void *const hw)
{
	return ((Pwm *)hw)->PWM_ISR1;
  400e8c:	69db      	ldr	r3, [r3, #28]
  400e8e:	b113      	cbz	r3, 400e96 <_pwm_interrupt_handler+0xe>
		if (NULL != device->callback.pwm_period_cb) {
  400e90:	6803      	ldr	r3, [r0, #0]
  400e92:	b103      	cbz	r3, 400e96 <_pwm_interrupt_handler+0xe>
			device->callback.pwm_period_cb(device);
  400e94:	4798      	blx	r3
  400e96:	bd08      	pop	{r3, pc}

00400e98 <PWM0_Handler>:

/**
 * \internal PWM interrupt handler
 */
void PWM0_Handler(void)
{
  400e98:	b508      	push	{r3, lr}
	_pwm_interrupt_handler(_pwm0_dev);
  400e9a:	4b02      	ldr	r3, [pc, #8]	; (400ea4 <PWM0_Handler+0xc>)
  400e9c:	6818      	ldr	r0, [r3, #0]
  400e9e:	4b02      	ldr	r3, [pc, #8]	; (400ea8 <PWM0_Handler+0x10>)
  400ea0:	4798      	blx	r3
  400ea2:	bd08      	pop	{r3, pc}
  400ea4:	2040009c 	.word	0x2040009c
  400ea8:	00400e89 	.word	0x00400e89

00400eac <_pwm_init>:
}

int32_t _pwm_init(struct _pwm_device *const device, void *const hw)
{
  400eac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  400eae:	4606      	mov	r6, r0
	ASSERT(hw);
  400eb0:	460c      	mov	r4, r1
  400eb2:	1c08      	adds	r0, r1, #0
  400eb4:	bf18      	it	ne
  400eb6:	2001      	movne	r0, #1
  400eb8:	f240 1271 	movw	r2, #369	; 0x171
  400ebc:	4944      	ldr	r1, [pc, #272]	; (400fd0 <_pwm_init+0x124>)
  400ebe:	4b45      	ldr	r3, [pc, #276]	; (400fd4 <_pwm_init+0x128>)
  400ec0:	4798      	blx	r3
	int8_t                      i;
	const struct _pwm_cfg *     cfg;
	const struct _pwm_ch_cfg *  ch;
	const struct _pwm_comp_cfg *comp;

	cfg = _pwm_get_cfg(hw);
  400ec2:	4620      	mov	r0, r4
  400ec4:	4b44      	ldr	r3, [pc, #272]	; (400fd8 <_pwm_init+0x12c>)
  400ec6:	4798      	blx	r3
  400ec8:	4605      	mov	r5, r0

	device->hw = hw;
  400eca:	6134      	str	r4, [r6, #16]
	/* Init PMW */
	hri_pwm_write_CLK_reg(hw, cfg->pwm_clk);
  400ecc:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_pwm_write_CLK_reg(const void *const hw, hri_pwm_clk_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_CLK = data;
  400ece:	6023      	str	r3, [r4, #0]
	hri_pwm_write_ELMR_reg(hw, 0, cfg->pwm_elmr0);
  400ed0:	68c3      	ldr	r3, [r0, #12]
}

static inline void hri_pwm_write_ELMR_reg(const void *const hw, uint8_t index, hri_pwm_elmr_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ELMR[index] = data;
  400ed2:	67e3      	str	r3, [r4, #124]	; 0x7c
	hri_pwm_write_ELMR_reg(hw, 1, cfg->pwm_elmr1);
  400ed4:	6903      	ldr	r3, [r0, #16]
  400ed6:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	hri_pwm_write_FMR_reg(hw, cfg->pwm_fmr);
  400eda:	6943      	ldr	r3, [r0, #20]
	((Pwm *)hw)->PWM_FMR = data;
  400edc:	65e3      	str	r3, [r4, #92]	; 0x5c
	hri_pwm_write_FPV1_reg(hw, cfg->pwm_fpv1);
  400ede:	6983      	ldr	r3, [r0, #24]
	((Pwm *)hw)->PWM_FPV1 = data;
  400ee0:	66a3      	str	r3, [r4, #104]	; 0x68
	hri_pwm_write_FPV2_reg(hw, cfg->pwm_fpv2);
  400ee2:	69c3      	ldr	r3, [r0, #28]
}

static inline void hri_pwm_write_FPV2_reg(const void *const hw, hri_pwm_fpv2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_FPV2 = data;
  400ee4:	f8c4 30c0 	str.w	r3, [r4, #192]	; 0xc0
	hri_pwm_write_FPE_reg(hw, cfg->pwm_fpe);
  400ee8:	6a03      	ldr	r3, [r0, #32]
	((Pwm *)hw)->PWM_FPE = data;
  400eea:	66e3      	str	r3, [r4, #108]	; 0x6c
	hri_pwm_write_ETRG1_reg(hw, cfg->pwm_etrg1);
  400eec:	6a43      	ldr	r3, [r0, #36]	; 0x24
}

static inline void hri_pwm_write_ETRG1_reg(const void *const hw, hri_pwm_etrg1_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG1 = data;
  400eee:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	hri_pwm_write_ETRG2_reg(hw, cfg->pwm_etrg2);
  400ef2:	6a83      	ldr	r3, [r0, #40]	; 0x28
}

static inline void hri_pwm_write_ETRG2_reg(const void *const hw, hri_pwm_etrg2_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ETRG2 = data;
  400ef4:	f8c4 344c 	str.w	r3, [r4, #1100]	; 0x44c

	/* Init Channel */
	for (i = 0; i < cfg->ch_num; i++) {
  400ef8:	2300      	movs	r3, #0
  400efa:	e019      	b.n	400f30 <_pwm_init+0x84>
		ch = cfg->ch + i;
  400efc:	6b2f      	ldr	r7, [r5, #48]	; 0x30
  400efe:	0118      	lsls	r0, r3, #4
  400f00:	eb07 0e00 	add.w	lr, r7, r0
		hri_pwm_write_CMR_reg(hw, ch->index, ch->mode);
  400f04:	5c3a      	ldrb	r2, [r7, r0]
  400f06:	f8de 1004 	ldr.w	r1, [lr, #4]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CMR = data;
  400f0a:	3210      	adds	r2, #16
  400f0c:	0152      	lsls	r2, r2, #5
  400f0e:	50a1      	str	r1, [r4, r2]
		hri_pwm_write_CDTY_reg(hw, ch->index, ch->duty_cycle);
  400f10:	5c3a      	ldrb	r2, [r7, r0]
  400f12:	f8de 100c 	ldr.w	r1, [lr, #12]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CDTY = data;
  400f16:	3210      	adds	r2, #16
  400f18:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  400f1c:	6051      	str	r1, [r2, #4]
		hri_pwm_write_CPRD_reg(hw, ch->index, ch->period);
  400f1e:	5c3a      	ldrb	r2, [r7, r0]
  400f20:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CPRD = data;
  400f24:	eb04 1242 	add.w	r2, r4, r2, lsl #5
  400f28:	f8c2 120c 	str.w	r1, [r2, #524]	; 0x20c
	for (i = 0; i < cfg->ch_num; i++) {
  400f2c:	3301      	adds	r3, #1
  400f2e:	b25b      	sxtb	r3, r3
  400f30:	6aea      	ldr	r2, [r5, #44]	; 0x2c
  400f32:	4293      	cmp	r3, r2
  400f34:	d3e2      	bcc.n	400efc <_pwm_init+0x50>
  400f36:	2300      	movs	r3, #0
  400f38:	e014      	b.n	400f64 <_pwm_init+0xb8>
	}
	/* Init comparison */
	for (i = 0; i < cfg->comp_num; i++) {
		comp = cfg->comp + i;
  400f3a:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  400f3c:	eb03 0043 	add.w	r0, r3, r3, lsl #1
  400f40:	0082      	lsls	r2, r0, #2
  400f42:	eb01 0e02 	add.w	lr, r1, r2
		hri_pwm_write_CMPM_reg(hw, comp->index, comp->comp_cmpm);
  400f46:	5c88      	ldrb	r0, [r1, r2]
  400f48:	f8de 7004 	ldr.w	r7, [lr, #4]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPM = data;
  400f4c:	eb04 1000 	add.w	r0, r4, r0, lsl #4
  400f50:	f8c0 7138 	str.w	r7, [r0, #312]	; 0x138
		hri_pwm_write_CMPV_reg(hw, comp->index, comp->comp_cmpv);
  400f54:	5c8a      	ldrb	r2, [r1, r2]
  400f56:	f8de 1008 	ldr.w	r1, [lr, #8]
	((Pwm *)hw)->PwmCmp[submodule_index].PWM_CMPV = data;
  400f5a:	3213      	adds	r2, #19
  400f5c:	0112      	lsls	r2, r2, #4
  400f5e:	50a1      	str	r1, [r4, r2]
	for (i = 0; i < cfg->comp_num; i++) {
  400f60:	3301      	adds	r3, #1
  400f62:	b25b      	sxtb	r3, r3
  400f64:	6b6a      	ldr	r2, [r5, #52]	; 0x34
  400f66:	4293      	cmp	r3, r2
  400f68:	d3e7      	bcc.n	400f3a <_pwm_init+0x8e>
	}

	_pwm_init_irq_param(hw, device);
  400f6a:	4631      	mov	r1, r6
  400f6c:	4620      	mov	r0, r4
  400f6e:	4b1b      	ldr	r3, [pc, #108]	; (400fdc <_pwm_init+0x130>)
  400f70:	4798      	blx	r3
	NVIC_DisableIRQ(cfg->irq);
  400f72:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  400f76:	2b00      	cmp	r3, #0
  400f78:	db0d      	blt.n	400f96 <_pwm_init+0xea>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400f7a:	095a      	lsrs	r2, r3, #5
  400f7c:	f003 031f 	and.w	r3, r3, #31
  400f80:	2101      	movs	r1, #1
  400f82:	fa01 f303 	lsl.w	r3, r1, r3
  400f86:	3220      	adds	r2, #32
  400f88:	4915      	ldr	r1, [pc, #84]	; (400fe0 <_pwm_init+0x134>)
  400f8a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
  400f8e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  400f92:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(cfg->irq);
  400f96:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  400f9a:	2b00      	cmp	r3, #0
  400f9c:	db09      	blt.n	400fb2 <_pwm_init+0x106>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400f9e:	095a      	lsrs	r2, r3, #5
  400fa0:	f003 031f 	and.w	r3, r3, #31
  400fa4:	2101      	movs	r1, #1
  400fa6:	fa01 f303 	lsl.w	r3, r1, r3
  400faa:	3260      	adds	r2, #96	; 0x60
  400fac:	490c      	ldr	r1, [pc, #48]	; (400fe0 <_pwm_init+0x134>)
  400fae:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
	NVIC_EnableIRQ(cfg->irq);
  400fb2:	f995 3004 	ldrsb.w	r3, [r5, #4]
  if ((int32_t)(IRQn) >= 0)
  400fb6:	2b00      	cmp	r3, #0
  400fb8:	db08      	blt.n	400fcc <_pwm_init+0x120>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400fba:	0959      	lsrs	r1, r3, #5
  400fbc:	f003 031f 	and.w	r3, r3, #31
  400fc0:	2201      	movs	r2, #1
  400fc2:	fa02 f303 	lsl.w	r3, r2, r3
  400fc6:	4a06      	ldr	r2, [pc, #24]	; (400fe0 <_pwm_init+0x134>)
  400fc8:	f842 3021 	str.w	r3, [r2, r1, lsl #2]

	return ERR_NONE;
}
  400fcc:	2000      	movs	r0, #0
  400fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400fd0:	00402c3c 	.word	0x00402c3c
  400fd4:	00400a95 	.word	0x00400a95
  400fd8:	00400e45 	.word	0x00400e45
  400fdc:	00400e71 	.word	0x00400e71
  400fe0:	e000e100 	.word	0xe000e100

00400fe4 <_pwm_enable>:

	hri_pwm_write_DIS_reg(device->hw, PWM_DIS_MASK);
}

void _pwm_enable(struct _pwm_device *const device)
{
  400fe4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(device);
  400fe6:	4604      	mov	r4, r0
  400fe8:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
  400fec:	490b      	ldr	r1, [pc, #44]	; (40101c <_pwm_enable+0x38>)
  400fee:	3000      	adds	r0, #0
  400ff0:	bf18      	it	ne
  400ff2:	2001      	movne	r0, #1
  400ff4:	4b0a      	ldr	r3, [pc, #40]	; (401020 <_pwm_enable+0x3c>)
  400ff6:	4798      	blx	r3
	int8_t                 i;
	const struct _pwm_cfg *cfg;

	cfg = _pwm_get_cfg(device->hw);
  400ff8:	6920      	ldr	r0, [r4, #16]
  400ffa:	4b0a      	ldr	r3, [pc, #40]	; (401024 <_pwm_enable+0x40>)
  400ffc:	4798      	blx	r3

	for (i = 0; i < cfg->ch_num; i++) {
  400ffe:	2300      	movs	r3, #0
  401000:	e008      	b.n	401014 <_pwm_enable+0x30>
		hri_pwm_write_ENA_reg(device->hw, 0x1u << cfg->ch[i].index);
  401002:	6921      	ldr	r1, [r4, #16]
  401004:	6b05      	ldr	r5, [r0, #48]	; 0x30
  401006:	011a      	lsls	r2, r3, #4
  401008:	5cad      	ldrb	r5, [r5, r2]
  40100a:	2201      	movs	r2, #1
  40100c:	40aa      	lsls	r2, r5
}

static inline void hri_pwm_write_ENA_reg(const void *const hw, hri_pwm_ena_reg_t data)
{
	PWM_CRITICAL_SECTION_ENTER();
	((Pwm *)hw)->PWM_ENA = data;
  40100e:	604a      	str	r2, [r1, #4]
	for (i = 0; i < cfg->ch_num; i++) {
  401010:	3301      	adds	r3, #1
  401012:	b25b      	sxtb	r3, r3
  401014:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  401016:	4293      	cmp	r3, r2
  401018:	d3f3      	bcc.n	401002 <_pwm_enable+0x1e>
	}
}
  40101a:	bd38      	pop	{r3, r4, r5, pc}
  40101c:	00402c3c 	.word	0x00402c3c
  401020:	00400a95 	.word	0x00400a95
  401024:	00400e45 	.word	0x00400e45

00401028 <_pwm_is_enabled>:
		hri_pwm_write_CPRDUPD_reg(device->hw, cfg->ch[i].index, period);
	}
}

bool _pwm_is_enabled(const struct _pwm_device *const device)
{
  401028:	b510      	push	{r4, lr}
	ASSERT(device);
  40102a:	4604      	mov	r4, r0
  40102c:	f240 12d1 	movw	r2, #465	; 0x1d1
  401030:	4907      	ldr	r1, [pc, #28]	; (401050 <_pwm_is_enabled+0x28>)
  401032:	3000      	adds	r0, #0
  401034:	bf18      	it	ne
  401036:	2001      	movne	r0, #1
  401038:	4b06      	ldr	r3, [pc, #24]	; (401054 <_pwm_is_enabled+0x2c>)
  40103a:	4798      	blx	r3
	uint8_t status = hri_pwm_get_SR_reg(device->hw, 0x0F);
  40103c:	6923      	ldr	r3, [r4, #16]
	tmp = ((Pwm *)hw)->PWM_SR;
  40103e:	68db      	ldr	r3, [r3, #12]
	if (status == 0) {
  401040:	f013 0f0f 	tst.w	r3, #15
  401044:	d001      	beq.n	40104a <_pwm_is_enabled+0x22>
		return false;
	} else {
		return true;
  401046:	2001      	movs	r0, #1
	}
}
  401048:	bd10      	pop	{r4, pc}
		return false;
  40104a:	2000      	movs	r0, #0
  40104c:	bd10      	pop	{r4, pc}
  40104e:	bf00      	nop
  401050:	00402c3c 	.word	0x00402c3c
  401054:	00400a95 	.word	0x00400a95

00401058 <_pwm_get_pwm>:
 * \brief Retrieve pwm helper functions
 */
struct _pwm_hpl_interface *_pwm_get_pwm(void)
{
	return NULL;
}
  401058:	2000      	movs	r0, #0
  40105a:	4770      	bx	lr

0040105c <_spi_sync_enable>:
}

static inline void hri_spi_write_CR_reg(const void *const hw, hri_spi_cr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_CR = data;
  40105c:	2301      	movs	r3, #1
  40105e:	6003      	str	r3, [r0, #0]
static int32_t _spi_sync_enable(void *const hw)
{
	hri_spi_write_CR_reg(hw, SPI_CR_SPIEN);

	return ERR_NONE;
}
  401060:	2000      	movs	r0, #0
  401062:	4770      	bx	lr

00401064 <_spi_get_hardware_index>:
 * \brief Retrieve ordinal number of the given SPI hardware instance
 */
static uint8_t _spi_get_hardware_index(const void *const hw)
{

	uint8_t index = ((uint32_t)hw - (uint32_t)SPI0) >> 16;
  401064:	4b04      	ldr	r3, [pc, #16]	; (401078 <_spi_get_hardware_index+0x14>)
  401066:	4403      	add	r3, r0
  401068:	f3c3 4307 	ubfx	r3, r3, #16, #8

	if (index == 5) {
  40106c:	2b05      	cmp	r3, #5
  40106e:	d001      	beq.n	401074 <_spi_get_hardware_index+0x10>
		return 1;
	} else {
		return 0;
  401070:	2000      	movs	r0, #0
	}
}
  401072:	4770      	bx	lr
		return 1;
  401074:	2001      	movs	r0, #1
  401076:	4770      	bx	lr
  401078:	bfff8000 	.word	0xbfff8000

0040107c <_spi_m_sync_init>:

	return NULL;
}

int32_t _spi_m_sync_init(struct _spi_m_sync_dev *dev, void *const hw)
{
  40107c:	b570      	push	{r4, r5, r6, lr}
  40107e:	4606      	mov	r6, r0
  401080:	460c      	mov	r4, r1
	uint8_t n = _spi_get_hardware_index((const void *)hw_addr);
  401082:	4608      	mov	r0, r1
  401084:	4b20      	ldr	r3, [pc, #128]	; (401108 <_spi_m_sync_init+0x8c>)
  401086:	4798      	blx	r3
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  401088:	2300      	movs	r3, #0
  40108a:	b33b      	cbz	r3, 4010dc <_spi_m_sync_init+0x60>
	return NULL;
  40108c:	2500      	movs	r5, #0
	const struct spi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);

	ASSERT(dev && hw);
  40108e:	f44f 729a 	mov.w	r2, #308	; 0x134
  401092:	491e      	ldr	r1, [pc, #120]	; (40110c <_spi_m_sync_init+0x90>)
  401094:	2e00      	cmp	r6, #0
  401096:	bf18      	it	ne
  401098:	2c00      	cmpne	r4, #0
  40109a:	bf14      	ite	ne
  40109c:	2001      	movne	r0, #1
  40109e:	2000      	moveq	r0, #0
  4010a0:	4b1b      	ldr	r3, [pc, #108]	; (401110 <_spi_m_sync_init+0x94>)
  4010a2:	4798      	blx	r3

	if (regs == NULL) {
  4010a4:	b355      	cbz	r5, 4010fc <_spi_m_sync_init+0x80>
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  4010a6:	6923      	ldr	r3, [r4, #16]
		return ERR_INVALID_ARG;
	}

	if (hri_spi_get_SR_SPIENS_bit(hw)) {
  4010a8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  4010ac:	d129      	bne.n	401102 <_spi_m_sync_init+0x86>
	((Spi *)hw)->SPI_CR = data;
  4010ae:	2380      	movs	r3, #128	; 0x80
  4010b0:	6023      	str	r3, [r4, #0]
		return ERR_DENIED;
	}
	hri_spi_write_CR_reg(hw, SPI_CR_SWRST);
	dev->prvt = hw;
  4010b2:	6034      	str	r4, [r6, #0]
	hri_spi_write_CR_reg(hw, (regs->cr & ~(SPI_CR_SPIEN | SPI_CR_SPIDIS | SPI_CR_SWRST | SPI_CR_LASTXFER)));
  4010b4:	686a      	ldr	r2, [r5, #4]
  4010b6:	4b17      	ldr	r3, [pc, #92]	; (401114 <_spi_m_sync_init+0x98>)
  4010b8:	4013      	ands	r3, r2
  4010ba:	6023      	str	r3, [r4, #0]
	hri_spi_write_MR_reg(hw, ((regs->mr | SPI_MR_PCS(0x0E) | SPI_MR_MODFDIS) & ~SPI_MR_LLB));
  4010bc:	68ab      	ldr	r3, [r5, #8]
  4010be:	4a16      	ldr	r2, [pc, #88]	; (401118 <_spi_m_sync_init+0x9c>)
  4010c0:	401a      	ands	r2, r3
  4010c2:	4b16      	ldr	r3, [pc, #88]	; (40111c <_spi_m_sync_init+0xa0>)
  4010c4:	4313      	orrs	r3, r2
	((Spi *)hw)->SPI_MR = data;
  4010c6:	6063      	str	r3, [r4, #4]
	hri_spi_write_CSR_reg(hw, 0, regs->csr);
  4010c8:	68eb      	ldr	r3, [r5, #12]
	((Spi *)hw)->SPI_CSR[index] = data;
  4010ca:	6323      	str	r3, [r4, #48]	; 0x30

	dev->dummy_byte = regs->dummy_byte;
  4010cc:	8a2b      	ldrh	r3, [r5, #16]
  4010ce:	80f3      	strh	r3, [r6, #6]
	dev->char_size  = regs->csr & SPI_CSR_BITS_Msk;
  4010d0:	68eb      	ldr	r3, [r5, #12]
  4010d2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
  4010d6:	7133      	strb	r3, [r6, #4]

	return ERR_NONE;
  4010d8:	2000      	movs	r0, #0
  4010da:	bd70      	pop	{r4, r5, r6, pc}
		if (spi_regs[i].number == n) {
  4010dc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
  4010e0:	008a      	lsls	r2, r1, #2
  4010e2:	490f      	ldr	r1, [pc, #60]	; (401120 <_spi_m_sync_init+0xa4>)
  4010e4:	5c8a      	ldrb	r2, [r1, r2]
  4010e6:	4290      	cmp	r0, r2
  4010e8:	d002      	beq.n	4010f0 <_spi_m_sync_init+0x74>
	for (i = 0; i < sizeof(spi_regs) / sizeof(struct spi_regs_cfg); i++) {
  4010ea:	3301      	adds	r3, #1
  4010ec:	b2db      	uxtb	r3, r3
  4010ee:	e7cc      	b.n	40108a <_spi_m_sync_init+0xe>
			return &spi_regs[i];
  4010f0:	eb03 0583 	add.w	r5, r3, r3, lsl #2
  4010f4:	00ab      	lsls	r3, r5, #2
  4010f6:	460d      	mov	r5, r1
  4010f8:	441d      	add	r5, r3
  4010fa:	e7c8      	b.n	40108e <_spi_m_sync_init+0x12>
		return ERR_INVALID_ARG;
  4010fc:	f06f 000c 	mvn.w	r0, #12
  401100:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
  401102:	f06f 0010 	mvn.w	r0, #16
}
  401106:	bd70      	pop	{r4, r5, r6, pc}
  401108:	00401065 	.word	0x00401065
  40110c:	00402c68 	.word	0x00402c68
  401110:	00400a95 	.word	0x00400a95
  401114:	feffff7c 	.word	0xfeffff7c
  401118:	fff1ff6f 	.word	0xfff1ff6f
  40111c:	000e0010 	.word	0x000e0010
  401120:	00402c54 	.word	0x00402c54

00401124 <_spi_m_sync_enable>:

	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_sync_enable(struct _spi_m_sync_dev *dev)
{
  401124:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
  401126:	4604      	mov	r4, r0
  401128:	b168      	cbz	r0, 401146 <_spi_m_sync_enable+0x22>
  40112a:	6803      	ldr	r3, [r0, #0]
  40112c:	b14b      	cbz	r3, 401142 <_spi_m_sync_enable+0x1e>
  40112e:	2001      	movs	r0, #1
  401130:	f44f 72b9 	mov.w	r2, #370	; 0x172
  401134:	4905      	ldr	r1, [pc, #20]	; (40114c <_spi_m_sync_enable+0x28>)
  401136:	4b06      	ldr	r3, [pc, #24]	; (401150 <_spi_m_sync_enable+0x2c>)
  401138:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
  40113a:	6820      	ldr	r0, [r4, #0]
  40113c:	4b05      	ldr	r3, [pc, #20]	; (401154 <_spi_m_sync_enable+0x30>)
  40113e:	4798      	blx	r3
}
  401140:	bd10      	pop	{r4, pc}
	ASSERT(dev && dev->prvt);
  401142:	2000      	movs	r0, #0
  401144:	e7f4      	b.n	401130 <_spi_m_sync_enable+0xc>
  401146:	2000      	movs	r0, #0
  401148:	e7f2      	b.n	401130 <_spi_m_sync_enable+0xc>
  40114a:	bf00      	nop
  40114c:	00402c68 	.word	0x00402c68
  401150:	00400a95 	.word	0x00400a95
  401154:	0040105d 	.word	0x0040105d

00401158 <_spi_m_sync_trans>:

	return ERR_NONE;
}

int32_t _spi_m_sync_trans(struct _spi_m_sync_dev *dev, const struct spi_msg *msg)
{
  401158:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40115c:	b086      	sub	sp, #24
  40115e:	4607      	mov	r7, r0
  401160:	460d      	mov	r5, r1
	void *                 hw   = dev->prvt;
  401162:	6804      	ldr	r4, [r0, #0]
	int32_t                rc   = 0;
	struct _spi_trans_ctrl ctrl = {msg->txbuf, msg->rxbuf, 0, 0, dev->char_size};
  401164:	680b      	ldr	r3, [r1, #0]
  401166:	9301      	str	r3, [sp, #4]
  401168:	684b      	ldr	r3, [r1, #4]
  40116a:	9302      	str	r3, [sp, #8]
  40116c:	2300      	movs	r3, #0
  40116e:	9303      	str	r3, [sp, #12]
  401170:	9304      	str	r3, [sp, #16]
  401172:	7903      	ldrb	r3, [r0, #4]
  401174:	f88d 3014 	strb.w	r3, [sp, #20]

	ASSERT(dev && hw);
  401178:	1c26      	adds	r6, r4, #0
  40117a:	bf18      	it	ne
  40117c:	2601      	movne	r6, #1
  40117e:	f240 2231 	movw	r2, #561	; 0x231
  401182:	4933      	ldr	r1, [pc, #204]	; (401250 <_spi_m_sync_trans+0xf8>)
  401184:	2800      	cmp	r0, #0
  401186:	bf0c      	ite	eq
  401188:	2000      	moveq	r0, #0
  40118a:	f006 0001 	andne.w	r0, r6, #1
  40118e:	4b31      	ldr	r3, [pc, #196]	; (401254 <_spi_m_sync_trans+0xfc>)
  401190:	4798      	blx	r3
	return (((Spi *)hw)->SPI_SR & SPI_SR_SPIENS) > 0;
  401192:	6923      	ldr	r3, [r4, #16]

	/* SPI must be enabled to start synchronous transfer */
	if (!hri_spi_get_SR_SPIENS_bit(hw)) {
  401194:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401198:	d122      	bne.n	4011e0 <_spi_m_sync_trans+0x88>
		return ERR_NOT_INITIALIZED;
  40119a:	f06f 0013 	mvn.w	r0, #19
  40119e:	e053      	b.n	401248 <_spi_m_sync_trans+0xf0>
		return false;
  4011a0:	2300      	movs	r3, #0
  4011a2:	e035      	b.n	401210 <_spi_m_sync_trans+0xb8>
			data |= (*ctrl->txbuf) << 8;
  4011a4:	7850      	ldrb	r0, [r2, #1]
  4011a6:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
			ctrl->txbuf++;
  4011aa:	3202      	adds	r2, #2
  4011ac:	9201      	str	r2, [sp, #4]
	ctrl->txcnt++;
  4011ae:	3301      	adds	r3, #1
  4011b0:	9303      	str	r3, [sp, #12]
}

static inline void hri_spi_write_TDR_reg(const void *const hw, hri_spi_tdr_reg_t data)
{
	SPI_CRITICAL_SECTION_ENTER();
	((Spi *)hw)->SPI_TDR = data;
  4011b2:	60e1      	str	r1, [r4, #12]
	return ((Spi *)hw)->SPI_SR;
  4011b4:	f8d4 8010 	ldr.w	r8, [r4, #16]
	ASSERT(hw);
  4011b8:	f240 2222 	movw	r2, #546	; 0x222
  4011bc:	4924      	ldr	r1, [pc, #144]	; (401250 <_spi_m_sync_trans+0xf8>)
  4011be:	4630      	mov	r0, r6
  4011c0:	4b24      	ldr	r3, [pc, #144]	; (401254 <_spi_m_sync_trans+0xfc>)
  4011c2:	4798      	blx	r3
	if (SPI_SR_OVRES & iflag) {
  4011c4:	f018 0f08 	tst.w	r8, #8
  4011c8:	d038      	beq.n	40123c <_spi_m_sync_trans+0xe4>
		return ERR_OVERFLOW;
  4011ca:	f06f 0012 	mvn.w	r0, #18
			if (ctrl.rxcnt >= ctrl.txcnt) {
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
			}
		}
		rc = _spi_err_check(hri_spi_read_SR_reg(hw), hw);
		if (rc < 0) {
  4011ce:	2800      	cmp	r0, #0
  4011d0:	db36      	blt.n	401240 <_spi_m_sync_trans+0xe8>
			break;
		}
		if (ctrl.txcnt >= msg->size && ctrl.rxcnt >= msg->size) {
  4011d2:	9803      	ldr	r0, [sp, #12]
  4011d4:	68ab      	ldr	r3, [r5, #8]
  4011d6:	4298      	cmp	r0, r3
  4011d8:	d302      	bcc.n	4011e0 <_spi_m_sync_trans+0x88>
  4011da:	9a04      	ldr	r2, [sp, #16]
  4011dc:	4293      	cmp	r3, r2
  4011de:	d92f      	bls.n	401240 <_spi_m_sync_trans+0xe8>
  4011e0:	6923      	ldr	r3, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_RDRF)) {
  4011e2:	f013 0f01 	tst.w	r3, #1
  4011e6:	d0db      	beq.n	4011a0 <_spi_m_sync_trans+0x48>
	return (((Spi *)hw)->SPI_RDR & SPI_RDR_RD_Msk) >> SPI_RDR_RD_Pos;
  4011e8:	68a3      	ldr	r3, [r4, #8]
  4011ea:	b29b      	uxth	r3, r3
	if (ctrl->rxbuf) {
  4011ec:	9a02      	ldr	r2, [sp, #8]
  4011ee:	b15a      	cbz	r2, 401208 <_spi_m_sync_trans+0xb0>
		*ctrl->rxbuf++ = (uint8_t)data;
  4011f0:	1c51      	adds	r1, r2, #1
  4011f2:	9102      	str	r1, [sp, #8]
  4011f4:	7013      	strb	r3, [r2, #0]
		if (ctrl->char_size > 1) {
  4011f6:	f89d 2014 	ldrb.w	r2, [sp, #20]
  4011fa:	2a01      	cmp	r2, #1
  4011fc:	d904      	bls.n	401208 <_spi_m_sync_trans+0xb0>
			*ctrl->rxbuf++ = (uint8_t)(data >> 8);
  4011fe:	460a      	mov	r2, r1
  401200:	3101      	adds	r1, #1
  401202:	9102      	str	r1, [sp, #8]
  401204:	0a1b      	lsrs	r3, r3, #8
  401206:	7013      	strb	r3, [r2, #0]
	ctrl->rxcnt++;
  401208:	9b04      	ldr	r3, [sp, #16]
  40120a:	3301      	adds	r3, #1
  40120c:	9304      	str	r3, [sp, #16]
	return true;
  40120e:	2301      	movs	r3, #1
		if (!_spi_rx_check_and_receive(hw, &ctrl)) {
  401210:	2b00      	cmp	r3, #0
  401212:	d1cf      	bne.n	4011b4 <_spi_m_sync_trans+0x5c>
			if (ctrl.rxcnt >= ctrl.txcnt) {
  401214:	9b03      	ldr	r3, [sp, #12]
  401216:	9a04      	ldr	r2, [sp, #16]
  401218:	429a      	cmp	r2, r3
  40121a:	d3cb      	bcc.n	4011b4 <_spi_m_sync_trans+0x5c>
				_spi_tx_check_and_send(hw, &ctrl, dev->dummy_byte);
  40121c:	88f9      	ldrh	r1, [r7, #6]
	return ((Spi *)hw)->SPI_SR;
  40121e:	6922      	ldr	r2, [r4, #16]
	if (!(hri_spi_read_SR_reg(hw) & SPI_SR_TDRE)) {
  401220:	f012 0f02 	tst.w	r2, #2
  401224:	d0c6      	beq.n	4011b4 <_spi_m_sync_trans+0x5c>
	if (ctrl->txbuf) {
  401226:	9a01      	ldr	r2, [sp, #4]
  401228:	2a00      	cmp	r2, #0
  40122a:	d0c0      	beq.n	4011ae <_spi_m_sync_trans+0x56>
		data = *ctrl->txbuf++;
  40122c:	1c51      	adds	r1, r2, #1
  40122e:	9101      	str	r1, [sp, #4]
  401230:	7811      	ldrb	r1, [r2, #0]
		if (ctrl->char_size > 1) {
  401232:	f89d 0014 	ldrb.w	r0, [sp, #20]
  401236:	2801      	cmp	r0, #1
  401238:	d8b4      	bhi.n	4011a4 <_spi_m_sync_trans+0x4c>
  40123a:	e7b8      	b.n	4011ae <_spi_m_sync_trans+0x56>
	return ERR_NONE;
  40123c:	2000      	movs	r0, #0
  40123e:	e7c6      	b.n	4011ce <_spi_m_sync_trans+0x76>
	tmp = ((Spi *)hw)->SPI_SR;
  401240:	6923      	ldr	r3, [r4, #16]
	while (!(hri_spi_get_SR_reg(hw, SPI_SR_TXEMPTY))) {
  401242:	f413 7f00 	tst.w	r3, #512	; 0x200
  401246:	d0fb      	beq.n	401240 <_spi_m_sync_trans+0xe8>

	/* Wait until SPI bus idle */
	_spi_wait_bus_idle(hw);

	return rc;
}
  401248:	b006      	add	sp, #24
  40124a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40124e:	bf00      	nop
  401250:	00402c68 	.word	0x00402c68
  401254:	00400a95 	.word	0x00400a95

00401258 <_spi_get_spi_m_sync>:
 * \brief Retrieve usart sync helper functions
 */
void *_spi_get_spi_m_sync(void)
{
	return (void *)NULL;
}
  401258:	2000      	movs	r0, #0
  40125a:	4770      	bx	lr

0040125c <_system_time_init>:
 * \brief Initialize system time module
 */
void _system_time_init(void *const hw)
{
	(void)hw;
	SysTick->LOAD = (0xFFFFFF << SysTick_LOAD_RELOAD_Pos);
  40125c:	4b03      	ldr	r3, [pc, #12]	; (40126c <_system_time_init+0x10>)
  40125e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
  401262:	605a      	str	r2, [r3, #4]
	SysTick->CTRL = (1 << SysTick_CTRL_ENABLE_Pos) | (CONF_SYSTICK_TICKINT << SysTick_CTRL_TICKINT_Pos)
  401264:	2205      	movs	r2, #5
  401266:	601a      	str	r2, [r3, #0]
  401268:	4770      	bx	lr
  40126a:	bf00      	nop
  40126c:	e000e010 	.word	0xe000e010

00401270 <_delay_init>:
}
/**
 * \brief Initialize delay functionality
 */
void _delay_init(void *const hw)
{
  401270:	b508      	push	{r3, lr}
	_system_time_init(hw);
  401272:	4b01      	ldr	r3, [pc, #4]	; (401278 <_delay_init+0x8>)
  401274:	4798      	blx	r3
  401276:	bd08      	pop	{r3, pc}
  401278:	0040125d 	.word	0x0040125d

0040127c <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
  40127c:	0e08      	lsrs	r0, r1, #24
	uint32_t buf = cycles;

	while (n--) {
  40127e:	e00d      	b.n	40129c <_delay_cycles+0x20>
		SysTick->LOAD = 0xFFFFFF;
  401280:	4b0d      	ldr	r3, [pc, #52]	; (4012b8 <_delay_cycles+0x3c>)
  401282:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
  401286:	6058      	str	r0, [r3, #4]
		SysTick->VAL  = 0xFFFFFF;
  401288:	6098      	str	r0, [r3, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  40128a:	4b0b      	ldr	r3, [pc, #44]	; (4012b8 <_delay_cycles+0x3c>)
  40128c:	681b      	ldr	r3, [r3, #0]
  40128e:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  401292:	d0fa      	beq.n	40128a <_delay_cycles+0xe>
			;
		buf -= 0xFFFFFF;
  401294:	f101 417f 	add.w	r1, r1, #4278190080	; 0xff000000
  401298:	3101      	adds	r1, #1
	while (n--) {
  40129a:	4610      	mov	r0, r2
  40129c:	1e43      	subs	r3, r0, #1
  40129e:	b2da      	uxtb	r2, r3
  4012a0:	2800      	cmp	r0, #0
  4012a2:	d1ed      	bne.n	401280 <_delay_cycles+0x4>
	}

	SysTick->LOAD = buf;
  4012a4:	4b04      	ldr	r3, [pc, #16]	; (4012b8 <_delay_cycles+0x3c>)
  4012a6:	6059      	str	r1, [r3, #4]
	SysTick->VAL  = buf;
  4012a8:	6099      	str	r1, [r3, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
  4012aa:	4b03      	ldr	r3, [pc, #12]	; (4012b8 <_delay_cycles+0x3c>)
  4012ac:	681b      	ldr	r3, [r3, #0]
  4012ae:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  4012b2:	d0fa      	beq.n	4012aa <_delay_cycles+0x2e>
		;
}
  4012b4:	4770      	bx	lr
  4012b6:	bf00      	nop
  4012b8:	e000e010 	.word	0xe000e010

004012bc <_get_i2cm_sync_cfg>:
 */
static const struct _i2cm_sync_cfg *_get_i2cm_sync_cfg(void *hw)
{
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  4012bc:	2300      	movs	r3, #0
  4012be:	b13b      	cbz	r3, 4012d0 <_get_i2cm_sync_cfg+0x14>
		if (_i2cm_sync_cfgs[i].hw == hw) {
			return &(_i2cm_sync_cfgs[i]);
		}
	}
	return NULL;
  4012c0:	2000      	movs	r0, #0
  4012c2:	4770      	bx	lr
			return &(_i2cm_sync_cfgs[i]);
  4012c4:	eb03 0443 	add.w	r4, r3, r3, lsl #1
  4012c8:	00e3      	lsls	r3, r4, #3
  4012ca:	4608      	mov	r0, r1
  4012cc:	4418      	add	r0, r3
  4012ce:	e00c      	b.n	4012ea <_get_i2cm_sync_cfg+0x2e>
{
  4012d0:	b410      	push	{r4}
		if (_i2cm_sync_cfgs[i].hw == hw) {
  4012d2:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  4012d6:	00ca      	lsls	r2, r1, #3
  4012d8:	4905      	ldr	r1, [pc, #20]	; (4012f0 <_get_i2cm_sync_cfg+0x34>)
  4012da:	588a      	ldr	r2, [r1, r2]
  4012dc:	4282      	cmp	r2, r0
  4012de:	d0f1      	beq.n	4012c4 <_get_i2cm_sync_cfg+0x8>
	for (i = 0; i < ARRAY_SIZE(_i2cm_sync_cfgs); i++) {
  4012e0:	3301      	adds	r3, #1
  4012e2:	b2db      	uxtb	r3, r3
  4012e4:	2b00      	cmp	r3, #0
  4012e6:	d0f4      	beq.n	4012d2 <_get_i2cm_sync_cfg+0x16>
	return NULL;
  4012e8:	2000      	movs	r0, #0
}
  4012ea:	f85d 4b04 	ldr.w	r4, [sp], #4
  4012ee:	4770      	bx	lr
  4012f0:	00402c80 	.word	0x00402c80

004012f4 <_i2c_m_sync_init>:

int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *const dev, void *const hw)
{
  4012f4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && hw);
  4012f6:	4604      	mov	r4, r0
  4012f8:	460d      	mov	r5, r1
  4012fa:	2800      	cmp	r0, #0
  4012fc:	bf18      	it	ne
  4012fe:	2900      	cmpne	r1, #0
  401300:	bf14      	ite	ne
  401302:	2001      	movne	r0, #1
  401304:	2000      	moveq	r0, #0
  401306:	2278      	movs	r2, #120	; 0x78
  401308:	4909      	ldr	r1, [pc, #36]	; (401330 <_i2c_m_sync_init+0x3c>)
  40130a:	4b0a      	ldr	r3, [pc, #40]	; (401334 <_i2c_m_sync_init+0x40>)
  40130c:	4798      	blx	r3

	const struct _i2cm_sync_cfg *cfg;

	dev->hw = hw;
  40130e:	6125      	str	r5, [r4, #16]
	cfg     = _get_i2cm_sync_cfg(dev->hw);
  401310:	4628      	mov	r0, r5
  401312:	4b09      	ldr	r3, [pc, #36]	; (401338 <_i2c_m_sync_init+0x44>)
  401314:	4798      	blx	r3

	// hri_twihs_write_CR_reg(hw, TWIHS_CR_SWRST);
	// hri_twihs_read_RHR_reg(hw);
	hri_twihs_write_CR_reg(dev->hw, cfg->ctrl);
  401316:	6843      	ldr	r3, [r0, #4]
}

static inline void hri_twihs_write_CR_reg(const void *const hw, hri_twihs_cr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_CR = data;
  401318:	602b      	str	r3, [r5, #0]
	hri_twihs_write_SMBTR_reg(dev->hw, cfg->smbtr);
  40131a:	6923      	ldr	r3, [r4, #16]
  40131c:	6882      	ldr	r2, [r0, #8]
	((Twihs *)hw)->TWIHS_SMBTR = data;
  40131e:	639a      	str	r2, [r3, #56]	; 0x38
	hri_twihs_write_FILTR_reg(dev->hw, cfg->filtr);
  401320:	6923      	ldr	r3, [r4, #16]
  401322:	68c2      	ldr	r2, [r0, #12]
	((Twihs *)hw)->TWIHS_FILTR = data;
  401324:	645a      	str	r2, [r3, #68]	; 0x44
	hri_twihs_write_CWGR_reg(dev->hw, cfg->cwgr);
  401326:	6923      	ldr	r3, [r4, #16]
  401328:	6902      	ldr	r2, [r0, #16]
	((Twihs *)hw)->TWIHS_CWGR = data;
  40132a:	611a      	str	r2, [r3, #16]

	return ERR_NONE;
}
  40132c:	2000      	movs	r0, #0
  40132e:	bd38      	pop	{r3, r4, r5, pc}
  401330:	00402c98 	.word	0x00402c98
  401334:	00400a95 	.word	0x00400a95
  401338:	004012bd 	.word	0x004012bd

0040133c <_i2c_m_sync_transfer>:

	return ERR_NONE;
}

int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
  40133c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev && msg);
  40133e:	4604      	mov	r4, r0
  401340:	460d      	mov	r5, r1
  401342:	2800      	cmp	r0, #0
  401344:	bf18      	it	ne
  401346:	2900      	cmpne	r1, #0
  401348:	bf14      	ite	ne
  40134a:	2001      	movne	r0, #1
  40134c:	2000      	moveq	r0, #0
  40134e:	22ba      	movs	r2, #186	; 0xba
  401350:	4952      	ldr	r1, [pc, #328]	; (40149c <_i2c_m_sync_transfer+0x160>)
  401352:	4b53      	ldr	r3, [pc, #332]	; (4014a0 <_i2c_m_sync_transfer+0x164>)
  401354:	4798      	blx	r3

	if (dev->service.msg.flags & I2C_M_BUSY) {
  401356:	8863      	ldrh	r3, [r4, #2]
  401358:	f413 7f80 	tst.w	r3, #256	; 0x100
  40135c:	f040 809a 	bne.w	401494 <_i2c_m_sync_transfer+0x158>
		return I2C_ERR_BUSY;
	}

	if (msg->flags & I2C_M_RD) {
  401360:	886b      	ldrh	r3, [r5, #2]
  401362:	f013 0f01 	tst.w	r3, #1
  401366:	d118      	bne.n	40139a <_i2c_m_sync_transfer+0x5e>
{
	uint32_t i;
	uint32_t sr;
	int      ret = ERR_NONE;

	msg->flags |= I2C_M_BUSY;
  401368:	886b      	ldrh	r3, [r5, #2]
  40136a:	b29b      	uxth	r3, r3
  40136c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  401370:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  401372:	882b      	ldrh	r3, [r5, #0]
  401374:	f413 6f80 	tst.w	r3, #1024	; 0x400
  401378:	d05f      	beq.n	40143a <_i2c_m_sync_transfer+0xfe>
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1));
  40137a:	6922      	ldr	r2, [r4, #16]
  40137c:	0a1b      	lsrs	r3, r3, #8
  40137e:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  401382:	041b      	lsls	r3, r3, #16
  401384:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  401388:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	((Twihs *)hw)->TWIHS_MMR = data;
  40138c:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  40138e:	6923      	ldr	r3, [r4, #16]
  401390:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  401392:	60da      	str	r2, [r3, #12]
	for (i = 0; i < msg->len; i++) {
		/* Wait for data is transferred from TWIHS_THR or if NACK is detected */
		do {
			sr = hri_twihs_read_SR_reg(dev->hw);
			if (sr & TWIHS_SR_NACK) {
				ret = I2C_NACK;
  401394:	2000      	movs	r0, #0
  401396:	4601      	mov	r1, r0
  401398:	e05c      	b.n	401454 <_i2c_m_sync_transfer+0x118>

static inline int32_t _i2c_m_sync_read(struct _i2c_m_sync_device *const dev, struct _i2c_m_msg *msg)
{
	uint32_t i;

	msg->flags |= I2C_M_BUSY;
  40139a:	886b      	ldrh	r3, [r5, #2]
  40139c:	b29b      	uxth	r3, r3
  40139e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  4013a2:	806b      	strh	r3, [r5, #2]

	if (msg->addr & I2C_M_TEN) {
  4013a4:	882b      	ldrh	r3, [r5, #0]
  4013a6:	f413 6f80 	tst.w	r3, #1024	; 0x400
  4013aa:	d022      	beq.n	4013f2 <_i2c_m_sync_transfer+0xb6>
		hri_twihs_write_MMR_reg(dev->hw,
  4013ac:	6922      	ldr	r2, [r4, #16]
		                        TWIHS_MMR_DADR(0x78 | (msg->addr >> 8)) | TWIHS_MMR_IADRSZ(1) | TWIHS_MMR_MREAD);
  4013ae:	0a1b      	lsrs	r3, r3, #8
  4013b0:	f043 0378 	orr.w	r3, r3, #120	; 0x78
  4013b4:	041b      	lsls	r3, r3, #16
  4013b6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  4013ba:	f443 5388 	orr.w	r3, r3, #4352	; 0x1100
	((Twihs *)hw)->TWIHS_MMR = data;
  4013be:	6053      	str	r3, [r2, #4]
		hri_twihs_write_IADR_reg(dev->hw, msg->addr & 0xff);
  4013c0:	6923      	ldr	r3, [r4, #16]
  4013c2:	782a      	ldrb	r2, [r5, #0]
	((Twihs *)hw)->TWIHS_IADR = data;
  4013c4:	60da      	str	r2, [r3, #12]
	} else {
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
	}
	/* In single data byte master read, the START and STOP must both be set */
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  4013c6:	6923      	ldr	r3, [r4, #16]
  4013c8:	686a      	ldr	r2, [r5, #4]
  4013ca:	2a01      	cmp	r2, #1
  4013cc:	d019      	beq.n	401402 <_i2c_m_sync_transfer+0xc6>
  4013ce:	2201      	movs	r2, #1
	((Twihs *)hw)->TWIHS_CR = data;
  4013d0:	601a      	str	r2, [r3, #0]

	for (i = 0; i < msg->len; i++) {
  4013d2:	2100      	movs	r1, #0
  4013d4:	686b      	ldr	r3, [r5, #4]
  4013d6:	4299      	cmp	r1, r3
  4013d8:	d222      	bcs.n	401420 <_i2c_m_sync_transfer+0xe4>
		/* Wait for a byte has been received in TWIHS_RHR since last read */
		while (!hri_twihs_get_SR_RXRDY_bit(dev->hw)) {
  4013da:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_RXRDY) > 0;
  4013dc:	6a1a      	ldr	r2, [r3, #32]
  4013de:	f012 0f02 	tst.w	r2, #2
  4013e2:	d110      	bne.n	401406 <_i2c_m_sync_transfer+0xca>
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_NACK) > 0;
  4013e4:	6a1b      	ldr	r3, [r3, #32]
			/* Check whether slave acknowledge received after the address byte */
			if (hri_twihs_get_SR_NACK_bit(dev->hw))
  4013e6:	f413 7f80 	tst.w	r3, #256	; 0x100
  4013ea:	d0f6      	beq.n	4013da <_i2c_m_sync_transfer+0x9e>
				return I2C_NACK;
  4013ec:	f06f 0001 	mvn.w	r0, #1
		return _i2c_m_sync_read(dev, msg);
  4013f0:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr) | TWIHS_MMR_MREAD);
  4013f2:	6922      	ldr	r2, [r4, #16]
  4013f4:	041b      	lsls	r3, r3, #16
  4013f6:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
  4013fa:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
	((Twihs *)hw)->TWIHS_MMR = data;
  4013fe:	6053      	str	r3, [r2, #4]
  401400:	e7e1      	b.n	4013c6 <_i2c_m_sync_transfer+0x8a>
	hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_START | ((msg->len == 1) ? TWIHS_CR_STOP : 0));
  401402:	2203      	movs	r2, #3
  401404:	e7e4      	b.n	4013d0 <_i2c_m_sync_transfer+0x94>
		};

		msg->buffer[i] = hri_twihs_read_RHR_reg(dev->hw);
  401406:	68aa      	ldr	r2, [r5, #8]
	return ((Twihs *)hw)->TWIHS_RHR;
  401408:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40140a:	5453      	strb	r3, [r2, r1]
		/* In multiple data bytes master read, the STOP must be set after the
		 * last data received but one */
		if (i == (msg->len - 2)) {
  40140c:	686b      	ldr	r3, [r5, #4]
  40140e:	3b02      	subs	r3, #2
  401410:	4299      	cmp	r1, r3
  401412:	d001      	beq.n	401418 <_i2c_m_sync_transfer+0xdc>
	for (i = 0; i < msg->len; i++) {
  401414:	3101      	adds	r1, #1
  401416:	e7dd      	b.n	4013d4 <_i2c_m_sync_transfer+0x98>
			hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401418:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  40141a:	2202      	movs	r2, #2
  40141c:	601a      	str	r2, [r3, #0]
  40141e:	e7f9      	b.n	401414 <_i2c_m_sync_transfer+0xd8>
		}
	}

	while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401420:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  401422:	6a1b      	ldr	r3, [r3, #32]
  401424:	f013 0f01 	tst.w	r3, #1
  401428:	d0fa      	beq.n	401420 <_i2c_m_sync_transfer+0xe4>
	};
	dev->service.msg.flags &= ~I2C_M_BUSY;
  40142a:	8863      	ldrh	r3, [r4, #2]
  40142c:	b29b      	uxth	r3, r3
  40142e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  401432:	b29b      	uxth	r3, r3
  401434:	8063      	strh	r3, [r4, #2]

	return ERR_NONE;
  401436:	2000      	movs	r0, #0
  401438:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_MMR_reg(dev->hw, TWIHS_MMR_DADR(msg->addr));
  40143a:	6922      	ldr	r2, [r4, #16]
  40143c:	041b      	lsls	r3, r3, #16
  40143e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
	((Twihs *)hw)->TWIHS_MMR = data;
  401442:	6053      	str	r3, [r2, #4]
  401444:	e7a6      	b.n	401394 <_i2c_m_sync_transfer+0x58>
				ret = I2C_NACK;
  401446:	f06f 0001 	mvn.w	r0, #1
		if (ret != ERR_NONE)
  40144a:	b978      	cbnz	r0, 40146c <_i2c_m_sync_transfer+0x130>
		hri_twihs_write_THR_reg(dev->hw, msg->buffer[i]);
  40144c:	68ab      	ldr	r3, [r5, #8]
  40144e:	5c5b      	ldrb	r3, [r3, r1]
}

static inline void hri_twihs_write_THR_reg(const void *const hw, hri_twihs_thr_reg_t data)
{
	TWIHS_CRITICAL_SECTION_ENTER();
	((Twihs *)hw)->TWIHS_THR = data;
  401450:	6353      	str	r3, [r2, #52]	; 0x34
	for (i = 0; i < msg->len; i++) {
  401452:	3101      	adds	r1, #1
  401454:	686b      	ldr	r3, [r5, #4]
  401456:	4299      	cmp	r1, r3
  401458:	d208      	bcs.n	40146c <_i2c_m_sync_transfer+0x130>
			sr = hri_twihs_read_SR_reg(dev->hw);
  40145a:	6922      	ldr	r2, [r4, #16]
	return ((Twihs *)hw)->TWIHS_SR;
  40145c:	6a13      	ldr	r3, [r2, #32]
			if (sr & TWIHS_SR_NACK) {
  40145e:	f413 7f80 	tst.w	r3, #256	; 0x100
  401462:	d1f0      	bne.n	401446 <_i2c_m_sync_transfer+0x10a>
		} while (!(sr & TWIHS_SR_TXRDY));
  401464:	f013 0f04 	tst.w	r3, #4
  401468:	d0f7      	beq.n	40145a <_i2c_m_sync_transfer+0x11e>
  40146a:	e7ee      	b.n	40144a <_i2c_m_sync_transfer+0x10e>
	if (msg->flags & I2C_M_STOP) {
  40146c:	886b      	ldrh	r3, [r5, #2]
  40146e:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  401472:	d106      	bne.n	401482 <_i2c_m_sync_transfer+0x146>
	dev->service.msg.flags &= ~I2C_M_BUSY;
  401474:	8863      	ldrh	r3, [r4, #2]
  401476:	b29b      	uxth	r3, r3
  401478:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  40147c:	b29b      	uxth	r3, r3
  40147e:	8063      	strh	r3, [r4, #2]
		return _i2c_m_sync_write(dev, msg);
  401480:	bd38      	pop	{r3, r4, r5, pc}
		hri_twihs_write_CR_reg(dev->hw, TWIHS_CR_STOP);
  401482:	6923      	ldr	r3, [r4, #16]
	((Twihs *)hw)->TWIHS_CR = data;
  401484:	2202      	movs	r2, #2
  401486:	601a      	str	r2, [r3, #0]
		while (!hri_twihs_get_SR_TXCOMP_bit(dev->hw)) {
  401488:	6923      	ldr	r3, [r4, #16]
	return (((Twihs *)hw)->TWIHS_SR & TWIHS_SR_TXCOMP) > 0;
  40148a:	6a1b      	ldr	r3, [r3, #32]
  40148c:	f013 0f01 	tst.w	r3, #1
  401490:	d0fa      	beq.n	401488 <_i2c_m_sync_transfer+0x14c>
  401492:	e7ef      	b.n	401474 <_i2c_m_sync_transfer+0x138>
		return I2C_ERR_BUSY;
  401494:	f06f 0005 	mvn.w	r0, #5
}
  401498:	bd38      	pop	{r3, r4, r5, pc}
  40149a:	bf00      	nop
  40149c:	00402c98 	.word	0x00402c98
  4014a0:	00400a95 	.word	0x00400a95

004014a4 <_usart_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given usart hardware instance
 */
static uint8_t _usart_get_hardware_index(const void *const hw)
{
  4014a4:	b510      	push	{r4, lr}
	ASSERT(hw);
  4014a6:	4604      	mov	r4, r0
  4014a8:	f240 222b 	movw	r2, #555	; 0x22b
  4014ac:	4905      	ldr	r1, [pc, #20]	; (4014c4 <_usart_get_hardware_index+0x20>)
  4014ae:	3000      	adds	r0, #0
  4014b0:	bf18      	it	ne
  4014b2:	2001      	movne	r0, #1
  4014b4:	4b04      	ldr	r3, [pc, #16]	; (4014c8 <_usart_get_hardware_index+0x24>)
  4014b6:	4798      	blx	r3

#ifdef _UNIT_TEST_
	return ((uint32_t)hw - (uint32_t)USART0) / sizeof(Usart);
#endif

	return ((uint32_t)hw - (uint32_t)USART0) >> 14;
  4014b8:	4804      	ldr	r0, [pc, #16]	; (4014cc <_usart_get_hardware_index+0x28>)
  4014ba:	4420      	add	r0, r4
}
  4014bc:	f3c0 3087 	ubfx	r0, r0, #14, #8
  4014c0:	bd10      	pop	{r4, pc}
  4014c2:	bf00      	nop
  4014c4:	00402cc0 	.word	0x00402cc0
  4014c8:	00400a95 	.word	0x00400a95
  4014cc:	bffdc000 	.word	0xbffdc000

004014d0 <_get_usart_index>:
 * \param[in] hw The pointer to hardware instance

 * \return The ordinal number of the given usart hardware instance
 */
static uint8_t _get_usart_index(const void *const hw)
{
  4014d0:	b510      	push	{r4, lr}
	ASSERT(hw);
  4014d2:	4604      	mov	r4, r0
  4014d4:	f240 2287 	movw	r2, #647	; 0x287
  4014d8:	490e      	ldr	r1, [pc, #56]	; (401514 <_get_usart_index+0x44>)
  4014da:	3000      	adds	r0, #0
  4014dc:	bf18      	it	ne
  4014de:	2001      	movne	r0, #1
  4014e0:	4b0d      	ldr	r3, [pc, #52]	; (401518 <_get_usart_index+0x48>)
  4014e2:	4798      	blx	r3
	uint8_t usart_offset = _usart_get_hardware_index(hw);
  4014e4:	4620      	mov	r0, r4
  4014e6:	4b0d      	ldr	r3, [pc, #52]	; (40151c <_get_usart_index+0x4c>)
  4014e8:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  4014ea:	2300      	movs	r3, #0
  4014ec:	b143      	cbz	r3, 401500 <_get_usart_index+0x30>
		if (_usarts[i].number == usart_offset) {
			return i;
		}
	}

	ASSERT(false);
  4014ee:	f240 2291 	movw	r2, #657	; 0x291
  4014f2:	4908      	ldr	r1, [pc, #32]	; (401514 <_get_usart_index+0x44>)
  4014f4:	2000      	movs	r0, #0
  4014f6:	4b08      	ldr	r3, [pc, #32]	; (401518 <_get_usart_index+0x48>)
  4014f8:	4798      	blx	r3
	return 0;
  4014fa:	2300      	movs	r3, #0
}
  4014fc:	4618      	mov	r0, r3
  4014fe:	bd10      	pop	{r4, pc}
		if (_usarts[i].number == usart_offset) {
  401500:	eb03 0143 	add.w	r1, r3, r3, lsl #1
  401504:	008a      	lsls	r2, r1, #2
  401506:	4906      	ldr	r1, [pc, #24]	; (401520 <_get_usart_index+0x50>)
  401508:	5c8a      	ldrb	r2, [r1, r2]
  40150a:	4290      	cmp	r0, r2
  40150c:	d0f6      	beq.n	4014fc <_get_usart_index+0x2c>
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
  40150e:	3301      	adds	r3, #1
  401510:	b2db      	uxtb	r3, r3
  401512:	e7eb      	b.n	4014ec <_get_usart_index+0x1c>
  401514:	00402cc0 	.word	0x00402cc0
  401518:	00400a95 	.word	0x00400a95
  40151c:	004014a5 	.word	0x004014a5
  401520:	00402cb4 	.word	0x00402cb4

00401524 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
  401524:	b510      	push	{r4, lr}
	ASSERT(hw);
  401526:	4604      	mov	r4, r0
  401528:	f240 229e 	movw	r2, #670	; 0x29e
  40152c:	4911      	ldr	r1, [pc, #68]	; (401574 <_usart_init+0x50>)
  40152e:	3000      	adds	r0, #0
  401530:	bf18      	it	ne
  401532:	2001      	movne	r0, #1
  401534:	4b10      	ldr	r3, [pc, #64]	; (401578 <_usart_init+0x54>)
  401536:	4798      	blx	r3
	uint8_t i = _get_usart_index(hw);
  401538:	4620      	mov	r0, r4
  40153a:	4b10      	ldr	r3, [pc, #64]	; (40157c <_usart_init+0x58>)
  40153c:	4798      	blx	r3
}

static inline void hri_usart_write_US_WPMR_reg(const void *const hw, hri_usart_us_wpmr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_WPMR = data;
  40153e:	4b10      	ldr	r3, [pc, #64]	; (401580 <_usart_init+0x5c>)
  401540:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	((Usart *)hw)->US_MR = data;
  401544:	2300      	movs	r3, #0
  401546:	6063      	str	r3, [r4, #4]
	((Usart *)hw)->US_RTOR = data;
  401548:	6263      	str	r3, [r4, #36]	; 0x24
	((Usart *)hw)->US_TTGR = data;
  40154a:	62a3      	str	r3, [r4, #40]	; 0x28
}

static inline void hri_usart_write_US_CR_reg(const void *const hw, hri_usart_us_cr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_CR = data;
  40154c:	22ac      	movs	r2, #172	; 0xac
  40154e:	6022      	str	r2, [r4, #0]
  401550:	f44f 7280 	mov.w	r2, #256	; 0x100
  401554:	6022      	str	r2, [r4, #0]
  401556:	f44f 2200 	mov.w	r2, #524288	; 0x80000
  40155a:	6022      	str	r2, [r4, #0]
	/* Reset status bits. */
	hri_usart_write_US_CR_reg(hw, US_CR_RSTSTA);
	/* Turn off RTS and DTR if exist. */
	hri_usart_write_US_CR_reg(hw, US_CR_USART_RTSDIS);

	hri_usart_write_US_MR_reg(hw, _usarts[i].us_mr);
  40155c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
  401560:	0081      	lsls	r1, r0, #2
  401562:	4a08      	ldr	r2, [pc, #32]	; (401584 <_usart_init+0x60>)
  401564:	440a      	add	r2, r1
  401566:	6852      	ldr	r2, [r2, #4]
	((Usart *)hw)->US_MR = data;
  401568:	6062      	str	r2, [r4, #4]
	((Usart *)hw)->US_BRGR = data;
  40156a:	4a07      	ldr	r2, [pc, #28]	; (401588 <_usart_init+0x64>)
  40156c:	6222      	str	r2, [r4, #32]
	hri_usart_write_US_BRGR_reg(hw, _usarts[i].us_brgr);

	return ERR_NONE;
}
  40156e:	4618      	mov	r0, r3
  401570:	bd10      	pop	{r4, pc}
  401572:	bf00      	nop
  401574:	00402cc0 	.word	0x00402cc0
  401578:	00400a95 	.word	0x00400a95
  40157c:	004014d1 	.word	0x004014d1
  401580:	55534100 	.word	0x55534100
  401584:	00402cb4 	.word	0x00402cb4
  401588:	000100f4 	.word	0x000100f4

0040158c <_usart_sync_init>:
{
  40158c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40158e:	460c      	mov	r4, r1
	ASSERT(device);
  401590:	4e09      	ldr	r6, [pc, #36]	; (4015b8 <_usart_sync_init+0x2c>)
  401592:	4607      	mov	r7, r0
  401594:	22bd      	movs	r2, #189	; 0xbd
  401596:	4631      	mov	r1, r6
  401598:	3000      	adds	r0, #0
  40159a:	bf18      	it	ne
  40159c:	2001      	movne	r0, #1
  40159e:	4d07      	ldr	r5, [pc, #28]	; (4015bc <_usart_sync_init+0x30>)
  4015a0:	47a8      	blx	r5
	ASSERT(hw);
  4015a2:	22be      	movs	r2, #190	; 0xbe
  4015a4:	4631      	mov	r1, r6
  4015a6:	1c20      	adds	r0, r4, #0
  4015a8:	bf18      	it	ne
  4015aa:	2001      	movne	r0, #1
  4015ac:	47a8      	blx	r5
	device->hw = hw;
  4015ae:	603c      	str	r4, [r7, #0]
	return _usart_init(hw);
  4015b0:	4620      	mov	r0, r4
  4015b2:	4b03      	ldr	r3, [pc, #12]	; (4015c0 <_usart_sync_init+0x34>)
  4015b4:	4798      	blx	r3
}
  4015b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4015b8:	00402cc0 	.word	0x00402cc0
  4015bc:	00400a95 	.word	0x00400a95
  4015c0:	00401525 	.word	0x00401525

004015c4 <_usart_sync_enable>:
{
  4015c4:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
  4015c6:	4e0a      	ldr	r6, [pc, #40]	; (4015f0 <_usart_sync_enable+0x2c>)
  4015c8:	4604      	mov	r4, r0
  4015ca:	f240 1205 	movw	r2, #261	; 0x105
  4015ce:	4631      	mov	r1, r6
  4015d0:	3000      	adds	r0, #0
  4015d2:	bf18      	it	ne
  4015d4:	2001      	movne	r0, #1
  4015d6:	4d07      	ldr	r5, [pc, #28]	; (4015f4 <_usart_sync_enable+0x30>)
  4015d8:	47a8      	blx	r5
	_usart_enable(device->hw);
  4015da:	6824      	ldr	r4, [r4, #0]
 *
 * \param[in] hw The pointer to hardware instance
 */
static inline void _usart_enable(void *const hw)
{
	ASSERT(hw);
  4015dc:	f240 22c7 	movw	r2, #711	; 0x2c7
  4015e0:	4631      	mov	r1, r6
  4015e2:	1c20      	adds	r0, r4, #0
  4015e4:	bf18      	it	ne
  4015e6:	2001      	movne	r0, #1
  4015e8:	47a8      	blx	r5
	((Usart *)hw)->US_CR = data;
  4015ea:	2350      	movs	r3, #80	; 0x50
  4015ec:	6023      	str	r3, [r4, #0]
  4015ee:	bd70      	pop	{r4, r5, r6, pc}
  4015f0:	00402cc0 	.word	0x00402cc0
  4015f4:	00400a95 	.word	0x00400a95

004015f8 <_usart_sync_write_byte>:
{
  4015f8:	b538      	push	{r3, r4, r5, lr}
  4015fa:	460c      	mov	r4, r1
	ASSERT(device);
  4015fc:	4605      	mov	r5, r0
  4015fe:	f44f 72d4 	mov.w	r2, #424	; 0x1a8
  401602:	4904      	ldr	r1, [pc, #16]	; (401614 <_usart_sync_write_byte+0x1c>)
  401604:	3000      	adds	r0, #0
  401606:	bf18      	it	ne
  401608:	2001      	movne	r0, #1
  40160a:	4b03      	ldr	r3, [pc, #12]	; (401618 <_usart_sync_write_byte+0x20>)
  40160c:	4798      	blx	r3
	hri_usart_write_US_THR_reg(device->hw, (hri_usart_us_thr_reg_t)data);
  40160e:	682b      	ldr	r3, [r5, #0]
}

static inline void hri_usart_write_US_THR_reg(const void *const hw, hri_usart_us_thr_reg_t data)
{
	USART_CRITICAL_SECTION_ENTER();
	((Usart *)hw)->US_THR = data;
  401610:	61dc      	str	r4, [r3, #28]
  401612:	bd38      	pop	{r3, r4, r5, pc}
  401614:	00402cc0 	.word	0x00402cc0
  401618:	00400a95 	.word	0x00400a95

0040161c <_usart_sync_read_byte>:
{
  40161c:	b510      	push	{r4, lr}
	ASSERT(device);
  40161e:	4604      	mov	r4, r0
  401620:	f44f 72dd 	mov.w	r2, #442	; 0x1ba
  401624:	4904      	ldr	r1, [pc, #16]	; (401638 <_usart_sync_read_byte+0x1c>)
  401626:	3000      	adds	r0, #0
  401628:	bf18      	it	ne
  40162a:	2001      	movne	r0, #1
  40162c:	4b03      	ldr	r3, [pc, #12]	; (40163c <_usart_sync_read_byte+0x20>)
  40162e:	4798      	blx	r3
	return (uint8_t)(hri_usart_read_US_RHR_reg(device->hw) & 0xff);
  401630:	6823      	ldr	r3, [r4, #0]
	return ((Usart *)hw)->US_RHR;
  401632:	6998      	ldr	r0, [r3, #24]
}
  401634:	b2c0      	uxtb	r0, r0
  401636:	bd10      	pop	{r4, pc}
  401638:	00402cc0 	.word	0x00402cc0
  40163c:	00400a95 	.word	0x00400a95

00401640 <_usart_sync_is_ready_to_send>:
{
  401640:	b510      	push	{r4, lr}
	ASSERT(device);
  401642:	4604      	mov	r4, r0
  401644:	f240 12c3 	movw	r2, #451	; 0x1c3
  401648:	4905      	ldr	r1, [pc, #20]	; (401660 <_usart_sync_is_ready_to_send+0x20>)
  40164a:	3000      	adds	r0, #0
  40164c:	bf18      	it	ne
  40164e:	2001      	movne	r0, #1
  401650:	4b04      	ldr	r3, [pc, #16]	; (401664 <_usart_sync_is_ready_to_send+0x24>)
  401652:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXRDY_bit(device->hw);
  401654:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXRDY) > 0;
  401656:	6958      	ldr	r0, [r3, #20]
}
  401658:	f3c0 0040 	ubfx	r0, r0, #1, #1
  40165c:	bd10      	pop	{r4, pc}
  40165e:	bf00      	nop
  401660:	00402cc0 	.word	0x00402cc0
  401664:	00400a95 	.word	0x00400a95

00401668 <_usart_sync_is_transmit_done>:
{
  401668:	b510      	push	{r4, lr}
	ASSERT(device);
  40166a:	4604      	mov	r4, r0
  40166c:	f44f 72e6 	mov.w	r2, #460	; 0x1cc
  401670:	4905      	ldr	r1, [pc, #20]	; (401688 <_usart_sync_is_transmit_done+0x20>)
  401672:	3000      	adds	r0, #0
  401674:	bf18      	it	ne
  401676:	2001      	movne	r0, #1
  401678:	4b04      	ldr	r3, [pc, #16]	; (40168c <_usart_sync_is_transmit_done+0x24>)
  40167a:	4798      	blx	r3
	return hri_usart_get_US_CSR_TXEMPTY_bit(device->hw);
  40167c:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_TXEMPTY) > 0;
  40167e:	6958      	ldr	r0, [r3, #20]
}
  401680:	f3c0 2040 	ubfx	r0, r0, #9, #1
  401684:	bd10      	pop	{r4, pc}
  401686:	bf00      	nop
  401688:	00402cc0 	.word	0x00402cc0
  40168c:	00400a95 	.word	0x00400a95

00401690 <_usart_sync_is_byte_received>:
{
  401690:	b510      	push	{r4, lr}
	ASSERT(device);
  401692:	4604      	mov	r4, r0
  401694:	f44f 72ef 	mov.w	r2, #478	; 0x1de
  401698:	4905      	ldr	r1, [pc, #20]	; (4016b0 <_usart_sync_is_byte_received+0x20>)
  40169a:	3000      	adds	r0, #0
  40169c:	bf18      	it	ne
  40169e:	2001      	movne	r0, #1
  4016a0:	4b04      	ldr	r3, [pc, #16]	; (4016b4 <_usart_sync_is_byte_received+0x24>)
  4016a2:	4798      	blx	r3
	return hri_usart_get_US_CSR_RXRDY_bit(device->hw);
  4016a4:	6823      	ldr	r3, [r4, #0]
	return (((Usart *)hw)->US_CSR & US_CSR_RXRDY) > 0;
  4016a6:	6958      	ldr	r0, [r3, #20]
  4016a8:	f000 0001 	and.w	r0, r0, #1
}
  4016ac:	bd10      	pop	{r4, pc}
  4016ae:	bf00      	nop
  4016b0:	00402cc0 	.word	0x00402cc0
  4016b4:	00400a95 	.word	0x00400a95

004016b8 <_usart_get_usart_sync>:
}
  4016b8:	2000      	movs	r0, #0
  4016ba:	4770      	bx	lr

004016bc <set_pwm_channel>:

//sets duty cycle / period of a specified PWM channel on a specified instance
//use Atmel start to configure both instances
//channel may be from 0-3
void set_pwm_channel(struct _pwm_device *const device, uint8_t channel, uint32_t duty_cycle){
	if((channel < 4) && (channel >= 0)){
  4016bc:	2903      	cmp	r1, #3
  4016be:	d80d      	bhi.n	4016dc <set_pwm_channel+0x20>
void set_pwm_channel(struct _pwm_device *const device, uint8_t channel, uint32_t duty_cycle){
  4016c0:	b410      	push	{r4}
		hri_pwm_write_CPRDUPD_reg(device->hw, channel, PWM_PERIOD); //set period for channel
  4016c2:	6903      	ldr	r3, [r0, #16]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CPRDUPD = data;
  4016c4:	0149      	lsls	r1, r1, #5
  4016c6:	440b      	add	r3, r1
  4016c8:	f44f 7437 	mov.w	r4, #732	; 0x2dc
  4016cc:	f8c3 4210 	str.w	r4, [r3, #528]	; 0x210
		hri_pwm_write_CDTYUPD_reg(device->hw, channel, duty_cycle); //set duty-cycle for channel
  4016d0:	6903      	ldr	r3, [r0, #16]
	((Pwm *)hw)->PwmChNum[submodule_index].PWM_CDTYUPD = data;
  4016d2:	4419      	add	r1, r3
  4016d4:	f8c1 2208 	str.w	r2, [r1, #520]	; 0x208
	}
}
  4016d8:	f85d 4b04 	ldr.w	r4, [sp], #4
  4016dc:	4770      	bx	lr
	...

004016e0 <set_pmw_motor_0>:

/*
 * Functions for each individual motor for sake of processing time.
*/
//motor 0
void set_pmw_motor_0(struct _pwm_device *const device, uint32_t duty_cycle){
  4016e0:	b508      	push	{r3, lr}
	set_pwm_channel(device, CHANNEL_0, duty_cycle);
  4016e2:	460a      	mov	r2, r1
  4016e4:	2100      	movs	r1, #0
  4016e6:	4b01      	ldr	r3, [pc, #4]	; (4016ec <set_pmw_motor_0+0xc>)
  4016e8:	4798      	blx	r3
  4016ea:	bd08      	pop	{r3, pc}
  4016ec:	004016bd 	.word	0x004016bd

004016f0 <main>:
}

int main(void)
{
  4016f0:	b510      	push	{r4, lr}
  4016f2:	b088      	sub	sp, #32
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  4016f4:	4b16      	ldr	r3, [pc, #88]	; (401750 <main+0x60>)
  4016f6:	4798      	blx	r3
	
	/*Initialize the IMU, making sure to pass in the address of the start of the float array that will hold the quaternion coefficients*/
	
	//init_IMU(&imu_vector_buffer[0]);
	
	nRF24_init();
  4016f8:	4b16      	ldr	r3, [pc, #88]	; (401754 <main+0x64>)
  4016fa:	4798      	blx	r3
	delay_us(200); //Should be 200 us, setting higher for testing
  4016fc:	20c8      	movs	r0, #200	; 0xc8
  4016fe:	4b16      	ldr	r3, [pc, #88]	; (401758 <main+0x68>)
  401700:	4798      	blx	r3
	nRF24_enter_receive();
  401702:	4b16      	ldr	r3, [pc, #88]	; (40175c <main+0x6c>)
  401704:	4798      	blx	r3
	
	uint8_t data_store[32];
	memset(&data_store[0], 0, sizeof(uint8_t)*32);
  401706:	2220      	movs	r2, #32
  401708:	2100      	movs	r1, #0
  40170a:	4668      	mov	r0, sp
  40170c:	4b14      	ldr	r3, [pc, #80]	; (401760 <main+0x70>)
  40170e:	4798      	blx	r3
	pwm_enable(&PWM_0);
  401710:	4c14      	ldr	r4, [pc, #80]	; (401764 <main+0x74>)
  401712:	4620      	mov	r0, r4
  401714:	4b14      	ldr	r3, [pc, #80]	; (401768 <main+0x78>)
  401716:	4798      	blx	r3
	set_pmw_motor_0(&(PWM_0.device), 4);
  401718:	2104      	movs	r1, #4
  40171a:	4620      	mov	r0, r4
  40171c:	4b13      	ldr	r3, [pc, #76]	; (40176c <main+0x7c>)
  40171e:	4798      	blx	r3
		IMU quaternion coefficient updates (only relevant for the demo code, in reality it doesn't matter if we miss new updates, as we
		should only fetch when needed, regardless of whether we have missed some or not), while being slow enough that we aren't asking the
		IMU for new quaternion coefficients before it is ready with the next set of them. (also really only relevant for the demo code, in
		reality it doesn't matter if we ask for coefficients before the IMU is ready with new ones, as the function will just return the last
		valid coefficients it collected in the event that the IMU isn't ready with new ones) */
		if(nRF_24_is_data_available(1)){ //There is data for me to collect :)
  401720:	2001      	movs	r0, #1
  401722:	4b13      	ldr	r3, [pc, #76]	; (401770 <main+0x80>)
  401724:	4798      	blx	r3
  401726:	2800      	cmp	r0, #0
  401728:	d0fa      	beq.n	401720 <main+0x30>
			nRF24_receive_data(&data_store[0]);
  40172a:	4668      	mov	r0, sp
  40172c:	4b11      	ldr	r3, [pc, #68]	; (401774 <main+0x84>)
  40172e:	4798      	blx	r3
			/*for(int i = 0; i < 32; i++){
				printf("0x%02x\r\n", data_store[i]);
			}*/
			printf("%s\r\n",data_store); //If you want to print the received number to console you would have to add 48!!!
  401730:	4669      	mov	r1, sp
  401732:	4811      	ldr	r0, [pc, #68]	; (401778 <main+0x88>)
  401734:	4b11      	ldr	r3, [pc, #68]	; (40177c <main+0x8c>)
  401736:	4798      	blx	r3
			uint8_t m_period;
			m_period = data_store[0];
			set_pmw_motor_0(&(PWM_0.device), m_period);
  401738:	f89d 1000 	ldrb.w	r1, [sp]
  40173c:	4809      	ldr	r0, [pc, #36]	; (401764 <main+0x74>)
  40173e:	4b0b      	ldr	r3, [pc, #44]	; (40176c <main+0x7c>)
  401740:	4798      	blx	r3
			memset(&data_store[0], 0, sizeof(uint8_t)*32);
  401742:	2220      	movs	r2, #32
  401744:	2100      	movs	r1, #0
  401746:	4668      	mov	r0, sp
  401748:	4b05      	ldr	r3, [pc, #20]	; (401760 <main+0x70>)
  40174a:	4798      	blx	r3
  40174c:	e7e8      	b.n	401720 <main+0x30>
  40174e:	bf00      	nop
  401750:	004001d5 	.word	0x004001d5
  401754:	00401871 	.word	0x00401871
  401758:	004005a9 	.word	0x004005a9
  40175c:	00401921 	.word	0x00401921
  401760:	00401b09 	.word	0x00401b09
  401764:	204000b8 	.word	0x204000b8
  401768:	00400799 	.word	0x00400799
  40176c:	004016e1 	.word	0x004016e1
  401770:	004018f9 	.word	0x004018f9
  401774:	00401979 	.word	0x00401979
  401778:	00402cdc 	.word	0x00402cdc
  40177c:	00401c71 	.word	0x00401c71

00401780 <nRF24_write_to_register>:

#include "nRF24_driver.h"

struct io_descriptor *spi_0_io;

void nRF24_write_to_register(uint8_t registerd, uint8_t data){ //SPI Command "W_REGISTER"
  401780:	b530      	push	{r4, r5, lr}
  401782:	b083      	sub	sp, #12
	uint8_t buffer[2];
	memset(&buffer[0], 0, sizeof(uint8_t)*2);
	buffer[0] = buffer[0] | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer[0] = (buffer[0]) | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  401784:	f040 0020 	orr.w	r0, r0, #32
  401788:	f88d 0004 	strb.w	r0, [sp, #4]
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	buffer[1] = data;
  40178c:	f88d 1005 	strb.w	r1, [sp, #5]
	((Pio *)hw)->PIO_CODR = mask;
  401790:	4c06      	ldr	r4, [pc, #24]	; (4017ac <nRF24_write_to_register+0x2c>)
  401792:	f44f 7500 	mov.w	r5, #512	; 0x200
  401796:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, buffer, 2); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  401798:	2202      	movs	r2, #2
  40179a:	a901      	add	r1, sp, #4
  40179c:	4b04      	ldr	r3, [pc, #16]	; (4017b0 <nRF24_write_to_register+0x30>)
  40179e:	6818      	ldr	r0, [r3, #0]
  4017a0:	4b04      	ldr	r3, [pc, #16]	; (4017b4 <nRF24_write_to_register+0x34>)
  4017a2:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  4017a4:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  4017a6:	b003      	add	sp, #12
  4017a8:	bd30      	pop	{r4, r5, pc}
  4017aa:	bf00      	nop
  4017ac:	400e1200 	.word	0x400e1200
  4017b0:	20400118 	.word	0x20400118
  4017b4:	004006e1 	.word	0x004006e1

004017b8 <nRF24_write_to_register_multi_byte>:

void nRF24_write_to_register_multi_byte(uint8_t registerd, uint8_t *data, int length){ //SPI Command "W_REGISTER"
  4017b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4017bc:	b083      	sub	sp, #12
  4017be:	4688      	mov	r8, r1
  4017c0:	4691      	mov	r9, r2
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | 32; //Command word (binary) = 001A AAAA. 32 = 0010 0000. This will place a 1 in the right position for the command word for W_REGISTER
	buffer = buffer | registerd; //For example, if register 4 was passed in as a parameter. buffer[0] currently equals 32. 32|4 = 36. 36 = 0010 0100. This complies
  4017c2:	f040 0020 	orr.w	r0, r0, #32
  4017c6:	a902      	add	r1, sp, #8
  4017c8:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  4017cc:	4c08      	ldr	r4, [pc, #32]	; (4017f0 <nRF24_write_to_register_multi_byte+0x38>)
  4017ce:	f44f 7500 	mov.w	r5, #512	; 0x200
  4017d2:	6365      	str	r5, [r4, #52]	; 0x34
	//with what the chip is expecting of 001A AAAA, where AAAAA would equal 0100, or 4.
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1);
  4017d4:	4f07      	ldr	r7, [pc, #28]	; (4017f4 <nRF24_write_to_register_multi_byte+0x3c>)
  4017d6:	2201      	movs	r2, #1
  4017d8:	6838      	ldr	r0, [r7, #0]
  4017da:	4e07      	ldr	r6, [pc, #28]	; (4017f8 <nRF24_write_to_register_multi_byte+0x40>)
  4017dc:	47b0      	blx	r6
	io_write(spi_0_io, data, length); 
  4017de:	fa1f f289 	uxth.w	r2, r9
  4017e2:	4641      	mov	r1, r8
  4017e4:	6838      	ldr	r0, [r7, #0]
  4017e6:	47b0      	blx	r6
	((Pio *)hw)->PIO_SODR = mask;
  4017e8:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  4017ea:	b003      	add	sp, #12
  4017ec:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  4017f0:	400e1200 	.word	0x400e1200
  4017f4:	20400118 	.word	0x20400118
  4017f8:	004006e1 	.word	0x004006e1

004017fc <nRF24_read_from_register>:

uint8_t nRF24_read_from_register(uint8_t registerd){ //SPI Command "R_REGISTER"
  4017fc:	b570      	push	{r4, r5, r6, lr}
  4017fe:	b082      	sub	sp, #8
	uint8_t in_byte;
	uint8_t buffer;
	buffer = 0;
	buffer = buffer | registerd;
  401800:	a902      	add	r1, sp, #8
  401802:	f801 0d02 	strb.w	r0, [r1, #-2]!
	((Pio *)hw)->PIO_CODR = mask;
  401806:	4c0a      	ldr	r4, [pc, #40]	; (401830 <nRF24_read_from_register+0x34>)
  401808:	f44f 7500 	mov.w	r5, #512	; 0x200
  40180c:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &buffer, 1); //Careful never to put too much math inside of here, you only get 38 clock cycles max between driving CSN to low and when data needs to start being transmitted
  40180e:	4e09      	ldr	r6, [pc, #36]	; (401834 <nRF24_read_from_register+0x38>)
  401810:	2201      	movs	r2, #1
  401812:	6830      	ldr	r0, [r6, #0]
  401814:	4b08      	ldr	r3, [pc, #32]	; (401838 <nRF24_read_from_register+0x3c>)
  401816:	4798      	blx	r3
	io_read(spi_0_io, &in_byte, 1);
  401818:	2201      	movs	r2, #1
  40181a:	f10d 0107 	add.w	r1, sp, #7
  40181e:	6830      	ldr	r0, [r6, #0]
  401820:	4b06      	ldr	r3, [pc, #24]	; (40183c <nRF24_read_from_register+0x40>)
  401822:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  401824:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	return in_byte;
}
  401826:	f89d 0007 	ldrb.w	r0, [sp, #7]
  40182a:	b002      	add	sp, #8
  40182c:	bd70      	pop	{r4, r5, r6, pc}
  40182e:	bf00      	nop
  401830:	400e1200 	.word	0x400e1200
  401834:	20400118 	.word	0x20400118
  401838:	004006e1 	.word	0x004006e1
  40183c:	00400711 	.word	0x00400711

00401840 <nRF24_send_SPI_command>:
	io_write(spi_0_io, &buffer, 1);
	io_read(spi_0_io, data_pointer, length);
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}

void nRF24_send_SPI_command(uint8_t command){
  401840:	b530      	push	{r4, r5, lr}
  401842:	b083      	sub	sp, #12
  401844:	a902      	add	r1, sp, #8
  401846:	f801 0d01 	strb.w	r0, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  40184a:	4c06      	ldr	r4, [pc, #24]	; (401864 <nRF24_send_SPI_command+0x24>)
  40184c:	f44f 7500 	mov.w	r5, #512	; 0x200
  401850:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &command, 1);
  401852:	2201      	movs	r2, #1
  401854:	4b04      	ldr	r3, [pc, #16]	; (401868 <nRF24_send_SPI_command+0x28>)
  401856:	6818      	ldr	r0, [r3, #0]
  401858:	4b04      	ldr	r3, [pc, #16]	; (40186c <nRF24_send_SPI_command+0x2c>)
  40185a:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  40185c:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
}
  40185e:	b003      	add	sp, #12
  401860:	bd30      	pop	{r4, r5, pc}
  401862:	bf00      	nop
  401864:	400e1200 	.word	0x400e1200
  401868:	20400118 	.word	0x20400118
  40186c:	004006e1 	.word	0x004006e1

00401870 <nRF24_init>:

void nRF24_init(){ //You are in standby-1 at the end of this call
  401870:	b510      	push	{r4, lr}
  401872:	b082      	sub	sp, #8
	spi_m_sync_get_io_descriptor(&SPI_0, &spi_0_io);
  401874:	4c18      	ldr	r4, [pc, #96]	; (4018d8 <nRF24_init+0x68>)
  401876:	4919      	ldr	r1, [pc, #100]	; (4018dc <nRF24_init+0x6c>)
  401878:	4620      	mov	r0, r4
  40187a:	4b19      	ldr	r3, [pc, #100]	; (4018e0 <nRF24_init+0x70>)
  40187c:	4798      	blx	r3
	spi_m_sync_enable(&SPI_0);
  40187e:	4620      	mov	r0, r4
  401880:	4b18      	ldr	r3, [pc, #96]	; (4018e4 <nRF24_init+0x74>)
  401882:	4798      	blx	r3
	((Pio *)hw)->PIO_CODR = mask;
  401884:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  401888:	4b17      	ldr	r3, [pc, #92]	; (4018e8 <nRF24_init+0x78>)
  40188a:	635a      	str	r2, [r3, #52]	; 0x34
	gpio_set_pin_level(RF24_CE, false); //Keeps us set to be ready to enter standby-1
	nRF24_write_to_register(CONFIG,0); //0000 0000 keep us in power down, disable checksums
  40188c:	2100      	movs	r1, #0
  40188e:	4608      	mov	r0, r1
  401890:	4c16      	ldr	r4, [pc, #88]	; (4018ec <nRF24_init+0x7c>)
  401892:	47a0      	blx	r4
	nRF24_write_to_register(EN_AA,0); //0000 0000 no auto ACK
  401894:	2100      	movs	r1, #0
  401896:	2001      	movs	r0, #1
  401898:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR,0); //0000 0000 disable all RX pipes
  40189a:	2100      	movs	r1, #0
  40189c:	2002      	movs	r0, #2
  40189e:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_AW,3); //0000 0011 5 byte tx rx address fields
  4018a0:	2103      	movs	r1, #3
  4018a2:	4608      	mov	r0, r1
  4018a4:	47a0      	blx	r4
	nRF24_write_to_register(SETUP_RETR,0); //0000 0000 no auto retransmission
  4018a6:	2100      	movs	r1, #0
  4018a8:	2004      	movs	r0, #4
  4018aa:	47a0      	blx	r4
	nRF24_write_to_register(RF_CH,120); //0011 1111 first bit must be 0, 011 1111 = 63 freq = 2400 + 63 = 2463 = 2.463 GHz
  4018ac:	2178      	movs	r1, #120	; 0x78
  4018ae:	2005      	movs	r0, #5
  4018b0:	47a0      	blx	r4
	nRF24_write_to_register(RF_SETUP,6); //0000 0010 1 Mbps and -12 db //SET BACK TO 2
  4018b2:	2106      	movs	r1, #6
  4018b4:	4608      	mov	r0, r1
  4018b6:	47a0      	blx	r4
	uint8_t tx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  4018b8:	4b0d      	ldr	r3, [pc, #52]	; (4018f0 <nRF24_init+0x80>)
  4018ba:	e893 0003 	ldmia.w	r3, {r0, r1}
  4018be:	9000      	str	r0, [sp, #0]
  4018c0:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(TX_ADDR, &tx_address[0], 5); //Set TX addr as e7e7e7e7e7
  4018c4:	2205      	movs	r2, #5
  4018c6:	4669      	mov	r1, sp
  4018c8:	2010      	movs	r0, #16
  4018ca:	4b0a      	ldr	r3, [pc, #40]	; (4018f4 <nRF24_init+0x84>)
  4018cc:	4798      	blx	r3
	nRF24_write_to_register(CONFIG,2); //0000 0020 enter standby-1, disable checksums
  4018ce:	2102      	movs	r1, #2
  4018d0:	2000      	movs	r0, #0
  4018d2:	47a0      	blx	r4
}
  4018d4:	b002      	add	sp, #8
  4018d6:	bd10      	pop	{r4, pc}
  4018d8:	204000e0 	.word	0x204000e0
  4018dc:	20400118 	.word	0x20400118
  4018e0:	00400925 	.word	0x00400925
  4018e4:	00400845 	.word	0x00400845
  4018e8:	400e1400 	.word	0x400e1400
  4018ec:	00401781 	.word	0x00401781
  4018f0:	00402ce4 	.word	0x00402ce4
  4018f4:	004017b9 	.word	0x004017b9

004018f8 <nRF_24_is_data_available>:
	gpio_set_pin_level(RF24_CE, true);
	delay_us(11); //This will put us into TX mode and empty the FIFO queue into the air
	gpio_set_pin_level(RF24_CE, false); //Return to standby-1 mode!
}

uint8_t nRF_24_is_data_available(int pipe_num){
  4018f8:	b508      	push	{r3, lr}
	uint8_t status_reg;
	status_reg = nRF24_read_from_register(STATUS);
  4018fa:	2007      	movs	r0, #7
  4018fc:	4b06      	ldr	r3, [pc, #24]	; (401918 <nRF_24_is_data_available+0x20>)
  4018fe:	4798      	blx	r3
	if((status_reg&(1<<6))&&(status_reg&(1<<1))){ //1<<6 is the data ready rx fifo interrupt and 1<<1 is the data from pipe 1 ready to read 
  401900:	f000 0042 	and.w	r0, r0, #66	; 0x42
  401904:	2842      	cmp	r0, #66	; 0x42
  401906:	d001      	beq.n	40190c <nRF_24_is_data_available+0x14>
		nRF24_write_to_register(STATUS, (1<<6)); //clear data ready rx fifo
		return 1;
	}
	return 0;
  401908:	2000      	movs	r0, #0
}
  40190a:	bd08      	pop	{r3, pc}
		nRF24_write_to_register(STATUS, (1<<6)); //clear data ready rx fifo
  40190c:	2140      	movs	r1, #64	; 0x40
  40190e:	2007      	movs	r0, #7
  401910:	4b02      	ldr	r3, [pc, #8]	; (40191c <nRF_24_is_data_available+0x24>)
  401912:	4798      	blx	r3
		return 1;
  401914:	2001      	movs	r0, #1
  401916:	bd08      	pop	{r3, pc}
  401918:	004017fd 	.word	0x004017fd
  40191c:	00401781 	.word	0x00401781

00401920 <nRF24_enter_receive>:

void nRF24_enter_receive(){ //You are in receive at the end of this call
  401920:	b510      	push	{r4, lr}
  401922:	b082      	sub	sp, #8
	uint8_t config_reg;
	config_reg = nRF24_read_from_register(CONFIG);
  401924:	2000      	movs	r0, #0
  401926:	4b0f      	ldr	r3, [pc, #60]	; (401964 <nRF24_enter_receive+0x44>)
  401928:	4798      	blx	r3
	config_reg = config_reg | 1; //XXXX XXX1 PRIM_RX to 1
  40192a:	f040 0101 	orr.w	r1, r0, #1
	nRF24_write_to_register(CONFIG, config_reg);
  40192e:	b2c9      	uxtb	r1, r1
  401930:	2000      	movs	r0, #0
  401932:	4c0d      	ldr	r4, [pc, #52]	; (401968 <nRF24_enter_receive+0x48>)
  401934:	47a0      	blx	r4
	nRF24_write_to_register(EN_RXADDR, 2); //0000 0010 set data pipe 1 to on
  401936:	2102      	movs	r1, #2
  401938:	4608      	mov	r0, r1
  40193a:	47a0      	blx	r4
	uint8_t rx_address[] = {0xEE, 0xDD, 0xCC, 0xBB, 0xAA};
  40193c:	4b0b      	ldr	r3, [pc, #44]	; (40196c <nRF24_enter_receive+0x4c>)
  40193e:	e893 0003 	ldmia.w	r3, {r0, r1}
  401942:	9000      	str	r0, [sp, #0]
  401944:	f88d 1004 	strb.w	r1, [sp, #4]
	nRF24_write_to_register_multi_byte(RX_ADDR_P1, &rx_address[0], 5);
  401948:	2205      	movs	r2, #5
  40194a:	4669      	mov	r1, sp
  40194c:	200b      	movs	r0, #11
  40194e:	4b08      	ldr	r3, [pc, #32]	; (401970 <nRF24_enter_receive+0x50>)
  401950:	4798      	blx	r3
	nRF24_write_to_register(RX_PW_P1,32); //32 bytes packet size
  401952:	2120      	movs	r1, #32
  401954:	2012      	movs	r0, #18
  401956:	47a0      	blx	r4
	((Pio *)hw)->PIO_SODR = mask;
  401958:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
  40195c:	4b05      	ldr	r3, [pc, #20]	; (401974 <nRF24_enter_receive+0x54>)
  40195e:	631a      	str	r2, [r3, #48]	; 0x30
	gpio_set_pin_level(RF24_CE, true);
}
  401960:	b002      	add	sp, #8
  401962:	bd10      	pop	{r4, pc}
  401964:	004017fd 	.word	0x004017fd
  401968:	00401781 	.word	0x00401781
  40196c:	00402ce4 	.word	0x00402ce4
  401970:	004017b9 	.word	0x004017b9
  401974:	400e1400 	.word	0x400e1400

00401978 <nRF24_receive_data>:

void nRF24_receive_data(uint8_t *data_pointer){
  401978:	b5f0      	push	{r4, r5, r6, r7, lr}
  40197a:	b083      	sub	sp, #12
  40197c:	4607      	mov	r7, r0
	uint8_t cmd = R_RX_PAYLOAD;
  40197e:	a902      	add	r1, sp, #8
  401980:	2361      	movs	r3, #97	; 0x61
  401982:	f801 3d01 	strb.w	r3, [r1, #-1]!
	((Pio *)hw)->PIO_CODR = mask;
  401986:	4c0c      	ldr	r4, [pc, #48]	; (4019b8 <nRF24_receive_data+0x40>)
  401988:	f44f 7500 	mov.w	r5, #512	; 0x200
  40198c:	6365      	str	r5, [r4, #52]	; 0x34
	gpio_set_pin_level(RF24_CSN, false); //drive this low before doing SPI transmissions
	io_write(spi_0_io, &cmd, 1);
  40198e:	4e0b      	ldr	r6, [pc, #44]	; (4019bc <nRF24_receive_data+0x44>)
  401990:	2201      	movs	r2, #1
  401992:	6830      	ldr	r0, [r6, #0]
  401994:	4b0a      	ldr	r3, [pc, #40]	; (4019c0 <nRF24_receive_data+0x48>)
  401996:	4798      	blx	r3
	io_read(spi_0_io, data_pointer, 32);
  401998:	2220      	movs	r2, #32
  40199a:	4639      	mov	r1, r7
  40199c:	6830      	ldr	r0, [r6, #0]
  40199e:	4b09      	ldr	r3, [pc, #36]	; (4019c4 <nRF24_receive_data+0x4c>)
  4019a0:	4798      	blx	r3
	((Pio *)hw)->PIO_SODR = mask;
  4019a2:	6325      	str	r5, [r4, #48]	; 0x30
	gpio_set_pin_level(RF24_CSN, true); //return to high after SPI transmissions
	delay_us(11); //Make sure we had enough time to grab the data before flushing
  4019a4:	200b      	movs	r0, #11
  4019a6:	4b08      	ldr	r3, [pc, #32]	; (4019c8 <nRF24_receive_data+0x50>)
  4019a8:	4798      	blx	r3
	cmd = FLUSH_RX;
  4019aa:	20e2      	movs	r0, #226	; 0xe2
  4019ac:	f88d 0007 	strb.w	r0, [sp, #7]
	nRF24_send_SPI_command(cmd);
  4019b0:	4b06      	ldr	r3, [pc, #24]	; (4019cc <nRF24_receive_data+0x54>)
  4019b2:	4798      	blx	r3
}
  4019b4:	b003      	add	sp, #12
  4019b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4019b8:	400e1200 	.word	0x400e1200
  4019bc:	20400118 	.word	0x20400118
  4019c0:	004006e1 	.word	0x004006e1
  4019c4:	00400711 	.word	0x00400711
  4019c8:	004005a9 	.word	0x004005a9
  4019cc:	00401841 	.word	0x00401841

004019d0 <_read>:

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
	int n = 0;

	if (file != 0) {
  4019d0:	b958      	cbnz	r0, 4019ea <_read+0x1a>
{
  4019d2:	b508      	push	{r3, lr}
  4019d4:	460b      	mov	r3, r1
  4019d6:	4611      	mov	r1, r2
  4019d8:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
  4019da:	4b05      	ldr	r3, [pc, #20]	; (4019f0 <_read+0x20>)
  4019dc:	4798      	blx	r3
	if (n < 0) {
  4019de:	2800      	cmp	r0, #0
  4019e0:	db00      	blt.n	4019e4 <_read+0x14>
		return -1;
	}

	return n;
}
  4019e2:	bd08      	pop	{r3, pc}
		return -1;
  4019e4:	f04f 30ff 	mov.w	r0, #4294967295
  4019e8:	bd08      	pop	{r3, pc}
		return -1;
  4019ea:	f04f 30ff 	mov.w	r0, #4294967295
  4019ee:	4770      	bx	lr
  4019f0:	00401a49 	.word	0x00401a49

004019f4 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
  4019f4:	3801      	subs	r0, #1
  4019f6:	2802      	cmp	r0, #2
  4019f8:	d80b      	bhi.n	401a12 <_write+0x1e>
{
  4019fa:	b508      	push	{r3, lr}
  4019fc:	460b      	mov	r3, r1
  4019fe:	4611      	mov	r1, r2
  401a00:	4618      	mov	r0, r3
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
  401a02:	4b05      	ldr	r3, [pc, #20]	; (401a18 <_write+0x24>)
  401a04:	4798      	blx	r3
	if (n < 0) {
  401a06:	2800      	cmp	r0, #0
  401a08:	db00      	blt.n	401a0c <_write+0x18>
		return -1;
	}

	return n;
}
  401a0a:	bd08      	pop	{r3, pc}
		return -1;
  401a0c:	f04f 30ff 	mov.w	r0, #4294967295
  401a10:	bd08      	pop	{r3, pc}
		return -1;
  401a12:	f04f 30ff 	mov.w	r0, #4294967295
  401a16:	4770      	bx	lr
  401a18:	00401a6d 	.word	0x00401a6d

00401a1c <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
  401a1c:	b570      	push	{r4, r5, r6, lr}
  401a1e:	4606      	mov	r6, r0
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
  401a20:	4d06      	ldr	r5, [pc, #24]	; (401a3c <stdio_io_init+0x20>)
  401a22:	682b      	ldr	r3, [r5, #0]
  401a24:	2100      	movs	r1, #0
  401a26:	6898      	ldr	r0, [r3, #8]
  401a28:	4c05      	ldr	r4, [pc, #20]	; (401a40 <stdio_io_init+0x24>)
  401a2a:	47a0      	blx	r4
	setbuf(stdin, NULL);
  401a2c:	682b      	ldr	r3, [r5, #0]
  401a2e:	2100      	movs	r1, #0
  401a30:	6858      	ldr	r0, [r3, #4]
  401a32:	47a0      	blx	r4
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
  401a34:	4b03      	ldr	r3, [pc, #12]	; (401a44 <stdio_io_init+0x28>)
  401a36:	601e      	str	r6, [r3, #0]
  401a38:	bd70      	pop	{r4, r5, r6, pc}
  401a3a:	bf00      	nop
  401a3c:	20400000 	.word	0x20400000
  401a40:	00401cc1 	.word	0x00401cc1
  401a44:	204000ac 	.word	0x204000ac

00401a48 <stdio_io_read>:
{
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
  401a48:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  401a4a:	4b06      	ldr	r3, [pc, #24]	; (401a64 <stdio_io_read+0x1c>)
  401a4c:	681b      	ldr	r3, [r3, #0]
  401a4e:	b133      	cbz	r3, 401a5e <stdio_io_read+0x16>
  401a50:	460a      	mov	r2, r1
  401a52:	4601      	mov	r1, r0
		return 0;
	}
	return io_read(stdio_io, buf, len);
  401a54:	b292      	uxth	r2, r2
  401a56:	4618      	mov	r0, r3
  401a58:	4b03      	ldr	r3, [pc, #12]	; (401a68 <stdio_io_read+0x20>)
  401a5a:	4798      	blx	r3
  401a5c:	bd08      	pop	{r3, pc}
		return 0;
  401a5e:	2000      	movs	r0, #0
}
  401a60:	bd08      	pop	{r3, pc}
  401a62:	bf00      	nop
  401a64:	204000ac 	.word	0x204000ac
  401a68:	00400711 	.word	0x00400711

00401a6c <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
  401a6c:	b508      	push	{r3, lr}
	if (stdio_io == NULL) {
  401a6e:	4b06      	ldr	r3, [pc, #24]	; (401a88 <stdio_io_write+0x1c>)
  401a70:	681b      	ldr	r3, [r3, #0]
  401a72:	b133      	cbz	r3, 401a82 <stdio_io_write+0x16>
  401a74:	460a      	mov	r2, r1
  401a76:	4601      	mov	r1, r0
		return 0;
	}
	return io_write(stdio_io, buf, len);
  401a78:	b292      	uxth	r2, r2
  401a7a:	4618      	mov	r0, r3
  401a7c:	4b03      	ldr	r3, [pc, #12]	; (401a8c <stdio_io_write+0x20>)
  401a7e:	4798      	blx	r3
  401a80:	bd08      	pop	{r3, pc}
		return 0;
  401a82:	2000      	movs	r0, #0
}
  401a84:	bd08      	pop	{r3, pc}
  401a86:	bf00      	nop
  401a88:	204000ac 	.word	0x204000ac
  401a8c:	004006e1 	.word	0x004006e1

00401a90 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
  401a90:	b510      	push	{r4, lr}

	usart_sync_enable(&TARGET_IO);
  401a92:	4c04      	ldr	r4, [pc, #16]	; (401aa4 <stdio_redirect_init+0x14>)
  401a94:	4620      	mov	r0, r4
  401a96:	4b04      	ldr	r3, [pc, #16]	; (401aa8 <stdio_redirect_init+0x18>)
  401a98:	4798      	blx	r3
	stdio_io_init(&TARGET_IO.io);
  401a9a:	4620      	mov	r0, r4
  401a9c:	4b03      	ldr	r3, [pc, #12]	; (401aac <stdio_redirect_init+0x1c>)
  401a9e:	4798      	blx	r3
  401aa0:	bd10      	pop	{r4, pc}
  401aa2:	bf00      	nop
  401aa4:	204000d4 	.word	0x204000d4
  401aa8:	00400a69 	.word	0x00400a69
  401aac:	00401a1d 	.word	0x00401a1d

00401ab0 <__libc_init_array>:
  401ab0:	b570      	push	{r4, r5, r6, lr}
  401ab2:	4e0d      	ldr	r6, [pc, #52]	; (401ae8 <__libc_init_array+0x38>)
  401ab4:	4c0d      	ldr	r4, [pc, #52]	; (401aec <__libc_init_array+0x3c>)
  401ab6:	1ba4      	subs	r4, r4, r6
  401ab8:	10a4      	asrs	r4, r4, #2
  401aba:	2500      	movs	r5, #0
  401abc:	42a5      	cmp	r5, r4
  401abe:	d109      	bne.n	401ad4 <__libc_init_array+0x24>
  401ac0:	4e0b      	ldr	r6, [pc, #44]	; (401af0 <__libc_init_array+0x40>)
  401ac2:	4c0c      	ldr	r4, [pc, #48]	; (401af4 <__libc_init_array+0x44>)
  401ac4:	f001 f95e 	bl	402d84 <_init>
  401ac8:	1ba4      	subs	r4, r4, r6
  401aca:	10a4      	asrs	r4, r4, #2
  401acc:	2500      	movs	r5, #0
  401ace:	42a5      	cmp	r5, r4
  401ad0:	d105      	bne.n	401ade <__libc_init_array+0x2e>
  401ad2:	bd70      	pop	{r4, r5, r6, pc}
  401ad4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401ad8:	4798      	blx	r3
  401ada:	3501      	adds	r5, #1
  401adc:	e7ee      	b.n	401abc <__libc_init_array+0xc>
  401ade:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  401ae2:	4798      	blx	r3
  401ae4:	3501      	adds	r5, #1
  401ae6:	e7f2      	b.n	401ace <__libc_init_array+0x1e>
  401ae8:	00402d90 	.word	0x00402d90
  401aec:	00402d90 	.word	0x00402d90
  401af0:	00402d90 	.word	0x00402d90
  401af4:	00402d94 	.word	0x00402d94

00401af8 <malloc>:
  401af8:	4b02      	ldr	r3, [pc, #8]	; (401b04 <malloc+0xc>)
  401afa:	4601      	mov	r1, r0
  401afc:	6818      	ldr	r0, [r3, #0]
  401afe:	f000 b859 	b.w	401bb4 <_malloc_r>
  401b02:	bf00      	nop
  401b04:	20400000 	.word	0x20400000

00401b08 <memset>:
  401b08:	4402      	add	r2, r0
  401b0a:	4603      	mov	r3, r0
  401b0c:	4293      	cmp	r3, r2
  401b0e:	d100      	bne.n	401b12 <memset+0xa>
  401b10:	4770      	bx	lr
  401b12:	f803 1b01 	strb.w	r1, [r3], #1
  401b16:	e7f9      	b.n	401b0c <memset+0x4>

00401b18 <_free_r>:
  401b18:	b538      	push	{r3, r4, r5, lr}
  401b1a:	4605      	mov	r5, r0
  401b1c:	2900      	cmp	r1, #0
  401b1e:	d045      	beq.n	401bac <_free_r+0x94>
  401b20:	f851 3c04 	ldr.w	r3, [r1, #-4]
  401b24:	1f0c      	subs	r4, r1, #4
  401b26:	2b00      	cmp	r3, #0
  401b28:	bfb8      	it	lt
  401b2a:	18e4      	addlt	r4, r4, r3
  401b2c:	f000 fc1e 	bl	40236c <__malloc_lock>
  401b30:	4a1f      	ldr	r2, [pc, #124]	; (401bb0 <_free_r+0x98>)
  401b32:	6813      	ldr	r3, [r2, #0]
  401b34:	4610      	mov	r0, r2
  401b36:	b933      	cbnz	r3, 401b46 <_free_r+0x2e>
  401b38:	6063      	str	r3, [r4, #4]
  401b3a:	6014      	str	r4, [r2, #0]
  401b3c:	4628      	mov	r0, r5
  401b3e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  401b42:	f000 bc14 	b.w	40236e <__malloc_unlock>
  401b46:	42a3      	cmp	r3, r4
  401b48:	d90c      	bls.n	401b64 <_free_r+0x4c>
  401b4a:	6821      	ldr	r1, [r4, #0]
  401b4c:	1862      	adds	r2, r4, r1
  401b4e:	4293      	cmp	r3, r2
  401b50:	bf04      	itt	eq
  401b52:	681a      	ldreq	r2, [r3, #0]
  401b54:	685b      	ldreq	r3, [r3, #4]
  401b56:	6063      	str	r3, [r4, #4]
  401b58:	bf04      	itt	eq
  401b5a:	1852      	addeq	r2, r2, r1
  401b5c:	6022      	streq	r2, [r4, #0]
  401b5e:	6004      	str	r4, [r0, #0]
  401b60:	e7ec      	b.n	401b3c <_free_r+0x24>
  401b62:	4613      	mov	r3, r2
  401b64:	685a      	ldr	r2, [r3, #4]
  401b66:	b10a      	cbz	r2, 401b6c <_free_r+0x54>
  401b68:	42a2      	cmp	r2, r4
  401b6a:	d9fa      	bls.n	401b62 <_free_r+0x4a>
  401b6c:	6819      	ldr	r1, [r3, #0]
  401b6e:	1858      	adds	r0, r3, r1
  401b70:	42a0      	cmp	r0, r4
  401b72:	d10b      	bne.n	401b8c <_free_r+0x74>
  401b74:	6820      	ldr	r0, [r4, #0]
  401b76:	4401      	add	r1, r0
  401b78:	1858      	adds	r0, r3, r1
  401b7a:	4282      	cmp	r2, r0
  401b7c:	6019      	str	r1, [r3, #0]
  401b7e:	d1dd      	bne.n	401b3c <_free_r+0x24>
  401b80:	6810      	ldr	r0, [r2, #0]
  401b82:	6852      	ldr	r2, [r2, #4]
  401b84:	605a      	str	r2, [r3, #4]
  401b86:	4401      	add	r1, r0
  401b88:	6019      	str	r1, [r3, #0]
  401b8a:	e7d7      	b.n	401b3c <_free_r+0x24>
  401b8c:	d902      	bls.n	401b94 <_free_r+0x7c>
  401b8e:	230c      	movs	r3, #12
  401b90:	602b      	str	r3, [r5, #0]
  401b92:	e7d3      	b.n	401b3c <_free_r+0x24>
  401b94:	6820      	ldr	r0, [r4, #0]
  401b96:	1821      	adds	r1, r4, r0
  401b98:	428a      	cmp	r2, r1
  401b9a:	bf04      	itt	eq
  401b9c:	6811      	ldreq	r1, [r2, #0]
  401b9e:	6852      	ldreq	r2, [r2, #4]
  401ba0:	6062      	str	r2, [r4, #4]
  401ba2:	bf04      	itt	eq
  401ba4:	1809      	addeq	r1, r1, r0
  401ba6:	6021      	streq	r1, [r4, #0]
  401ba8:	605c      	str	r4, [r3, #4]
  401baa:	e7c7      	b.n	401b3c <_free_r+0x24>
  401bac:	bd38      	pop	{r3, r4, r5, pc}
  401bae:	bf00      	nop
  401bb0:	204000b0 	.word	0x204000b0

00401bb4 <_malloc_r>:
  401bb4:	b570      	push	{r4, r5, r6, lr}
  401bb6:	1ccd      	adds	r5, r1, #3
  401bb8:	f025 0503 	bic.w	r5, r5, #3
  401bbc:	3508      	adds	r5, #8
  401bbe:	2d0c      	cmp	r5, #12
  401bc0:	bf38      	it	cc
  401bc2:	250c      	movcc	r5, #12
  401bc4:	2d00      	cmp	r5, #0
  401bc6:	4606      	mov	r6, r0
  401bc8:	db01      	blt.n	401bce <_malloc_r+0x1a>
  401bca:	42a9      	cmp	r1, r5
  401bcc:	d903      	bls.n	401bd6 <_malloc_r+0x22>
  401bce:	230c      	movs	r3, #12
  401bd0:	6033      	str	r3, [r6, #0]
  401bd2:	2000      	movs	r0, #0
  401bd4:	bd70      	pop	{r4, r5, r6, pc}
  401bd6:	f000 fbc9 	bl	40236c <__malloc_lock>
  401bda:	4a23      	ldr	r2, [pc, #140]	; (401c68 <_malloc_r+0xb4>)
  401bdc:	6814      	ldr	r4, [r2, #0]
  401bde:	4621      	mov	r1, r4
  401be0:	b991      	cbnz	r1, 401c08 <_malloc_r+0x54>
  401be2:	4c22      	ldr	r4, [pc, #136]	; (401c6c <_malloc_r+0xb8>)
  401be4:	6823      	ldr	r3, [r4, #0]
  401be6:	b91b      	cbnz	r3, 401bf0 <_malloc_r+0x3c>
  401be8:	4630      	mov	r0, r6
  401bea:	f000 f859 	bl	401ca0 <_sbrk_r>
  401bee:	6020      	str	r0, [r4, #0]
  401bf0:	4629      	mov	r1, r5
  401bf2:	4630      	mov	r0, r6
  401bf4:	f000 f854 	bl	401ca0 <_sbrk_r>
  401bf8:	1c43      	adds	r3, r0, #1
  401bfa:	d126      	bne.n	401c4a <_malloc_r+0x96>
  401bfc:	230c      	movs	r3, #12
  401bfe:	6033      	str	r3, [r6, #0]
  401c00:	4630      	mov	r0, r6
  401c02:	f000 fbb4 	bl	40236e <__malloc_unlock>
  401c06:	e7e4      	b.n	401bd2 <_malloc_r+0x1e>
  401c08:	680b      	ldr	r3, [r1, #0]
  401c0a:	1b5b      	subs	r3, r3, r5
  401c0c:	d41a      	bmi.n	401c44 <_malloc_r+0x90>
  401c0e:	2b0b      	cmp	r3, #11
  401c10:	d90f      	bls.n	401c32 <_malloc_r+0x7e>
  401c12:	600b      	str	r3, [r1, #0]
  401c14:	50cd      	str	r5, [r1, r3]
  401c16:	18cc      	adds	r4, r1, r3
  401c18:	4630      	mov	r0, r6
  401c1a:	f000 fba8 	bl	40236e <__malloc_unlock>
  401c1e:	f104 000b 	add.w	r0, r4, #11
  401c22:	1d23      	adds	r3, r4, #4
  401c24:	f020 0007 	bic.w	r0, r0, #7
  401c28:	1ac3      	subs	r3, r0, r3
  401c2a:	d01b      	beq.n	401c64 <_malloc_r+0xb0>
  401c2c:	425a      	negs	r2, r3
  401c2e:	50e2      	str	r2, [r4, r3]
  401c30:	bd70      	pop	{r4, r5, r6, pc}
  401c32:	428c      	cmp	r4, r1
  401c34:	bf0d      	iteet	eq
  401c36:	6863      	ldreq	r3, [r4, #4]
  401c38:	684b      	ldrne	r3, [r1, #4]
  401c3a:	6063      	strne	r3, [r4, #4]
  401c3c:	6013      	streq	r3, [r2, #0]
  401c3e:	bf18      	it	ne
  401c40:	460c      	movne	r4, r1
  401c42:	e7e9      	b.n	401c18 <_malloc_r+0x64>
  401c44:	460c      	mov	r4, r1
  401c46:	6849      	ldr	r1, [r1, #4]
  401c48:	e7ca      	b.n	401be0 <_malloc_r+0x2c>
  401c4a:	1cc4      	adds	r4, r0, #3
  401c4c:	f024 0403 	bic.w	r4, r4, #3
  401c50:	42a0      	cmp	r0, r4
  401c52:	d005      	beq.n	401c60 <_malloc_r+0xac>
  401c54:	1a21      	subs	r1, r4, r0
  401c56:	4630      	mov	r0, r6
  401c58:	f000 f822 	bl	401ca0 <_sbrk_r>
  401c5c:	3001      	adds	r0, #1
  401c5e:	d0cd      	beq.n	401bfc <_malloc_r+0x48>
  401c60:	6025      	str	r5, [r4, #0]
  401c62:	e7d9      	b.n	401c18 <_malloc_r+0x64>
  401c64:	bd70      	pop	{r4, r5, r6, pc}
  401c66:	bf00      	nop
  401c68:	204000b0 	.word	0x204000b0
  401c6c:	204000b4 	.word	0x204000b4

00401c70 <iprintf>:
  401c70:	b40f      	push	{r0, r1, r2, r3}
  401c72:	4b0a      	ldr	r3, [pc, #40]	; (401c9c <iprintf+0x2c>)
  401c74:	b513      	push	{r0, r1, r4, lr}
  401c76:	681c      	ldr	r4, [r3, #0]
  401c78:	b124      	cbz	r4, 401c84 <iprintf+0x14>
  401c7a:	69a3      	ldr	r3, [r4, #24]
  401c7c:	b913      	cbnz	r3, 401c84 <iprintf+0x14>
  401c7e:	4620      	mov	r0, r4
  401c80:	f000 fa86 	bl	402190 <__sinit>
  401c84:	ab05      	add	r3, sp, #20
  401c86:	9a04      	ldr	r2, [sp, #16]
  401c88:	68a1      	ldr	r1, [r4, #8]
  401c8a:	9301      	str	r3, [sp, #4]
  401c8c:	4620      	mov	r0, r4
  401c8e:	f000 fb97 	bl	4023c0 <_vfiprintf_r>
  401c92:	b002      	add	sp, #8
  401c94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  401c98:	b004      	add	sp, #16
  401c9a:	4770      	bx	lr
  401c9c:	20400000 	.word	0x20400000

00401ca0 <_sbrk_r>:
  401ca0:	b538      	push	{r3, r4, r5, lr}
  401ca2:	4c06      	ldr	r4, [pc, #24]	; (401cbc <_sbrk_r+0x1c>)
  401ca4:	2300      	movs	r3, #0
  401ca6:	4605      	mov	r5, r0
  401ca8:	4608      	mov	r0, r1
  401caa:	6023      	str	r3, [r4, #0]
  401cac:	f7fe fef6 	bl	400a9c <_sbrk>
  401cb0:	1c43      	adds	r3, r0, #1
  401cb2:	d102      	bne.n	401cba <_sbrk_r+0x1a>
  401cb4:	6823      	ldr	r3, [r4, #0]
  401cb6:	b103      	cbz	r3, 401cba <_sbrk_r+0x1a>
  401cb8:	602b      	str	r3, [r5, #0]
  401cba:	bd38      	pop	{r3, r4, r5, pc}
  401cbc:	2040011c 	.word	0x2040011c

00401cc0 <setbuf>:
  401cc0:	2900      	cmp	r1, #0
  401cc2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  401cc6:	bf0c      	ite	eq
  401cc8:	2202      	moveq	r2, #2
  401cca:	2200      	movne	r2, #0
  401ccc:	f000 b800 	b.w	401cd0 <setvbuf>

00401cd0 <setvbuf>:
  401cd0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  401cd4:	461d      	mov	r5, r3
  401cd6:	4b51      	ldr	r3, [pc, #324]	; (401e1c <setvbuf+0x14c>)
  401cd8:	681e      	ldr	r6, [r3, #0]
  401cda:	4604      	mov	r4, r0
  401cdc:	460f      	mov	r7, r1
  401cde:	4690      	mov	r8, r2
  401ce0:	b126      	cbz	r6, 401cec <setvbuf+0x1c>
  401ce2:	69b3      	ldr	r3, [r6, #24]
  401ce4:	b913      	cbnz	r3, 401cec <setvbuf+0x1c>
  401ce6:	4630      	mov	r0, r6
  401ce8:	f000 fa52 	bl	402190 <__sinit>
  401cec:	4b4c      	ldr	r3, [pc, #304]	; (401e20 <setvbuf+0x150>)
  401cee:	429c      	cmp	r4, r3
  401cf0:	d152      	bne.n	401d98 <setvbuf+0xc8>
  401cf2:	6874      	ldr	r4, [r6, #4]
  401cf4:	f1b8 0f02 	cmp.w	r8, #2
  401cf8:	d006      	beq.n	401d08 <setvbuf+0x38>
  401cfa:	f1b8 0f01 	cmp.w	r8, #1
  401cfe:	f200 8089 	bhi.w	401e14 <setvbuf+0x144>
  401d02:	2d00      	cmp	r5, #0
  401d04:	f2c0 8086 	blt.w	401e14 <setvbuf+0x144>
  401d08:	4621      	mov	r1, r4
  401d0a:	4630      	mov	r0, r6
  401d0c:	f000 f9d6 	bl	4020bc <_fflush_r>
  401d10:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401d12:	b141      	cbz	r1, 401d26 <setvbuf+0x56>
  401d14:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401d18:	4299      	cmp	r1, r3
  401d1a:	d002      	beq.n	401d22 <setvbuf+0x52>
  401d1c:	4630      	mov	r0, r6
  401d1e:	f7ff fefb 	bl	401b18 <_free_r>
  401d22:	2300      	movs	r3, #0
  401d24:	6363      	str	r3, [r4, #52]	; 0x34
  401d26:	2300      	movs	r3, #0
  401d28:	61a3      	str	r3, [r4, #24]
  401d2a:	6063      	str	r3, [r4, #4]
  401d2c:	89a3      	ldrh	r3, [r4, #12]
  401d2e:	061b      	lsls	r3, r3, #24
  401d30:	d503      	bpl.n	401d3a <setvbuf+0x6a>
  401d32:	6921      	ldr	r1, [r4, #16]
  401d34:	4630      	mov	r0, r6
  401d36:	f7ff feef 	bl	401b18 <_free_r>
  401d3a:	89a3      	ldrh	r3, [r4, #12]
  401d3c:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
  401d40:	f023 0303 	bic.w	r3, r3, #3
  401d44:	f1b8 0f02 	cmp.w	r8, #2
  401d48:	81a3      	strh	r3, [r4, #12]
  401d4a:	d05d      	beq.n	401e08 <setvbuf+0x138>
  401d4c:	ab01      	add	r3, sp, #4
  401d4e:	466a      	mov	r2, sp
  401d50:	4621      	mov	r1, r4
  401d52:	4630      	mov	r0, r6
  401d54:	f000 faa6 	bl	4022a4 <__swhatbuf_r>
  401d58:	89a3      	ldrh	r3, [r4, #12]
  401d5a:	4318      	orrs	r0, r3
  401d5c:	81a0      	strh	r0, [r4, #12]
  401d5e:	bb2d      	cbnz	r5, 401dac <setvbuf+0xdc>
  401d60:	9d00      	ldr	r5, [sp, #0]
  401d62:	4628      	mov	r0, r5
  401d64:	f7ff fec8 	bl	401af8 <malloc>
  401d68:	4607      	mov	r7, r0
  401d6a:	2800      	cmp	r0, #0
  401d6c:	d14e      	bne.n	401e0c <setvbuf+0x13c>
  401d6e:	f8dd 9000 	ldr.w	r9, [sp]
  401d72:	45a9      	cmp	r9, r5
  401d74:	d13c      	bne.n	401df0 <setvbuf+0x120>
  401d76:	f04f 30ff 	mov.w	r0, #4294967295
  401d7a:	89a3      	ldrh	r3, [r4, #12]
  401d7c:	f043 0302 	orr.w	r3, r3, #2
  401d80:	81a3      	strh	r3, [r4, #12]
  401d82:	2300      	movs	r3, #0
  401d84:	60a3      	str	r3, [r4, #8]
  401d86:	f104 0347 	add.w	r3, r4, #71	; 0x47
  401d8a:	6023      	str	r3, [r4, #0]
  401d8c:	6123      	str	r3, [r4, #16]
  401d8e:	2301      	movs	r3, #1
  401d90:	6163      	str	r3, [r4, #20]
  401d92:	b003      	add	sp, #12
  401d94:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  401d98:	4b22      	ldr	r3, [pc, #136]	; (401e24 <setvbuf+0x154>)
  401d9a:	429c      	cmp	r4, r3
  401d9c:	d101      	bne.n	401da2 <setvbuf+0xd2>
  401d9e:	68b4      	ldr	r4, [r6, #8]
  401da0:	e7a8      	b.n	401cf4 <setvbuf+0x24>
  401da2:	4b21      	ldr	r3, [pc, #132]	; (401e28 <setvbuf+0x158>)
  401da4:	429c      	cmp	r4, r3
  401da6:	bf08      	it	eq
  401da8:	68f4      	ldreq	r4, [r6, #12]
  401daa:	e7a3      	b.n	401cf4 <setvbuf+0x24>
  401dac:	2f00      	cmp	r7, #0
  401dae:	d0d8      	beq.n	401d62 <setvbuf+0x92>
  401db0:	69b3      	ldr	r3, [r6, #24]
  401db2:	b913      	cbnz	r3, 401dba <setvbuf+0xea>
  401db4:	4630      	mov	r0, r6
  401db6:	f000 f9eb 	bl	402190 <__sinit>
  401dba:	f1b8 0f01 	cmp.w	r8, #1
  401dbe:	bf08      	it	eq
  401dc0:	89a3      	ldrheq	r3, [r4, #12]
  401dc2:	6027      	str	r7, [r4, #0]
  401dc4:	bf04      	itt	eq
  401dc6:	f043 0301 	orreq.w	r3, r3, #1
  401dca:	81a3      	strheq	r3, [r4, #12]
  401dcc:	89a3      	ldrh	r3, [r4, #12]
  401dce:	6127      	str	r7, [r4, #16]
  401dd0:	f013 0008 	ands.w	r0, r3, #8
  401dd4:	6165      	str	r5, [r4, #20]
  401dd6:	d01b      	beq.n	401e10 <setvbuf+0x140>
  401dd8:	f013 0001 	ands.w	r0, r3, #1
  401ddc:	bf18      	it	ne
  401dde:	426d      	negne	r5, r5
  401de0:	f04f 0300 	mov.w	r3, #0
  401de4:	bf1d      	ittte	ne
  401de6:	60a3      	strne	r3, [r4, #8]
  401de8:	61a5      	strne	r5, [r4, #24]
  401dea:	4618      	movne	r0, r3
  401dec:	60a5      	streq	r5, [r4, #8]
  401dee:	e7d0      	b.n	401d92 <setvbuf+0xc2>
  401df0:	4648      	mov	r0, r9
  401df2:	f7ff fe81 	bl	401af8 <malloc>
  401df6:	4607      	mov	r7, r0
  401df8:	2800      	cmp	r0, #0
  401dfa:	d0bc      	beq.n	401d76 <setvbuf+0xa6>
  401dfc:	89a3      	ldrh	r3, [r4, #12]
  401dfe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  401e02:	81a3      	strh	r3, [r4, #12]
  401e04:	464d      	mov	r5, r9
  401e06:	e7d3      	b.n	401db0 <setvbuf+0xe0>
  401e08:	2000      	movs	r0, #0
  401e0a:	e7b6      	b.n	401d7a <setvbuf+0xaa>
  401e0c:	46a9      	mov	r9, r5
  401e0e:	e7f5      	b.n	401dfc <setvbuf+0x12c>
  401e10:	60a0      	str	r0, [r4, #8]
  401e12:	e7be      	b.n	401d92 <setvbuf+0xc2>
  401e14:	f04f 30ff 	mov.w	r0, #4294967295
  401e18:	e7bb      	b.n	401d92 <setvbuf+0xc2>
  401e1a:	bf00      	nop
  401e1c:	20400000 	.word	0x20400000
  401e20:	00402d10 	.word	0x00402d10
  401e24:	00402d30 	.word	0x00402d30
  401e28:	00402cf0 	.word	0x00402cf0

00401e2c <__swbuf_r>:
  401e2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401e2e:	460e      	mov	r6, r1
  401e30:	4614      	mov	r4, r2
  401e32:	4605      	mov	r5, r0
  401e34:	b118      	cbz	r0, 401e3e <__swbuf_r+0x12>
  401e36:	6983      	ldr	r3, [r0, #24]
  401e38:	b90b      	cbnz	r3, 401e3e <__swbuf_r+0x12>
  401e3a:	f000 f9a9 	bl	402190 <__sinit>
  401e3e:	4b21      	ldr	r3, [pc, #132]	; (401ec4 <__swbuf_r+0x98>)
  401e40:	429c      	cmp	r4, r3
  401e42:	d12a      	bne.n	401e9a <__swbuf_r+0x6e>
  401e44:	686c      	ldr	r4, [r5, #4]
  401e46:	69a3      	ldr	r3, [r4, #24]
  401e48:	60a3      	str	r3, [r4, #8]
  401e4a:	89a3      	ldrh	r3, [r4, #12]
  401e4c:	071a      	lsls	r2, r3, #28
  401e4e:	d52e      	bpl.n	401eae <__swbuf_r+0x82>
  401e50:	6923      	ldr	r3, [r4, #16]
  401e52:	b363      	cbz	r3, 401eae <__swbuf_r+0x82>
  401e54:	6923      	ldr	r3, [r4, #16]
  401e56:	6820      	ldr	r0, [r4, #0]
  401e58:	1ac0      	subs	r0, r0, r3
  401e5a:	6963      	ldr	r3, [r4, #20]
  401e5c:	b2f6      	uxtb	r6, r6
  401e5e:	4298      	cmp	r0, r3
  401e60:	4637      	mov	r7, r6
  401e62:	db04      	blt.n	401e6e <__swbuf_r+0x42>
  401e64:	4621      	mov	r1, r4
  401e66:	4628      	mov	r0, r5
  401e68:	f000 f928 	bl	4020bc <_fflush_r>
  401e6c:	bb28      	cbnz	r0, 401eba <__swbuf_r+0x8e>
  401e6e:	68a3      	ldr	r3, [r4, #8]
  401e70:	3b01      	subs	r3, #1
  401e72:	60a3      	str	r3, [r4, #8]
  401e74:	6823      	ldr	r3, [r4, #0]
  401e76:	1c5a      	adds	r2, r3, #1
  401e78:	6022      	str	r2, [r4, #0]
  401e7a:	701e      	strb	r6, [r3, #0]
  401e7c:	6963      	ldr	r3, [r4, #20]
  401e7e:	3001      	adds	r0, #1
  401e80:	4298      	cmp	r0, r3
  401e82:	d004      	beq.n	401e8e <__swbuf_r+0x62>
  401e84:	89a3      	ldrh	r3, [r4, #12]
  401e86:	07db      	lsls	r3, r3, #31
  401e88:	d519      	bpl.n	401ebe <__swbuf_r+0x92>
  401e8a:	2e0a      	cmp	r6, #10
  401e8c:	d117      	bne.n	401ebe <__swbuf_r+0x92>
  401e8e:	4621      	mov	r1, r4
  401e90:	4628      	mov	r0, r5
  401e92:	f000 f913 	bl	4020bc <_fflush_r>
  401e96:	b190      	cbz	r0, 401ebe <__swbuf_r+0x92>
  401e98:	e00f      	b.n	401eba <__swbuf_r+0x8e>
  401e9a:	4b0b      	ldr	r3, [pc, #44]	; (401ec8 <__swbuf_r+0x9c>)
  401e9c:	429c      	cmp	r4, r3
  401e9e:	d101      	bne.n	401ea4 <__swbuf_r+0x78>
  401ea0:	68ac      	ldr	r4, [r5, #8]
  401ea2:	e7d0      	b.n	401e46 <__swbuf_r+0x1a>
  401ea4:	4b09      	ldr	r3, [pc, #36]	; (401ecc <__swbuf_r+0xa0>)
  401ea6:	429c      	cmp	r4, r3
  401ea8:	bf08      	it	eq
  401eaa:	68ec      	ldreq	r4, [r5, #12]
  401eac:	e7cb      	b.n	401e46 <__swbuf_r+0x1a>
  401eae:	4621      	mov	r1, r4
  401eb0:	4628      	mov	r0, r5
  401eb2:	f000 f80d 	bl	401ed0 <__swsetup_r>
  401eb6:	2800      	cmp	r0, #0
  401eb8:	d0cc      	beq.n	401e54 <__swbuf_r+0x28>
  401eba:	f04f 37ff 	mov.w	r7, #4294967295
  401ebe:	4638      	mov	r0, r7
  401ec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  401ec2:	bf00      	nop
  401ec4:	00402d10 	.word	0x00402d10
  401ec8:	00402d30 	.word	0x00402d30
  401ecc:	00402cf0 	.word	0x00402cf0

00401ed0 <__swsetup_r>:
  401ed0:	4b32      	ldr	r3, [pc, #200]	; (401f9c <__swsetup_r+0xcc>)
  401ed2:	b570      	push	{r4, r5, r6, lr}
  401ed4:	681d      	ldr	r5, [r3, #0]
  401ed6:	4606      	mov	r6, r0
  401ed8:	460c      	mov	r4, r1
  401eda:	b125      	cbz	r5, 401ee6 <__swsetup_r+0x16>
  401edc:	69ab      	ldr	r3, [r5, #24]
  401ede:	b913      	cbnz	r3, 401ee6 <__swsetup_r+0x16>
  401ee0:	4628      	mov	r0, r5
  401ee2:	f000 f955 	bl	402190 <__sinit>
  401ee6:	4b2e      	ldr	r3, [pc, #184]	; (401fa0 <__swsetup_r+0xd0>)
  401ee8:	429c      	cmp	r4, r3
  401eea:	d10f      	bne.n	401f0c <__swsetup_r+0x3c>
  401eec:	686c      	ldr	r4, [r5, #4]
  401eee:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401ef2:	b29a      	uxth	r2, r3
  401ef4:	0715      	lsls	r5, r2, #28
  401ef6:	d42c      	bmi.n	401f52 <__swsetup_r+0x82>
  401ef8:	06d0      	lsls	r0, r2, #27
  401efa:	d411      	bmi.n	401f20 <__swsetup_r+0x50>
  401efc:	2209      	movs	r2, #9
  401efe:	6032      	str	r2, [r6, #0]
  401f00:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  401f04:	81a3      	strh	r3, [r4, #12]
  401f06:	f04f 30ff 	mov.w	r0, #4294967295
  401f0a:	bd70      	pop	{r4, r5, r6, pc}
  401f0c:	4b25      	ldr	r3, [pc, #148]	; (401fa4 <__swsetup_r+0xd4>)
  401f0e:	429c      	cmp	r4, r3
  401f10:	d101      	bne.n	401f16 <__swsetup_r+0x46>
  401f12:	68ac      	ldr	r4, [r5, #8]
  401f14:	e7eb      	b.n	401eee <__swsetup_r+0x1e>
  401f16:	4b24      	ldr	r3, [pc, #144]	; (401fa8 <__swsetup_r+0xd8>)
  401f18:	429c      	cmp	r4, r3
  401f1a:	bf08      	it	eq
  401f1c:	68ec      	ldreq	r4, [r5, #12]
  401f1e:	e7e6      	b.n	401eee <__swsetup_r+0x1e>
  401f20:	0751      	lsls	r1, r2, #29
  401f22:	d512      	bpl.n	401f4a <__swsetup_r+0x7a>
  401f24:	6b61      	ldr	r1, [r4, #52]	; 0x34
  401f26:	b141      	cbz	r1, 401f3a <__swsetup_r+0x6a>
  401f28:	f104 0344 	add.w	r3, r4, #68	; 0x44
  401f2c:	4299      	cmp	r1, r3
  401f2e:	d002      	beq.n	401f36 <__swsetup_r+0x66>
  401f30:	4630      	mov	r0, r6
  401f32:	f7ff fdf1 	bl	401b18 <_free_r>
  401f36:	2300      	movs	r3, #0
  401f38:	6363      	str	r3, [r4, #52]	; 0x34
  401f3a:	89a3      	ldrh	r3, [r4, #12]
  401f3c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
  401f40:	81a3      	strh	r3, [r4, #12]
  401f42:	2300      	movs	r3, #0
  401f44:	6063      	str	r3, [r4, #4]
  401f46:	6923      	ldr	r3, [r4, #16]
  401f48:	6023      	str	r3, [r4, #0]
  401f4a:	89a3      	ldrh	r3, [r4, #12]
  401f4c:	f043 0308 	orr.w	r3, r3, #8
  401f50:	81a3      	strh	r3, [r4, #12]
  401f52:	6923      	ldr	r3, [r4, #16]
  401f54:	b94b      	cbnz	r3, 401f6a <__swsetup_r+0x9a>
  401f56:	89a3      	ldrh	r3, [r4, #12]
  401f58:	f403 7320 	and.w	r3, r3, #640	; 0x280
  401f5c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  401f60:	d003      	beq.n	401f6a <__swsetup_r+0x9a>
  401f62:	4621      	mov	r1, r4
  401f64:	4630      	mov	r0, r6
  401f66:	f000 f9c1 	bl	4022ec <__smakebuf_r>
  401f6a:	89a2      	ldrh	r2, [r4, #12]
  401f6c:	f012 0301 	ands.w	r3, r2, #1
  401f70:	d00c      	beq.n	401f8c <__swsetup_r+0xbc>
  401f72:	2300      	movs	r3, #0
  401f74:	60a3      	str	r3, [r4, #8]
  401f76:	6963      	ldr	r3, [r4, #20]
  401f78:	425b      	negs	r3, r3
  401f7a:	61a3      	str	r3, [r4, #24]
  401f7c:	6923      	ldr	r3, [r4, #16]
  401f7e:	b953      	cbnz	r3, 401f96 <__swsetup_r+0xc6>
  401f80:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  401f84:	f013 0080 	ands.w	r0, r3, #128	; 0x80
  401f88:	d1ba      	bne.n	401f00 <__swsetup_r+0x30>
  401f8a:	bd70      	pop	{r4, r5, r6, pc}
  401f8c:	0792      	lsls	r2, r2, #30
  401f8e:	bf58      	it	pl
  401f90:	6963      	ldrpl	r3, [r4, #20]
  401f92:	60a3      	str	r3, [r4, #8]
  401f94:	e7f2      	b.n	401f7c <__swsetup_r+0xac>
  401f96:	2000      	movs	r0, #0
  401f98:	e7f7      	b.n	401f8a <__swsetup_r+0xba>
  401f9a:	bf00      	nop
  401f9c:	20400000 	.word	0x20400000
  401fa0:	00402d10 	.word	0x00402d10
  401fa4:	00402d30 	.word	0x00402d30
  401fa8:	00402cf0 	.word	0x00402cf0

00401fac <__sflush_r>:
  401fac:	898a      	ldrh	r2, [r1, #12]
  401fae:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  401fb2:	4605      	mov	r5, r0
  401fb4:	0710      	lsls	r0, r2, #28
  401fb6:	460c      	mov	r4, r1
  401fb8:	d45a      	bmi.n	402070 <__sflush_r+0xc4>
  401fba:	684b      	ldr	r3, [r1, #4]
  401fbc:	2b00      	cmp	r3, #0
  401fbe:	dc05      	bgt.n	401fcc <__sflush_r+0x20>
  401fc0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
  401fc2:	2b00      	cmp	r3, #0
  401fc4:	dc02      	bgt.n	401fcc <__sflush_r+0x20>
  401fc6:	2000      	movs	r0, #0
  401fc8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  401fcc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  401fce:	2e00      	cmp	r6, #0
  401fd0:	d0f9      	beq.n	401fc6 <__sflush_r+0x1a>
  401fd2:	2300      	movs	r3, #0
  401fd4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
  401fd8:	682f      	ldr	r7, [r5, #0]
  401fda:	602b      	str	r3, [r5, #0]
  401fdc:	d033      	beq.n	402046 <__sflush_r+0x9a>
  401fde:	6d60      	ldr	r0, [r4, #84]	; 0x54
  401fe0:	89a3      	ldrh	r3, [r4, #12]
  401fe2:	075a      	lsls	r2, r3, #29
  401fe4:	d505      	bpl.n	401ff2 <__sflush_r+0x46>
  401fe6:	6863      	ldr	r3, [r4, #4]
  401fe8:	1ac0      	subs	r0, r0, r3
  401fea:	6b63      	ldr	r3, [r4, #52]	; 0x34
  401fec:	b10b      	cbz	r3, 401ff2 <__sflush_r+0x46>
  401fee:	6c23      	ldr	r3, [r4, #64]	; 0x40
  401ff0:	1ac0      	subs	r0, r0, r3
  401ff2:	2300      	movs	r3, #0
  401ff4:	4602      	mov	r2, r0
  401ff6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
  401ff8:	6a21      	ldr	r1, [r4, #32]
  401ffa:	4628      	mov	r0, r5
  401ffc:	47b0      	blx	r6
  401ffe:	1c43      	adds	r3, r0, #1
  402000:	89a3      	ldrh	r3, [r4, #12]
  402002:	d106      	bne.n	402012 <__sflush_r+0x66>
  402004:	6829      	ldr	r1, [r5, #0]
  402006:	291d      	cmp	r1, #29
  402008:	d84b      	bhi.n	4020a2 <__sflush_r+0xf6>
  40200a:	4a2b      	ldr	r2, [pc, #172]	; (4020b8 <__sflush_r+0x10c>)
  40200c:	40ca      	lsrs	r2, r1
  40200e:	07d6      	lsls	r6, r2, #31
  402010:	d547      	bpl.n	4020a2 <__sflush_r+0xf6>
  402012:	2200      	movs	r2, #0
  402014:	6062      	str	r2, [r4, #4]
  402016:	04d9      	lsls	r1, r3, #19
  402018:	6922      	ldr	r2, [r4, #16]
  40201a:	6022      	str	r2, [r4, #0]
  40201c:	d504      	bpl.n	402028 <__sflush_r+0x7c>
  40201e:	1c42      	adds	r2, r0, #1
  402020:	d101      	bne.n	402026 <__sflush_r+0x7a>
  402022:	682b      	ldr	r3, [r5, #0]
  402024:	b903      	cbnz	r3, 402028 <__sflush_r+0x7c>
  402026:	6560      	str	r0, [r4, #84]	; 0x54
  402028:	6b61      	ldr	r1, [r4, #52]	; 0x34
  40202a:	602f      	str	r7, [r5, #0]
  40202c:	2900      	cmp	r1, #0
  40202e:	d0ca      	beq.n	401fc6 <__sflush_r+0x1a>
  402030:	f104 0344 	add.w	r3, r4, #68	; 0x44
  402034:	4299      	cmp	r1, r3
  402036:	d002      	beq.n	40203e <__sflush_r+0x92>
  402038:	4628      	mov	r0, r5
  40203a:	f7ff fd6d 	bl	401b18 <_free_r>
  40203e:	2000      	movs	r0, #0
  402040:	6360      	str	r0, [r4, #52]	; 0x34
  402042:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402046:	6a21      	ldr	r1, [r4, #32]
  402048:	2301      	movs	r3, #1
  40204a:	4628      	mov	r0, r5
  40204c:	47b0      	blx	r6
  40204e:	1c41      	adds	r1, r0, #1
  402050:	d1c6      	bne.n	401fe0 <__sflush_r+0x34>
  402052:	682b      	ldr	r3, [r5, #0]
  402054:	2b00      	cmp	r3, #0
  402056:	d0c3      	beq.n	401fe0 <__sflush_r+0x34>
  402058:	2b1d      	cmp	r3, #29
  40205a:	d001      	beq.n	402060 <__sflush_r+0xb4>
  40205c:	2b16      	cmp	r3, #22
  40205e:	d101      	bne.n	402064 <__sflush_r+0xb8>
  402060:	602f      	str	r7, [r5, #0]
  402062:	e7b0      	b.n	401fc6 <__sflush_r+0x1a>
  402064:	89a3      	ldrh	r3, [r4, #12]
  402066:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  40206a:	81a3      	strh	r3, [r4, #12]
  40206c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402070:	690f      	ldr	r7, [r1, #16]
  402072:	2f00      	cmp	r7, #0
  402074:	d0a7      	beq.n	401fc6 <__sflush_r+0x1a>
  402076:	0793      	lsls	r3, r2, #30
  402078:	680e      	ldr	r6, [r1, #0]
  40207a:	bf08      	it	eq
  40207c:	694b      	ldreq	r3, [r1, #20]
  40207e:	600f      	str	r7, [r1, #0]
  402080:	bf18      	it	ne
  402082:	2300      	movne	r3, #0
  402084:	eba6 0807 	sub.w	r8, r6, r7
  402088:	608b      	str	r3, [r1, #8]
  40208a:	f1b8 0f00 	cmp.w	r8, #0
  40208e:	dd9a      	ble.n	401fc6 <__sflush_r+0x1a>
  402090:	4643      	mov	r3, r8
  402092:	463a      	mov	r2, r7
  402094:	6a21      	ldr	r1, [r4, #32]
  402096:	6aa6      	ldr	r6, [r4, #40]	; 0x28
  402098:	4628      	mov	r0, r5
  40209a:	47b0      	blx	r6
  40209c:	2800      	cmp	r0, #0
  40209e:	dc07      	bgt.n	4020b0 <__sflush_r+0x104>
  4020a0:	89a3      	ldrh	r3, [r4, #12]
  4020a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  4020a6:	81a3      	strh	r3, [r4, #12]
  4020a8:	f04f 30ff 	mov.w	r0, #4294967295
  4020ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4020b0:	4407      	add	r7, r0
  4020b2:	eba8 0800 	sub.w	r8, r8, r0
  4020b6:	e7e8      	b.n	40208a <__sflush_r+0xde>
  4020b8:	20400001 	.word	0x20400001

004020bc <_fflush_r>:
  4020bc:	b538      	push	{r3, r4, r5, lr}
  4020be:	690b      	ldr	r3, [r1, #16]
  4020c0:	4605      	mov	r5, r0
  4020c2:	460c      	mov	r4, r1
  4020c4:	b1db      	cbz	r3, 4020fe <_fflush_r+0x42>
  4020c6:	b118      	cbz	r0, 4020d0 <_fflush_r+0x14>
  4020c8:	6983      	ldr	r3, [r0, #24]
  4020ca:	b90b      	cbnz	r3, 4020d0 <_fflush_r+0x14>
  4020cc:	f000 f860 	bl	402190 <__sinit>
  4020d0:	4b0c      	ldr	r3, [pc, #48]	; (402104 <_fflush_r+0x48>)
  4020d2:	429c      	cmp	r4, r3
  4020d4:	d109      	bne.n	4020ea <_fflush_r+0x2e>
  4020d6:	686c      	ldr	r4, [r5, #4]
  4020d8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  4020dc:	b17b      	cbz	r3, 4020fe <_fflush_r+0x42>
  4020de:	4621      	mov	r1, r4
  4020e0:	4628      	mov	r0, r5
  4020e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  4020e6:	f7ff bf61 	b.w	401fac <__sflush_r>
  4020ea:	4b07      	ldr	r3, [pc, #28]	; (402108 <_fflush_r+0x4c>)
  4020ec:	429c      	cmp	r4, r3
  4020ee:	d101      	bne.n	4020f4 <_fflush_r+0x38>
  4020f0:	68ac      	ldr	r4, [r5, #8]
  4020f2:	e7f1      	b.n	4020d8 <_fflush_r+0x1c>
  4020f4:	4b05      	ldr	r3, [pc, #20]	; (40210c <_fflush_r+0x50>)
  4020f6:	429c      	cmp	r4, r3
  4020f8:	bf08      	it	eq
  4020fa:	68ec      	ldreq	r4, [r5, #12]
  4020fc:	e7ec      	b.n	4020d8 <_fflush_r+0x1c>
  4020fe:	2000      	movs	r0, #0
  402100:	bd38      	pop	{r3, r4, r5, pc}
  402102:	bf00      	nop
  402104:	00402d10 	.word	0x00402d10
  402108:	00402d30 	.word	0x00402d30
  40210c:	00402cf0 	.word	0x00402cf0

00402110 <_cleanup_r>:
  402110:	4901      	ldr	r1, [pc, #4]	; (402118 <_cleanup_r+0x8>)
  402112:	f000 b8a9 	b.w	402268 <_fwalk_reent>
  402116:	bf00      	nop
  402118:	004020bd 	.word	0x004020bd

0040211c <std.isra.0>:
  40211c:	2300      	movs	r3, #0
  40211e:	b510      	push	{r4, lr}
  402120:	4604      	mov	r4, r0
  402122:	6003      	str	r3, [r0, #0]
  402124:	6043      	str	r3, [r0, #4]
  402126:	6083      	str	r3, [r0, #8]
  402128:	8181      	strh	r1, [r0, #12]
  40212a:	6643      	str	r3, [r0, #100]	; 0x64
  40212c:	81c2      	strh	r2, [r0, #14]
  40212e:	6103      	str	r3, [r0, #16]
  402130:	6143      	str	r3, [r0, #20]
  402132:	6183      	str	r3, [r0, #24]
  402134:	4619      	mov	r1, r3
  402136:	2208      	movs	r2, #8
  402138:	305c      	adds	r0, #92	; 0x5c
  40213a:	f7ff fce5 	bl	401b08 <memset>
  40213e:	4b05      	ldr	r3, [pc, #20]	; (402154 <std.isra.0+0x38>)
  402140:	6263      	str	r3, [r4, #36]	; 0x24
  402142:	4b05      	ldr	r3, [pc, #20]	; (402158 <std.isra.0+0x3c>)
  402144:	62a3      	str	r3, [r4, #40]	; 0x28
  402146:	4b05      	ldr	r3, [pc, #20]	; (40215c <std.isra.0+0x40>)
  402148:	62e3      	str	r3, [r4, #44]	; 0x2c
  40214a:	4b05      	ldr	r3, [pc, #20]	; (402160 <std.isra.0+0x44>)
  40214c:	6224      	str	r4, [r4, #32]
  40214e:	6323      	str	r3, [r4, #48]	; 0x30
  402150:	bd10      	pop	{r4, pc}
  402152:	bf00      	nop
  402154:	00402919 	.word	0x00402919
  402158:	0040293b 	.word	0x0040293b
  40215c:	00402973 	.word	0x00402973
  402160:	00402997 	.word	0x00402997

00402164 <__sfmoreglue>:
  402164:	b570      	push	{r4, r5, r6, lr}
  402166:	1e4a      	subs	r2, r1, #1
  402168:	2568      	movs	r5, #104	; 0x68
  40216a:	4355      	muls	r5, r2
  40216c:	460e      	mov	r6, r1
  40216e:	f105 0174 	add.w	r1, r5, #116	; 0x74
  402172:	f7ff fd1f 	bl	401bb4 <_malloc_r>
  402176:	4604      	mov	r4, r0
  402178:	b140      	cbz	r0, 40218c <__sfmoreglue+0x28>
  40217a:	2100      	movs	r1, #0
  40217c:	e880 0042 	stmia.w	r0, {r1, r6}
  402180:	300c      	adds	r0, #12
  402182:	60a0      	str	r0, [r4, #8]
  402184:	f105 0268 	add.w	r2, r5, #104	; 0x68
  402188:	f7ff fcbe 	bl	401b08 <memset>
  40218c:	4620      	mov	r0, r4
  40218e:	bd70      	pop	{r4, r5, r6, pc}

00402190 <__sinit>:
  402190:	6983      	ldr	r3, [r0, #24]
  402192:	b510      	push	{r4, lr}
  402194:	4604      	mov	r4, r0
  402196:	bb33      	cbnz	r3, 4021e6 <__sinit+0x56>
  402198:	6483      	str	r3, [r0, #72]	; 0x48
  40219a:	64c3      	str	r3, [r0, #76]	; 0x4c
  40219c:	6503      	str	r3, [r0, #80]	; 0x50
  40219e:	4b12      	ldr	r3, [pc, #72]	; (4021e8 <__sinit+0x58>)
  4021a0:	4a12      	ldr	r2, [pc, #72]	; (4021ec <__sinit+0x5c>)
  4021a2:	681b      	ldr	r3, [r3, #0]
  4021a4:	6282      	str	r2, [r0, #40]	; 0x28
  4021a6:	4298      	cmp	r0, r3
  4021a8:	bf04      	itt	eq
  4021aa:	2301      	moveq	r3, #1
  4021ac:	6183      	streq	r3, [r0, #24]
  4021ae:	f000 f81f 	bl	4021f0 <__sfp>
  4021b2:	6060      	str	r0, [r4, #4]
  4021b4:	4620      	mov	r0, r4
  4021b6:	f000 f81b 	bl	4021f0 <__sfp>
  4021ba:	60a0      	str	r0, [r4, #8]
  4021bc:	4620      	mov	r0, r4
  4021be:	f000 f817 	bl	4021f0 <__sfp>
  4021c2:	2200      	movs	r2, #0
  4021c4:	60e0      	str	r0, [r4, #12]
  4021c6:	2104      	movs	r1, #4
  4021c8:	6860      	ldr	r0, [r4, #4]
  4021ca:	f7ff ffa7 	bl	40211c <std.isra.0>
  4021ce:	2201      	movs	r2, #1
  4021d0:	2109      	movs	r1, #9
  4021d2:	68a0      	ldr	r0, [r4, #8]
  4021d4:	f7ff ffa2 	bl	40211c <std.isra.0>
  4021d8:	2202      	movs	r2, #2
  4021da:	2112      	movs	r1, #18
  4021dc:	68e0      	ldr	r0, [r4, #12]
  4021de:	f7ff ff9d 	bl	40211c <std.isra.0>
  4021e2:	2301      	movs	r3, #1
  4021e4:	61a3      	str	r3, [r4, #24]
  4021e6:	bd10      	pop	{r4, pc}
  4021e8:	00402cec 	.word	0x00402cec
  4021ec:	00402111 	.word	0x00402111

004021f0 <__sfp>:
  4021f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4021f2:	4b1c      	ldr	r3, [pc, #112]	; (402264 <__sfp+0x74>)
  4021f4:	681e      	ldr	r6, [r3, #0]
  4021f6:	69b3      	ldr	r3, [r6, #24]
  4021f8:	4607      	mov	r7, r0
  4021fa:	b913      	cbnz	r3, 402202 <__sfp+0x12>
  4021fc:	4630      	mov	r0, r6
  4021fe:	f7ff ffc7 	bl	402190 <__sinit>
  402202:	3648      	adds	r6, #72	; 0x48
  402204:	68b4      	ldr	r4, [r6, #8]
  402206:	6873      	ldr	r3, [r6, #4]
  402208:	3b01      	subs	r3, #1
  40220a:	d503      	bpl.n	402214 <__sfp+0x24>
  40220c:	6833      	ldr	r3, [r6, #0]
  40220e:	b133      	cbz	r3, 40221e <__sfp+0x2e>
  402210:	6836      	ldr	r6, [r6, #0]
  402212:	e7f7      	b.n	402204 <__sfp+0x14>
  402214:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
  402218:	b16d      	cbz	r5, 402236 <__sfp+0x46>
  40221a:	3468      	adds	r4, #104	; 0x68
  40221c:	e7f4      	b.n	402208 <__sfp+0x18>
  40221e:	2104      	movs	r1, #4
  402220:	4638      	mov	r0, r7
  402222:	f7ff ff9f 	bl	402164 <__sfmoreglue>
  402226:	6030      	str	r0, [r6, #0]
  402228:	2800      	cmp	r0, #0
  40222a:	d1f1      	bne.n	402210 <__sfp+0x20>
  40222c:	230c      	movs	r3, #12
  40222e:	603b      	str	r3, [r7, #0]
  402230:	4604      	mov	r4, r0
  402232:	4620      	mov	r0, r4
  402234:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402236:	f64f 73ff 	movw	r3, #65535	; 0xffff
  40223a:	81e3      	strh	r3, [r4, #14]
  40223c:	2301      	movs	r3, #1
  40223e:	81a3      	strh	r3, [r4, #12]
  402240:	6665      	str	r5, [r4, #100]	; 0x64
  402242:	6025      	str	r5, [r4, #0]
  402244:	60a5      	str	r5, [r4, #8]
  402246:	6065      	str	r5, [r4, #4]
  402248:	6125      	str	r5, [r4, #16]
  40224a:	6165      	str	r5, [r4, #20]
  40224c:	61a5      	str	r5, [r4, #24]
  40224e:	2208      	movs	r2, #8
  402250:	4629      	mov	r1, r5
  402252:	f104 005c 	add.w	r0, r4, #92	; 0x5c
  402256:	f7ff fc57 	bl	401b08 <memset>
  40225a:	6365      	str	r5, [r4, #52]	; 0x34
  40225c:	63a5      	str	r5, [r4, #56]	; 0x38
  40225e:	64a5      	str	r5, [r4, #72]	; 0x48
  402260:	64e5      	str	r5, [r4, #76]	; 0x4c
  402262:	e7e6      	b.n	402232 <__sfp+0x42>
  402264:	00402cec 	.word	0x00402cec

00402268 <_fwalk_reent>:
  402268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40226c:	4680      	mov	r8, r0
  40226e:	4689      	mov	r9, r1
  402270:	f100 0448 	add.w	r4, r0, #72	; 0x48
  402274:	2600      	movs	r6, #0
  402276:	b914      	cbnz	r4, 40227e <_fwalk_reent+0x16>
  402278:	4630      	mov	r0, r6
  40227a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40227e:	68a5      	ldr	r5, [r4, #8]
  402280:	6867      	ldr	r7, [r4, #4]
  402282:	3f01      	subs	r7, #1
  402284:	d501      	bpl.n	40228a <_fwalk_reent+0x22>
  402286:	6824      	ldr	r4, [r4, #0]
  402288:	e7f5      	b.n	402276 <_fwalk_reent+0xe>
  40228a:	89ab      	ldrh	r3, [r5, #12]
  40228c:	2b01      	cmp	r3, #1
  40228e:	d907      	bls.n	4022a0 <_fwalk_reent+0x38>
  402290:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
  402294:	3301      	adds	r3, #1
  402296:	d003      	beq.n	4022a0 <_fwalk_reent+0x38>
  402298:	4629      	mov	r1, r5
  40229a:	4640      	mov	r0, r8
  40229c:	47c8      	blx	r9
  40229e:	4306      	orrs	r6, r0
  4022a0:	3568      	adds	r5, #104	; 0x68
  4022a2:	e7ee      	b.n	402282 <_fwalk_reent+0x1a>

004022a4 <__swhatbuf_r>:
  4022a4:	b570      	push	{r4, r5, r6, lr}
  4022a6:	460e      	mov	r6, r1
  4022a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  4022ac:	2900      	cmp	r1, #0
  4022ae:	b090      	sub	sp, #64	; 0x40
  4022b0:	4614      	mov	r4, r2
  4022b2:	461d      	mov	r5, r3
  4022b4:	da07      	bge.n	4022c6 <__swhatbuf_r+0x22>
  4022b6:	2300      	movs	r3, #0
  4022b8:	602b      	str	r3, [r5, #0]
  4022ba:	89b3      	ldrh	r3, [r6, #12]
  4022bc:	061a      	lsls	r2, r3, #24
  4022be:	d410      	bmi.n	4022e2 <__swhatbuf_r+0x3e>
  4022c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  4022c4:	e00e      	b.n	4022e4 <__swhatbuf_r+0x40>
  4022c6:	aa01      	add	r2, sp, #4
  4022c8:	f000 fb8c 	bl	4029e4 <_fstat_r>
  4022cc:	2800      	cmp	r0, #0
  4022ce:	dbf2      	blt.n	4022b6 <__swhatbuf_r+0x12>
  4022d0:	9a02      	ldr	r2, [sp, #8]
  4022d2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
  4022d6:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
  4022da:	425a      	negs	r2, r3
  4022dc:	415a      	adcs	r2, r3
  4022de:	602a      	str	r2, [r5, #0]
  4022e0:	e7ee      	b.n	4022c0 <__swhatbuf_r+0x1c>
  4022e2:	2340      	movs	r3, #64	; 0x40
  4022e4:	2000      	movs	r0, #0
  4022e6:	6023      	str	r3, [r4, #0]
  4022e8:	b010      	add	sp, #64	; 0x40
  4022ea:	bd70      	pop	{r4, r5, r6, pc}

004022ec <__smakebuf_r>:
  4022ec:	898b      	ldrh	r3, [r1, #12]
  4022ee:	b573      	push	{r0, r1, r4, r5, r6, lr}
  4022f0:	079d      	lsls	r5, r3, #30
  4022f2:	4606      	mov	r6, r0
  4022f4:	460c      	mov	r4, r1
  4022f6:	d507      	bpl.n	402308 <__smakebuf_r+0x1c>
  4022f8:	f104 0347 	add.w	r3, r4, #71	; 0x47
  4022fc:	6023      	str	r3, [r4, #0]
  4022fe:	6123      	str	r3, [r4, #16]
  402300:	2301      	movs	r3, #1
  402302:	6163      	str	r3, [r4, #20]
  402304:	b002      	add	sp, #8
  402306:	bd70      	pop	{r4, r5, r6, pc}
  402308:	ab01      	add	r3, sp, #4
  40230a:	466a      	mov	r2, sp
  40230c:	f7ff ffca 	bl	4022a4 <__swhatbuf_r>
  402310:	9900      	ldr	r1, [sp, #0]
  402312:	4605      	mov	r5, r0
  402314:	4630      	mov	r0, r6
  402316:	f7ff fc4d 	bl	401bb4 <_malloc_r>
  40231a:	b948      	cbnz	r0, 402330 <__smakebuf_r+0x44>
  40231c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  402320:	059a      	lsls	r2, r3, #22
  402322:	d4ef      	bmi.n	402304 <__smakebuf_r+0x18>
  402324:	f023 0303 	bic.w	r3, r3, #3
  402328:	f043 0302 	orr.w	r3, r3, #2
  40232c:	81a3      	strh	r3, [r4, #12]
  40232e:	e7e3      	b.n	4022f8 <__smakebuf_r+0xc>
  402330:	4b0d      	ldr	r3, [pc, #52]	; (402368 <__smakebuf_r+0x7c>)
  402332:	62b3      	str	r3, [r6, #40]	; 0x28
  402334:	89a3      	ldrh	r3, [r4, #12]
  402336:	6020      	str	r0, [r4, #0]
  402338:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  40233c:	81a3      	strh	r3, [r4, #12]
  40233e:	9b00      	ldr	r3, [sp, #0]
  402340:	6163      	str	r3, [r4, #20]
  402342:	9b01      	ldr	r3, [sp, #4]
  402344:	6120      	str	r0, [r4, #16]
  402346:	b15b      	cbz	r3, 402360 <__smakebuf_r+0x74>
  402348:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40234c:	4630      	mov	r0, r6
  40234e:	f000 fb5b 	bl	402a08 <_isatty_r>
  402352:	b128      	cbz	r0, 402360 <__smakebuf_r+0x74>
  402354:	89a3      	ldrh	r3, [r4, #12]
  402356:	f023 0303 	bic.w	r3, r3, #3
  40235a:	f043 0301 	orr.w	r3, r3, #1
  40235e:	81a3      	strh	r3, [r4, #12]
  402360:	89a3      	ldrh	r3, [r4, #12]
  402362:	431d      	orrs	r5, r3
  402364:	81a5      	strh	r5, [r4, #12]
  402366:	e7cd      	b.n	402304 <__smakebuf_r+0x18>
  402368:	00402111 	.word	0x00402111

0040236c <__malloc_lock>:
  40236c:	4770      	bx	lr

0040236e <__malloc_unlock>:
  40236e:	4770      	bx	lr

00402370 <__sfputc_r>:
  402370:	6893      	ldr	r3, [r2, #8]
  402372:	3b01      	subs	r3, #1
  402374:	2b00      	cmp	r3, #0
  402376:	b410      	push	{r4}
  402378:	6093      	str	r3, [r2, #8]
  40237a:	da08      	bge.n	40238e <__sfputc_r+0x1e>
  40237c:	6994      	ldr	r4, [r2, #24]
  40237e:	42a3      	cmp	r3, r4
  402380:	db02      	blt.n	402388 <__sfputc_r+0x18>
  402382:	b2cb      	uxtb	r3, r1
  402384:	2b0a      	cmp	r3, #10
  402386:	d102      	bne.n	40238e <__sfputc_r+0x1e>
  402388:	bc10      	pop	{r4}
  40238a:	f7ff bd4f 	b.w	401e2c <__swbuf_r>
  40238e:	6813      	ldr	r3, [r2, #0]
  402390:	1c58      	adds	r0, r3, #1
  402392:	6010      	str	r0, [r2, #0]
  402394:	7019      	strb	r1, [r3, #0]
  402396:	b2c8      	uxtb	r0, r1
  402398:	bc10      	pop	{r4}
  40239a:	4770      	bx	lr

0040239c <__sfputs_r>:
  40239c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40239e:	4606      	mov	r6, r0
  4023a0:	460f      	mov	r7, r1
  4023a2:	4614      	mov	r4, r2
  4023a4:	18d5      	adds	r5, r2, r3
  4023a6:	42ac      	cmp	r4, r5
  4023a8:	d101      	bne.n	4023ae <__sfputs_r+0x12>
  4023aa:	2000      	movs	r0, #0
  4023ac:	e007      	b.n	4023be <__sfputs_r+0x22>
  4023ae:	463a      	mov	r2, r7
  4023b0:	f814 1b01 	ldrb.w	r1, [r4], #1
  4023b4:	4630      	mov	r0, r6
  4023b6:	f7ff ffdb 	bl	402370 <__sfputc_r>
  4023ba:	1c43      	adds	r3, r0, #1
  4023bc:	d1f3      	bne.n	4023a6 <__sfputs_r+0xa>
  4023be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

004023c0 <_vfiprintf_r>:
  4023c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4023c4:	b09d      	sub	sp, #116	; 0x74
  4023c6:	460c      	mov	r4, r1
  4023c8:	4617      	mov	r7, r2
  4023ca:	9303      	str	r3, [sp, #12]
  4023cc:	4606      	mov	r6, r0
  4023ce:	b118      	cbz	r0, 4023d8 <_vfiprintf_r+0x18>
  4023d0:	6983      	ldr	r3, [r0, #24]
  4023d2:	b90b      	cbnz	r3, 4023d8 <_vfiprintf_r+0x18>
  4023d4:	f7ff fedc 	bl	402190 <__sinit>
  4023d8:	4b7c      	ldr	r3, [pc, #496]	; (4025cc <_vfiprintf_r+0x20c>)
  4023da:	429c      	cmp	r4, r3
  4023dc:	d157      	bne.n	40248e <_vfiprintf_r+0xce>
  4023de:	6874      	ldr	r4, [r6, #4]
  4023e0:	89a3      	ldrh	r3, [r4, #12]
  4023e2:	0718      	lsls	r0, r3, #28
  4023e4:	d55d      	bpl.n	4024a2 <_vfiprintf_r+0xe2>
  4023e6:	6923      	ldr	r3, [r4, #16]
  4023e8:	2b00      	cmp	r3, #0
  4023ea:	d05a      	beq.n	4024a2 <_vfiprintf_r+0xe2>
  4023ec:	2300      	movs	r3, #0
  4023ee:	9309      	str	r3, [sp, #36]	; 0x24
  4023f0:	2320      	movs	r3, #32
  4023f2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  4023f6:	2330      	movs	r3, #48	; 0x30
  4023f8:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  4023fc:	f04f 0b01 	mov.w	fp, #1
  402400:	46b8      	mov	r8, r7
  402402:	4645      	mov	r5, r8
  402404:	f815 3b01 	ldrb.w	r3, [r5], #1
  402408:	2b00      	cmp	r3, #0
  40240a:	d155      	bne.n	4024b8 <_vfiprintf_r+0xf8>
  40240c:	ebb8 0a07 	subs.w	sl, r8, r7
  402410:	d00b      	beq.n	40242a <_vfiprintf_r+0x6a>
  402412:	4653      	mov	r3, sl
  402414:	463a      	mov	r2, r7
  402416:	4621      	mov	r1, r4
  402418:	4630      	mov	r0, r6
  40241a:	f7ff ffbf 	bl	40239c <__sfputs_r>
  40241e:	3001      	adds	r0, #1
  402420:	f000 80c4 	beq.w	4025ac <_vfiprintf_r+0x1ec>
  402424:	9b09      	ldr	r3, [sp, #36]	; 0x24
  402426:	4453      	add	r3, sl
  402428:	9309      	str	r3, [sp, #36]	; 0x24
  40242a:	f898 3000 	ldrb.w	r3, [r8]
  40242e:	2b00      	cmp	r3, #0
  402430:	f000 80bc 	beq.w	4025ac <_vfiprintf_r+0x1ec>
  402434:	2300      	movs	r3, #0
  402436:	f04f 32ff 	mov.w	r2, #4294967295
  40243a:	9304      	str	r3, [sp, #16]
  40243c:	9307      	str	r3, [sp, #28]
  40243e:	9205      	str	r2, [sp, #20]
  402440:	9306      	str	r3, [sp, #24]
  402442:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  402446:	931a      	str	r3, [sp, #104]	; 0x68
  402448:	2205      	movs	r2, #5
  40244a:	7829      	ldrb	r1, [r5, #0]
  40244c:	4860      	ldr	r0, [pc, #384]	; (4025d0 <_vfiprintf_r+0x210>)
  40244e:	f000 faff 	bl	402a50 <memchr>
  402452:	f105 0801 	add.w	r8, r5, #1
  402456:	9b04      	ldr	r3, [sp, #16]
  402458:	2800      	cmp	r0, #0
  40245a:	d131      	bne.n	4024c0 <_vfiprintf_r+0x100>
  40245c:	06d9      	lsls	r1, r3, #27
  40245e:	bf44      	itt	mi
  402460:	2220      	movmi	r2, #32
  402462:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  402466:	071a      	lsls	r2, r3, #28
  402468:	bf44      	itt	mi
  40246a:	222b      	movmi	r2, #43	; 0x2b
  40246c:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
  402470:	782a      	ldrb	r2, [r5, #0]
  402472:	2a2a      	cmp	r2, #42	; 0x2a
  402474:	d02c      	beq.n	4024d0 <_vfiprintf_r+0x110>
  402476:	9a07      	ldr	r2, [sp, #28]
  402478:	2100      	movs	r1, #0
  40247a:	200a      	movs	r0, #10
  40247c:	46a8      	mov	r8, r5
  40247e:	3501      	adds	r5, #1
  402480:	f898 3000 	ldrb.w	r3, [r8]
  402484:	3b30      	subs	r3, #48	; 0x30
  402486:	2b09      	cmp	r3, #9
  402488:	d96d      	bls.n	402566 <_vfiprintf_r+0x1a6>
  40248a:	b371      	cbz	r1, 4024ea <_vfiprintf_r+0x12a>
  40248c:	e026      	b.n	4024dc <_vfiprintf_r+0x11c>
  40248e:	4b51      	ldr	r3, [pc, #324]	; (4025d4 <_vfiprintf_r+0x214>)
  402490:	429c      	cmp	r4, r3
  402492:	d101      	bne.n	402498 <_vfiprintf_r+0xd8>
  402494:	68b4      	ldr	r4, [r6, #8]
  402496:	e7a3      	b.n	4023e0 <_vfiprintf_r+0x20>
  402498:	4b4f      	ldr	r3, [pc, #316]	; (4025d8 <_vfiprintf_r+0x218>)
  40249a:	429c      	cmp	r4, r3
  40249c:	bf08      	it	eq
  40249e:	68f4      	ldreq	r4, [r6, #12]
  4024a0:	e79e      	b.n	4023e0 <_vfiprintf_r+0x20>
  4024a2:	4621      	mov	r1, r4
  4024a4:	4630      	mov	r0, r6
  4024a6:	f7ff fd13 	bl	401ed0 <__swsetup_r>
  4024aa:	2800      	cmp	r0, #0
  4024ac:	d09e      	beq.n	4023ec <_vfiprintf_r+0x2c>
  4024ae:	f04f 30ff 	mov.w	r0, #4294967295
  4024b2:	b01d      	add	sp, #116	; 0x74
  4024b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4024b8:	2b25      	cmp	r3, #37	; 0x25
  4024ba:	d0a7      	beq.n	40240c <_vfiprintf_r+0x4c>
  4024bc:	46a8      	mov	r8, r5
  4024be:	e7a0      	b.n	402402 <_vfiprintf_r+0x42>
  4024c0:	4a43      	ldr	r2, [pc, #268]	; (4025d0 <_vfiprintf_r+0x210>)
  4024c2:	1a80      	subs	r0, r0, r2
  4024c4:	fa0b f000 	lsl.w	r0, fp, r0
  4024c8:	4318      	orrs	r0, r3
  4024ca:	9004      	str	r0, [sp, #16]
  4024cc:	4645      	mov	r5, r8
  4024ce:	e7bb      	b.n	402448 <_vfiprintf_r+0x88>
  4024d0:	9a03      	ldr	r2, [sp, #12]
  4024d2:	1d11      	adds	r1, r2, #4
  4024d4:	6812      	ldr	r2, [r2, #0]
  4024d6:	9103      	str	r1, [sp, #12]
  4024d8:	2a00      	cmp	r2, #0
  4024da:	db01      	blt.n	4024e0 <_vfiprintf_r+0x120>
  4024dc:	9207      	str	r2, [sp, #28]
  4024de:	e004      	b.n	4024ea <_vfiprintf_r+0x12a>
  4024e0:	4252      	negs	r2, r2
  4024e2:	f043 0302 	orr.w	r3, r3, #2
  4024e6:	9207      	str	r2, [sp, #28]
  4024e8:	9304      	str	r3, [sp, #16]
  4024ea:	f898 3000 	ldrb.w	r3, [r8]
  4024ee:	2b2e      	cmp	r3, #46	; 0x2e
  4024f0:	d110      	bne.n	402514 <_vfiprintf_r+0x154>
  4024f2:	f898 3001 	ldrb.w	r3, [r8, #1]
  4024f6:	2b2a      	cmp	r3, #42	; 0x2a
  4024f8:	f108 0101 	add.w	r1, r8, #1
  4024fc:	d137      	bne.n	40256e <_vfiprintf_r+0x1ae>
  4024fe:	9b03      	ldr	r3, [sp, #12]
  402500:	1d1a      	adds	r2, r3, #4
  402502:	681b      	ldr	r3, [r3, #0]
  402504:	9203      	str	r2, [sp, #12]
  402506:	2b00      	cmp	r3, #0
  402508:	bfb8      	it	lt
  40250a:	f04f 33ff 	movlt.w	r3, #4294967295
  40250e:	f108 0802 	add.w	r8, r8, #2
  402512:	9305      	str	r3, [sp, #20]
  402514:	4d31      	ldr	r5, [pc, #196]	; (4025dc <_vfiprintf_r+0x21c>)
  402516:	f898 1000 	ldrb.w	r1, [r8]
  40251a:	2203      	movs	r2, #3
  40251c:	4628      	mov	r0, r5
  40251e:	f000 fa97 	bl	402a50 <memchr>
  402522:	b140      	cbz	r0, 402536 <_vfiprintf_r+0x176>
  402524:	2340      	movs	r3, #64	; 0x40
  402526:	1b40      	subs	r0, r0, r5
  402528:	fa03 f000 	lsl.w	r0, r3, r0
  40252c:	9b04      	ldr	r3, [sp, #16]
  40252e:	4303      	orrs	r3, r0
  402530:	9304      	str	r3, [sp, #16]
  402532:	f108 0801 	add.w	r8, r8, #1
  402536:	f898 1000 	ldrb.w	r1, [r8]
  40253a:	4829      	ldr	r0, [pc, #164]	; (4025e0 <_vfiprintf_r+0x220>)
  40253c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  402540:	2206      	movs	r2, #6
  402542:	f108 0701 	add.w	r7, r8, #1
  402546:	f000 fa83 	bl	402a50 <memchr>
  40254a:	2800      	cmp	r0, #0
  40254c:	d034      	beq.n	4025b8 <_vfiprintf_r+0x1f8>
  40254e:	4b25      	ldr	r3, [pc, #148]	; (4025e4 <_vfiprintf_r+0x224>)
  402550:	bb03      	cbnz	r3, 402594 <_vfiprintf_r+0x1d4>
  402552:	9b03      	ldr	r3, [sp, #12]
  402554:	3307      	adds	r3, #7
  402556:	f023 0307 	bic.w	r3, r3, #7
  40255a:	3308      	adds	r3, #8
  40255c:	9303      	str	r3, [sp, #12]
  40255e:	9b09      	ldr	r3, [sp, #36]	; 0x24
  402560:	444b      	add	r3, r9
  402562:	9309      	str	r3, [sp, #36]	; 0x24
  402564:	e74c      	b.n	402400 <_vfiprintf_r+0x40>
  402566:	fb00 3202 	mla	r2, r0, r2, r3
  40256a:	2101      	movs	r1, #1
  40256c:	e786      	b.n	40247c <_vfiprintf_r+0xbc>
  40256e:	2300      	movs	r3, #0
  402570:	9305      	str	r3, [sp, #20]
  402572:	4618      	mov	r0, r3
  402574:	250a      	movs	r5, #10
  402576:	4688      	mov	r8, r1
  402578:	3101      	adds	r1, #1
  40257a:	f898 2000 	ldrb.w	r2, [r8]
  40257e:	3a30      	subs	r2, #48	; 0x30
  402580:	2a09      	cmp	r2, #9
  402582:	d903      	bls.n	40258c <_vfiprintf_r+0x1cc>
  402584:	2b00      	cmp	r3, #0
  402586:	d0c5      	beq.n	402514 <_vfiprintf_r+0x154>
  402588:	9005      	str	r0, [sp, #20]
  40258a:	e7c3      	b.n	402514 <_vfiprintf_r+0x154>
  40258c:	fb05 2000 	mla	r0, r5, r0, r2
  402590:	2301      	movs	r3, #1
  402592:	e7f0      	b.n	402576 <_vfiprintf_r+0x1b6>
  402594:	ab03      	add	r3, sp, #12
  402596:	9300      	str	r3, [sp, #0]
  402598:	4622      	mov	r2, r4
  40259a:	4b13      	ldr	r3, [pc, #76]	; (4025e8 <_vfiprintf_r+0x228>)
  40259c:	a904      	add	r1, sp, #16
  40259e:	4630      	mov	r0, r6
  4025a0:	f3af 8000 	nop.w
  4025a4:	f1b0 3fff 	cmp.w	r0, #4294967295
  4025a8:	4681      	mov	r9, r0
  4025aa:	d1d8      	bne.n	40255e <_vfiprintf_r+0x19e>
  4025ac:	89a3      	ldrh	r3, [r4, #12]
  4025ae:	065b      	lsls	r3, r3, #25
  4025b0:	f53f af7d 	bmi.w	4024ae <_vfiprintf_r+0xee>
  4025b4:	9809      	ldr	r0, [sp, #36]	; 0x24
  4025b6:	e77c      	b.n	4024b2 <_vfiprintf_r+0xf2>
  4025b8:	ab03      	add	r3, sp, #12
  4025ba:	9300      	str	r3, [sp, #0]
  4025bc:	4622      	mov	r2, r4
  4025be:	4b0a      	ldr	r3, [pc, #40]	; (4025e8 <_vfiprintf_r+0x228>)
  4025c0:	a904      	add	r1, sp, #16
  4025c2:	4630      	mov	r0, r6
  4025c4:	f000 f888 	bl	4026d8 <_printf_i>
  4025c8:	e7ec      	b.n	4025a4 <_vfiprintf_r+0x1e4>
  4025ca:	bf00      	nop
  4025cc:	00402d10 	.word	0x00402d10
  4025d0:	00402d50 	.word	0x00402d50
  4025d4:	00402d30 	.word	0x00402d30
  4025d8:	00402cf0 	.word	0x00402cf0
  4025dc:	00402d56 	.word	0x00402d56
  4025e0:	00402d5a 	.word	0x00402d5a
  4025e4:	00000000 	.word	0x00000000
  4025e8:	0040239d 	.word	0x0040239d

004025ec <_printf_common>:
  4025ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  4025f0:	4691      	mov	r9, r2
  4025f2:	461f      	mov	r7, r3
  4025f4:	688a      	ldr	r2, [r1, #8]
  4025f6:	690b      	ldr	r3, [r1, #16]
  4025f8:	f8dd 8020 	ldr.w	r8, [sp, #32]
  4025fc:	4293      	cmp	r3, r2
  4025fe:	bfb8      	it	lt
  402600:	4613      	movlt	r3, r2
  402602:	f8c9 3000 	str.w	r3, [r9]
  402606:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  40260a:	4606      	mov	r6, r0
  40260c:	460c      	mov	r4, r1
  40260e:	b112      	cbz	r2, 402616 <_printf_common+0x2a>
  402610:	3301      	adds	r3, #1
  402612:	f8c9 3000 	str.w	r3, [r9]
  402616:	6823      	ldr	r3, [r4, #0]
  402618:	0699      	lsls	r1, r3, #26
  40261a:	bf42      	ittt	mi
  40261c:	f8d9 3000 	ldrmi.w	r3, [r9]
  402620:	3302      	addmi	r3, #2
  402622:	f8c9 3000 	strmi.w	r3, [r9]
  402626:	6825      	ldr	r5, [r4, #0]
  402628:	f015 0506 	ands.w	r5, r5, #6
  40262c:	d107      	bne.n	40263e <_printf_common+0x52>
  40262e:	f104 0a19 	add.w	sl, r4, #25
  402632:	68e3      	ldr	r3, [r4, #12]
  402634:	f8d9 2000 	ldr.w	r2, [r9]
  402638:	1a9b      	subs	r3, r3, r2
  40263a:	429d      	cmp	r5, r3
  40263c:	db29      	blt.n	402692 <_printf_common+0xa6>
  40263e:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
  402642:	6822      	ldr	r2, [r4, #0]
  402644:	3300      	adds	r3, #0
  402646:	bf18      	it	ne
  402648:	2301      	movne	r3, #1
  40264a:	0692      	lsls	r2, r2, #26
  40264c:	d42e      	bmi.n	4026ac <_printf_common+0xc0>
  40264e:	f104 0243 	add.w	r2, r4, #67	; 0x43
  402652:	4639      	mov	r1, r7
  402654:	4630      	mov	r0, r6
  402656:	47c0      	blx	r8
  402658:	3001      	adds	r0, #1
  40265a:	d021      	beq.n	4026a0 <_printf_common+0xb4>
  40265c:	6823      	ldr	r3, [r4, #0]
  40265e:	68e5      	ldr	r5, [r4, #12]
  402660:	f8d9 2000 	ldr.w	r2, [r9]
  402664:	f003 0306 	and.w	r3, r3, #6
  402668:	2b04      	cmp	r3, #4
  40266a:	bf08      	it	eq
  40266c:	1aad      	subeq	r5, r5, r2
  40266e:	68a3      	ldr	r3, [r4, #8]
  402670:	6922      	ldr	r2, [r4, #16]
  402672:	bf0c      	ite	eq
  402674:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  402678:	2500      	movne	r5, #0
  40267a:	4293      	cmp	r3, r2
  40267c:	bfc4      	itt	gt
  40267e:	1a9b      	subgt	r3, r3, r2
  402680:	18ed      	addgt	r5, r5, r3
  402682:	f04f 0900 	mov.w	r9, #0
  402686:	341a      	adds	r4, #26
  402688:	454d      	cmp	r5, r9
  40268a:	d11b      	bne.n	4026c4 <_printf_common+0xd8>
  40268c:	2000      	movs	r0, #0
  40268e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402692:	2301      	movs	r3, #1
  402694:	4652      	mov	r2, sl
  402696:	4639      	mov	r1, r7
  402698:	4630      	mov	r0, r6
  40269a:	47c0      	blx	r8
  40269c:	3001      	adds	r0, #1
  40269e:	d103      	bne.n	4026a8 <_printf_common+0xbc>
  4026a0:	f04f 30ff 	mov.w	r0, #4294967295
  4026a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4026a8:	3501      	adds	r5, #1
  4026aa:	e7c2      	b.n	402632 <_printf_common+0x46>
  4026ac:	18e1      	adds	r1, r4, r3
  4026ae:	1c5a      	adds	r2, r3, #1
  4026b0:	2030      	movs	r0, #48	; 0x30
  4026b2:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  4026b6:	4422      	add	r2, r4
  4026b8:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  4026bc:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  4026c0:	3302      	adds	r3, #2
  4026c2:	e7c4      	b.n	40264e <_printf_common+0x62>
  4026c4:	2301      	movs	r3, #1
  4026c6:	4622      	mov	r2, r4
  4026c8:	4639      	mov	r1, r7
  4026ca:	4630      	mov	r0, r6
  4026cc:	47c0      	blx	r8
  4026ce:	3001      	adds	r0, #1
  4026d0:	d0e6      	beq.n	4026a0 <_printf_common+0xb4>
  4026d2:	f109 0901 	add.w	r9, r9, #1
  4026d6:	e7d7      	b.n	402688 <_printf_common+0x9c>

004026d8 <_printf_i>:
  4026d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  4026dc:	4617      	mov	r7, r2
  4026de:	7e0a      	ldrb	r2, [r1, #24]
  4026e0:	b085      	sub	sp, #20
  4026e2:	2a6e      	cmp	r2, #110	; 0x6e
  4026e4:	4698      	mov	r8, r3
  4026e6:	4606      	mov	r6, r0
  4026e8:	460c      	mov	r4, r1
  4026ea:	9b0c      	ldr	r3, [sp, #48]	; 0x30
  4026ec:	f101 0e43 	add.w	lr, r1, #67	; 0x43
  4026f0:	f000 80bc 	beq.w	40286c <_printf_i+0x194>
  4026f4:	d81a      	bhi.n	40272c <_printf_i+0x54>
  4026f6:	2a63      	cmp	r2, #99	; 0x63
  4026f8:	d02e      	beq.n	402758 <_printf_i+0x80>
  4026fa:	d80a      	bhi.n	402712 <_printf_i+0x3a>
  4026fc:	2a00      	cmp	r2, #0
  4026fe:	f000 80c8 	beq.w	402892 <_printf_i+0x1ba>
  402702:	2a58      	cmp	r2, #88	; 0x58
  402704:	f000 808a 	beq.w	40281c <_printf_i+0x144>
  402708:	f104 0542 	add.w	r5, r4, #66	; 0x42
  40270c:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
  402710:	e02a      	b.n	402768 <_printf_i+0x90>
  402712:	2a64      	cmp	r2, #100	; 0x64
  402714:	d001      	beq.n	40271a <_printf_i+0x42>
  402716:	2a69      	cmp	r2, #105	; 0x69
  402718:	d1f6      	bne.n	402708 <_printf_i+0x30>
  40271a:	6821      	ldr	r1, [r4, #0]
  40271c:	681a      	ldr	r2, [r3, #0]
  40271e:	f011 0f80 	tst.w	r1, #128	; 0x80
  402722:	d023      	beq.n	40276c <_printf_i+0x94>
  402724:	1d11      	adds	r1, r2, #4
  402726:	6019      	str	r1, [r3, #0]
  402728:	6813      	ldr	r3, [r2, #0]
  40272a:	e027      	b.n	40277c <_printf_i+0xa4>
  40272c:	2a73      	cmp	r2, #115	; 0x73
  40272e:	f000 80b4 	beq.w	40289a <_printf_i+0x1c2>
  402732:	d808      	bhi.n	402746 <_printf_i+0x6e>
  402734:	2a6f      	cmp	r2, #111	; 0x6f
  402736:	d02a      	beq.n	40278e <_printf_i+0xb6>
  402738:	2a70      	cmp	r2, #112	; 0x70
  40273a:	d1e5      	bne.n	402708 <_printf_i+0x30>
  40273c:	680a      	ldr	r2, [r1, #0]
  40273e:	f042 0220 	orr.w	r2, r2, #32
  402742:	600a      	str	r2, [r1, #0]
  402744:	e003      	b.n	40274e <_printf_i+0x76>
  402746:	2a75      	cmp	r2, #117	; 0x75
  402748:	d021      	beq.n	40278e <_printf_i+0xb6>
  40274a:	2a78      	cmp	r2, #120	; 0x78
  40274c:	d1dc      	bne.n	402708 <_printf_i+0x30>
  40274e:	2278      	movs	r2, #120	; 0x78
  402750:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
  402754:	496e      	ldr	r1, [pc, #440]	; (402910 <_printf_i+0x238>)
  402756:	e064      	b.n	402822 <_printf_i+0x14a>
  402758:	681a      	ldr	r2, [r3, #0]
  40275a:	f101 0542 	add.w	r5, r1, #66	; 0x42
  40275e:	1d11      	adds	r1, r2, #4
  402760:	6019      	str	r1, [r3, #0]
  402762:	6813      	ldr	r3, [r2, #0]
  402764:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  402768:	2301      	movs	r3, #1
  40276a:	e0a3      	b.n	4028b4 <_printf_i+0x1dc>
  40276c:	f011 0f40 	tst.w	r1, #64	; 0x40
  402770:	f102 0104 	add.w	r1, r2, #4
  402774:	6019      	str	r1, [r3, #0]
  402776:	d0d7      	beq.n	402728 <_printf_i+0x50>
  402778:	f9b2 3000 	ldrsh.w	r3, [r2]
  40277c:	2b00      	cmp	r3, #0
  40277e:	da03      	bge.n	402788 <_printf_i+0xb0>
  402780:	222d      	movs	r2, #45	; 0x2d
  402782:	425b      	negs	r3, r3
  402784:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
  402788:	4962      	ldr	r1, [pc, #392]	; (402914 <_printf_i+0x23c>)
  40278a:	220a      	movs	r2, #10
  40278c:	e017      	b.n	4027be <_printf_i+0xe6>
  40278e:	6820      	ldr	r0, [r4, #0]
  402790:	6819      	ldr	r1, [r3, #0]
  402792:	f010 0f80 	tst.w	r0, #128	; 0x80
  402796:	d003      	beq.n	4027a0 <_printf_i+0xc8>
  402798:	1d08      	adds	r0, r1, #4
  40279a:	6018      	str	r0, [r3, #0]
  40279c:	680b      	ldr	r3, [r1, #0]
  40279e:	e006      	b.n	4027ae <_printf_i+0xd6>
  4027a0:	f010 0f40 	tst.w	r0, #64	; 0x40
  4027a4:	f101 0004 	add.w	r0, r1, #4
  4027a8:	6018      	str	r0, [r3, #0]
  4027aa:	d0f7      	beq.n	40279c <_printf_i+0xc4>
  4027ac:	880b      	ldrh	r3, [r1, #0]
  4027ae:	4959      	ldr	r1, [pc, #356]	; (402914 <_printf_i+0x23c>)
  4027b0:	2a6f      	cmp	r2, #111	; 0x6f
  4027b2:	bf14      	ite	ne
  4027b4:	220a      	movne	r2, #10
  4027b6:	2208      	moveq	r2, #8
  4027b8:	2000      	movs	r0, #0
  4027ba:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
  4027be:	6865      	ldr	r5, [r4, #4]
  4027c0:	60a5      	str	r5, [r4, #8]
  4027c2:	2d00      	cmp	r5, #0
  4027c4:	f2c0 809c 	blt.w	402900 <_printf_i+0x228>
  4027c8:	6820      	ldr	r0, [r4, #0]
  4027ca:	f020 0004 	bic.w	r0, r0, #4
  4027ce:	6020      	str	r0, [r4, #0]
  4027d0:	2b00      	cmp	r3, #0
  4027d2:	d13f      	bne.n	402854 <_printf_i+0x17c>
  4027d4:	2d00      	cmp	r5, #0
  4027d6:	f040 8095 	bne.w	402904 <_printf_i+0x22c>
  4027da:	4675      	mov	r5, lr
  4027dc:	2a08      	cmp	r2, #8
  4027de:	d10b      	bne.n	4027f8 <_printf_i+0x120>
  4027e0:	6823      	ldr	r3, [r4, #0]
  4027e2:	07da      	lsls	r2, r3, #31
  4027e4:	d508      	bpl.n	4027f8 <_printf_i+0x120>
  4027e6:	6923      	ldr	r3, [r4, #16]
  4027e8:	6862      	ldr	r2, [r4, #4]
  4027ea:	429a      	cmp	r2, r3
  4027ec:	bfde      	ittt	le
  4027ee:	2330      	movle	r3, #48	; 0x30
  4027f0:	f805 3c01 	strble.w	r3, [r5, #-1]
  4027f4:	f105 35ff 	addle.w	r5, r5, #4294967295
  4027f8:	ebae 0305 	sub.w	r3, lr, r5
  4027fc:	6123      	str	r3, [r4, #16]
  4027fe:	f8cd 8000 	str.w	r8, [sp]
  402802:	463b      	mov	r3, r7
  402804:	aa03      	add	r2, sp, #12
  402806:	4621      	mov	r1, r4
  402808:	4630      	mov	r0, r6
  40280a:	f7ff feef 	bl	4025ec <_printf_common>
  40280e:	3001      	adds	r0, #1
  402810:	d155      	bne.n	4028be <_printf_i+0x1e6>
  402812:	f04f 30ff 	mov.w	r0, #4294967295
  402816:	b005      	add	sp, #20
  402818:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  40281c:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
  402820:	493c      	ldr	r1, [pc, #240]	; (402914 <_printf_i+0x23c>)
  402822:	6822      	ldr	r2, [r4, #0]
  402824:	6818      	ldr	r0, [r3, #0]
  402826:	f012 0f80 	tst.w	r2, #128	; 0x80
  40282a:	f100 0504 	add.w	r5, r0, #4
  40282e:	601d      	str	r5, [r3, #0]
  402830:	d001      	beq.n	402836 <_printf_i+0x15e>
  402832:	6803      	ldr	r3, [r0, #0]
  402834:	e002      	b.n	40283c <_printf_i+0x164>
  402836:	0655      	lsls	r5, r2, #25
  402838:	d5fb      	bpl.n	402832 <_printf_i+0x15a>
  40283a:	8803      	ldrh	r3, [r0, #0]
  40283c:	07d0      	lsls	r0, r2, #31
  40283e:	bf44      	itt	mi
  402840:	f042 0220 	orrmi.w	r2, r2, #32
  402844:	6022      	strmi	r2, [r4, #0]
  402846:	b91b      	cbnz	r3, 402850 <_printf_i+0x178>
  402848:	6822      	ldr	r2, [r4, #0]
  40284a:	f022 0220 	bic.w	r2, r2, #32
  40284e:	6022      	str	r2, [r4, #0]
  402850:	2210      	movs	r2, #16
  402852:	e7b1      	b.n	4027b8 <_printf_i+0xe0>
  402854:	4675      	mov	r5, lr
  402856:	fbb3 f0f2 	udiv	r0, r3, r2
  40285a:	fb02 3310 	mls	r3, r2, r0, r3
  40285e:	5ccb      	ldrb	r3, [r1, r3]
  402860:	f805 3d01 	strb.w	r3, [r5, #-1]!
  402864:	4603      	mov	r3, r0
  402866:	2800      	cmp	r0, #0
  402868:	d1f5      	bne.n	402856 <_printf_i+0x17e>
  40286a:	e7b7      	b.n	4027dc <_printf_i+0x104>
  40286c:	6808      	ldr	r0, [r1, #0]
  40286e:	681a      	ldr	r2, [r3, #0]
  402870:	6949      	ldr	r1, [r1, #20]
  402872:	f010 0f80 	tst.w	r0, #128	; 0x80
  402876:	d004      	beq.n	402882 <_printf_i+0x1aa>
  402878:	1d10      	adds	r0, r2, #4
  40287a:	6018      	str	r0, [r3, #0]
  40287c:	6813      	ldr	r3, [r2, #0]
  40287e:	6019      	str	r1, [r3, #0]
  402880:	e007      	b.n	402892 <_printf_i+0x1ba>
  402882:	f010 0f40 	tst.w	r0, #64	; 0x40
  402886:	f102 0004 	add.w	r0, r2, #4
  40288a:	6018      	str	r0, [r3, #0]
  40288c:	6813      	ldr	r3, [r2, #0]
  40288e:	d0f6      	beq.n	40287e <_printf_i+0x1a6>
  402890:	8019      	strh	r1, [r3, #0]
  402892:	2300      	movs	r3, #0
  402894:	6123      	str	r3, [r4, #16]
  402896:	4675      	mov	r5, lr
  402898:	e7b1      	b.n	4027fe <_printf_i+0x126>
  40289a:	681a      	ldr	r2, [r3, #0]
  40289c:	1d11      	adds	r1, r2, #4
  40289e:	6019      	str	r1, [r3, #0]
  4028a0:	6815      	ldr	r5, [r2, #0]
  4028a2:	6862      	ldr	r2, [r4, #4]
  4028a4:	2100      	movs	r1, #0
  4028a6:	4628      	mov	r0, r5
  4028a8:	f000 f8d2 	bl	402a50 <memchr>
  4028ac:	b108      	cbz	r0, 4028b2 <_printf_i+0x1da>
  4028ae:	1b40      	subs	r0, r0, r5
  4028b0:	6060      	str	r0, [r4, #4]
  4028b2:	6863      	ldr	r3, [r4, #4]
  4028b4:	6123      	str	r3, [r4, #16]
  4028b6:	2300      	movs	r3, #0
  4028b8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  4028bc:	e79f      	b.n	4027fe <_printf_i+0x126>
  4028be:	6923      	ldr	r3, [r4, #16]
  4028c0:	462a      	mov	r2, r5
  4028c2:	4639      	mov	r1, r7
  4028c4:	4630      	mov	r0, r6
  4028c6:	47c0      	blx	r8
  4028c8:	3001      	adds	r0, #1
  4028ca:	d0a2      	beq.n	402812 <_printf_i+0x13a>
  4028cc:	6823      	ldr	r3, [r4, #0]
  4028ce:	079b      	lsls	r3, r3, #30
  4028d0:	d507      	bpl.n	4028e2 <_printf_i+0x20a>
  4028d2:	2500      	movs	r5, #0
  4028d4:	f104 0919 	add.w	r9, r4, #25
  4028d8:	68e3      	ldr	r3, [r4, #12]
  4028da:	9a03      	ldr	r2, [sp, #12]
  4028dc:	1a9b      	subs	r3, r3, r2
  4028de:	429d      	cmp	r5, r3
  4028e0:	db05      	blt.n	4028ee <_printf_i+0x216>
  4028e2:	68e0      	ldr	r0, [r4, #12]
  4028e4:	9b03      	ldr	r3, [sp, #12]
  4028e6:	4298      	cmp	r0, r3
  4028e8:	bfb8      	it	lt
  4028ea:	4618      	movlt	r0, r3
  4028ec:	e793      	b.n	402816 <_printf_i+0x13e>
  4028ee:	2301      	movs	r3, #1
  4028f0:	464a      	mov	r2, r9
  4028f2:	4639      	mov	r1, r7
  4028f4:	4630      	mov	r0, r6
  4028f6:	47c0      	blx	r8
  4028f8:	3001      	adds	r0, #1
  4028fa:	d08a      	beq.n	402812 <_printf_i+0x13a>
  4028fc:	3501      	adds	r5, #1
  4028fe:	e7eb      	b.n	4028d8 <_printf_i+0x200>
  402900:	2b00      	cmp	r3, #0
  402902:	d1a7      	bne.n	402854 <_printf_i+0x17c>
  402904:	780b      	ldrb	r3, [r1, #0]
  402906:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  40290a:	f104 0542 	add.w	r5, r4, #66	; 0x42
  40290e:	e765      	b.n	4027dc <_printf_i+0x104>
  402910:	00402d72 	.word	0x00402d72
  402914:	00402d61 	.word	0x00402d61

00402918 <__sread>:
  402918:	b510      	push	{r4, lr}
  40291a:	460c      	mov	r4, r1
  40291c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402920:	f000 f8e6 	bl	402af0 <_read_r>
  402924:	2800      	cmp	r0, #0
  402926:	bfab      	itete	ge
  402928:	6d63      	ldrge	r3, [r4, #84]	; 0x54
  40292a:	89a3      	ldrhlt	r3, [r4, #12]
  40292c:	181b      	addge	r3, r3, r0
  40292e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
  402932:	bfac      	ite	ge
  402934:	6563      	strge	r3, [r4, #84]	; 0x54
  402936:	81a3      	strhlt	r3, [r4, #12]
  402938:	bd10      	pop	{r4, pc}

0040293a <__swrite>:
  40293a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  40293e:	461f      	mov	r7, r3
  402940:	898b      	ldrh	r3, [r1, #12]
  402942:	05db      	lsls	r3, r3, #23
  402944:	4605      	mov	r5, r0
  402946:	460c      	mov	r4, r1
  402948:	4616      	mov	r6, r2
  40294a:	d505      	bpl.n	402958 <__swrite+0x1e>
  40294c:	2302      	movs	r3, #2
  40294e:	2200      	movs	r2, #0
  402950:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  402954:	f000 f868 	bl	402a28 <_lseek_r>
  402958:	89a3      	ldrh	r3, [r4, #12]
  40295a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
  40295e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  402962:	81a3      	strh	r3, [r4, #12]
  402964:	4632      	mov	r2, r6
  402966:	463b      	mov	r3, r7
  402968:	4628      	mov	r0, r5
  40296a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40296e:	f000 b817 	b.w	4029a0 <_write_r>

00402972 <__sseek>:
  402972:	b510      	push	{r4, lr}
  402974:	460c      	mov	r4, r1
  402976:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40297a:	f000 f855 	bl	402a28 <_lseek_r>
  40297e:	1c43      	adds	r3, r0, #1
  402980:	89a3      	ldrh	r3, [r4, #12]
  402982:	bf15      	itete	ne
  402984:	6560      	strne	r0, [r4, #84]	; 0x54
  402986:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
  40298a:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
  40298e:	81a3      	strheq	r3, [r4, #12]
  402990:	bf18      	it	ne
  402992:	81a3      	strhne	r3, [r4, #12]
  402994:	bd10      	pop	{r4, pc}

00402996 <__sclose>:
  402996:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
  40299a:	f000 b813 	b.w	4029c4 <_close_r>
	...

004029a0 <_write_r>:
  4029a0:	b538      	push	{r3, r4, r5, lr}
  4029a2:	4c07      	ldr	r4, [pc, #28]	; (4029c0 <_write_r+0x20>)
  4029a4:	4605      	mov	r5, r0
  4029a6:	4608      	mov	r0, r1
  4029a8:	4611      	mov	r1, r2
  4029aa:	2200      	movs	r2, #0
  4029ac:	6022      	str	r2, [r4, #0]
  4029ae:	461a      	mov	r2, r3
  4029b0:	f7ff f820 	bl	4019f4 <_write>
  4029b4:	1c43      	adds	r3, r0, #1
  4029b6:	d102      	bne.n	4029be <_write_r+0x1e>
  4029b8:	6823      	ldr	r3, [r4, #0]
  4029ba:	b103      	cbz	r3, 4029be <_write_r+0x1e>
  4029bc:	602b      	str	r3, [r5, #0]
  4029be:	bd38      	pop	{r3, r4, r5, pc}
  4029c0:	2040011c 	.word	0x2040011c

004029c4 <_close_r>:
  4029c4:	b538      	push	{r3, r4, r5, lr}
  4029c6:	4c06      	ldr	r4, [pc, #24]	; (4029e0 <_close_r+0x1c>)
  4029c8:	2300      	movs	r3, #0
  4029ca:	4605      	mov	r5, r0
  4029cc:	4608      	mov	r0, r1
  4029ce:	6023      	str	r3, [r4, #0]
  4029d0:	f7fe f876 	bl	400ac0 <_close>
  4029d4:	1c43      	adds	r3, r0, #1
  4029d6:	d102      	bne.n	4029de <_close_r+0x1a>
  4029d8:	6823      	ldr	r3, [r4, #0]
  4029da:	b103      	cbz	r3, 4029de <_close_r+0x1a>
  4029dc:	602b      	str	r3, [r5, #0]
  4029de:	bd38      	pop	{r3, r4, r5, pc}
  4029e0:	2040011c 	.word	0x2040011c

004029e4 <_fstat_r>:
  4029e4:	b538      	push	{r3, r4, r5, lr}
  4029e6:	4c07      	ldr	r4, [pc, #28]	; (402a04 <_fstat_r+0x20>)
  4029e8:	2300      	movs	r3, #0
  4029ea:	4605      	mov	r5, r0
  4029ec:	4608      	mov	r0, r1
  4029ee:	4611      	mov	r1, r2
  4029f0:	6023      	str	r3, [r4, #0]
  4029f2:	f7fe f868 	bl	400ac6 <_fstat>
  4029f6:	1c43      	adds	r3, r0, #1
  4029f8:	d102      	bne.n	402a00 <_fstat_r+0x1c>
  4029fa:	6823      	ldr	r3, [r4, #0]
  4029fc:	b103      	cbz	r3, 402a00 <_fstat_r+0x1c>
  4029fe:	602b      	str	r3, [r5, #0]
  402a00:	bd38      	pop	{r3, r4, r5, pc}
  402a02:	bf00      	nop
  402a04:	2040011c 	.word	0x2040011c

00402a08 <_isatty_r>:
  402a08:	b538      	push	{r3, r4, r5, lr}
  402a0a:	4c06      	ldr	r4, [pc, #24]	; (402a24 <_isatty_r+0x1c>)
  402a0c:	2300      	movs	r3, #0
  402a0e:	4605      	mov	r5, r0
  402a10:	4608      	mov	r0, r1
  402a12:	6023      	str	r3, [r4, #0]
  402a14:	f7fe f85c 	bl	400ad0 <_isatty>
  402a18:	1c43      	adds	r3, r0, #1
  402a1a:	d102      	bne.n	402a22 <_isatty_r+0x1a>
  402a1c:	6823      	ldr	r3, [r4, #0]
  402a1e:	b103      	cbz	r3, 402a22 <_isatty_r+0x1a>
  402a20:	602b      	str	r3, [r5, #0]
  402a22:	bd38      	pop	{r3, r4, r5, pc}
  402a24:	2040011c 	.word	0x2040011c

00402a28 <_lseek_r>:
  402a28:	b538      	push	{r3, r4, r5, lr}
  402a2a:	4c07      	ldr	r4, [pc, #28]	; (402a48 <_lseek_r+0x20>)
  402a2c:	4605      	mov	r5, r0
  402a2e:	4608      	mov	r0, r1
  402a30:	4611      	mov	r1, r2
  402a32:	2200      	movs	r2, #0
  402a34:	6022      	str	r2, [r4, #0]
  402a36:	461a      	mov	r2, r3
  402a38:	f7fe f84c 	bl	400ad4 <_lseek>
  402a3c:	1c43      	adds	r3, r0, #1
  402a3e:	d102      	bne.n	402a46 <_lseek_r+0x1e>
  402a40:	6823      	ldr	r3, [r4, #0]
  402a42:	b103      	cbz	r3, 402a46 <_lseek_r+0x1e>
  402a44:	602b      	str	r3, [r5, #0]
  402a46:	bd38      	pop	{r3, r4, r5, pc}
  402a48:	2040011c 	.word	0x2040011c
  402a4c:	00000000 	.word	0x00000000

00402a50 <memchr>:
  402a50:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  402a54:	2a10      	cmp	r2, #16
  402a56:	db2b      	blt.n	402ab0 <memchr+0x60>
  402a58:	f010 0f07 	tst.w	r0, #7
  402a5c:	d008      	beq.n	402a70 <memchr+0x20>
  402a5e:	f810 3b01 	ldrb.w	r3, [r0], #1
  402a62:	3a01      	subs	r2, #1
  402a64:	428b      	cmp	r3, r1
  402a66:	d02d      	beq.n	402ac4 <memchr+0x74>
  402a68:	f010 0f07 	tst.w	r0, #7
  402a6c:	b342      	cbz	r2, 402ac0 <memchr+0x70>
  402a6e:	d1f6      	bne.n	402a5e <memchr+0xe>
  402a70:	b4f0      	push	{r4, r5, r6, r7}
  402a72:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  402a76:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  402a7a:	f022 0407 	bic.w	r4, r2, #7
  402a7e:	f07f 0700 	mvns.w	r7, #0
  402a82:	2300      	movs	r3, #0
  402a84:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  402a88:	3c08      	subs	r4, #8
  402a8a:	ea85 0501 	eor.w	r5, r5, r1
  402a8e:	ea86 0601 	eor.w	r6, r6, r1
  402a92:	fa85 f547 	uadd8	r5, r5, r7
  402a96:	faa3 f587 	sel	r5, r3, r7
  402a9a:	fa86 f647 	uadd8	r6, r6, r7
  402a9e:	faa5 f687 	sel	r6, r5, r7
  402aa2:	b98e      	cbnz	r6, 402ac8 <memchr+0x78>
  402aa4:	d1ee      	bne.n	402a84 <memchr+0x34>
  402aa6:	bcf0      	pop	{r4, r5, r6, r7}
  402aa8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  402aac:	f002 0207 	and.w	r2, r2, #7
  402ab0:	b132      	cbz	r2, 402ac0 <memchr+0x70>
  402ab2:	f810 3b01 	ldrb.w	r3, [r0], #1
  402ab6:	3a01      	subs	r2, #1
  402ab8:	ea83 0301 	eor.w	r3, r3, r1
  402abc:	b113      	cbz	r3, 402ac4 <memchr+0x74>
  402abe:	d1f8      	bne.n	402ab2 <memchr+0x62>
  402ac0:	2000      	movs	r0, #0
  402ac2:	4770      	bx	lr
  402ac4:	3801      	subs	r0, #1
  402ac6:	4770      	bx	lr
  402ac8:	2d00      	cmp	r5, #0
  402aca:	bf06      	itte	eq
  402acc:	4635      	moveq	r5, r6
  402ace:	3803      	subeq	r0, #3
  402ad0:	3807      	subne	r0, #7
  402ad2:	f015 0f01 	tst.w	r5, #1
  402ad6:	d107      	bne.n	402ae8 <memchr+0x98>
  402ad8:	3001      	adds	r0, #1
  402ada:	f415 7f80 	tst.w	r5, #256	; 0x100
  402ade:	bf02      	ittt	eq
  402ae0:	3001      	addeq	r0, #1
  402ae2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  402ae6:	3001      	addeq	r0, #1
  402ae8:	bcf0      	pop	{r4, r5, r6, r7}
  402aea:	3801      	subs	r0, #1
  402aec:	4770      	bx	lr
  402aee:	bf00      	nop

00402af0 <_read_r>:
  402af0:	b538      	push	{r3, r4, r5, lr}
  402af2:	4c07      	ldr	r4, [pc, #28]	; (402b10 <_read_r+0x20>)
  402af4:	4605      	mov	r5, r0
  402af6:	4608      	mov	r0, r1
  402af8:	4611      	mov	r1, r2
  402afa:	2200      	movs	r2, #0
  402afc:	6022      	str	r2, [r4, #0]
  402afe:	461a      	mov	r2, r3
  402b00:	f7fe ff66 	bl	4019d0 <_read>
  402b04:	1c43      	adds	r3, r0, #1
  402b06:	d102      	bne.n	402b0e <_read_r+0x1e>
  402b08:	6823      	ldr	r3, [r4, #0]
  402b0a:	b103      	cbz	r3, 402b0e <_read_r+0x1e>
  402b0c:	602b      	str	r3, [r5, #0]
  402b0e:	bd38      	pop	{r3, r4, r5, pc}
  402b10:	2040011c 	.word	0x2040011c
  402b14:	682f2e2e 	.word	0x682f2e2e
  402b18:	732f6c61 	.word	0x732f6c61
  402b1c:	682f6372 	.word	0x682f6372
  402b20:	695f6c61 	.word	0x695f6c61
  402b24:	6d5f6332 	.word	0x6d5f6332
  402b28:	6e79735f 	.word	0x6e79735f
  402b2c:	00632e63 	.word	0x00632e63
  402b30:	682f2e2e 	.word	0x682f2e2e
  402b34:	732f6c61 	.word	0x732f6c61
  402b38:	682f6372 	.word	0x682f6372
  402b3c:	695f6c61 	.word	0x695f6c61
  402b40:	00632e6f 	.word	0x00632e6f
  402b44:	682f2e2e 	.word	0x682f2e2e
  402b48:	732f6c61 	.word	0x732f6c61
  402b4c:	682f6372 	.word	0x682f6372
  402b50:	705f6c61 	.word	0x705f6c61
  402b54:	632e6d77 	.word	0x632e6d77
  402b58:	00000000 	.word	0x00000000
  402b5c:	682f2e2e 	.word	0x682f2e2e
  402b60:	732f6c61 	.word	0x732f6c61
  402b64:	682f6372 	.word	0x682f6372
  402b68:	735f6c61 	.word	0x735f6c61
  402b6c:	6d5f6970 	.word	0x6d5f6970
  402b70:	6e79735f 	.word	0x6e79735f
  402b74:	00632e63 	.word	0x00632e63
  402b78:	682f2e2e 	.word	0x682f2e2e
  402b7c:	732f6c61 	.word	0x732f6c61
  402b80:	682f6372 	.word	0x682f6372
  402b84:	755f6c61 	.word	0x755f6c61
  402b88:	74726173 	.word	0x74726173
  402b8c:	6e79735f 	.word	0x6e79735f
  402b90:	00632e63 	.word	0x00632e63

00402b94 <_ext_irq>:
  402b94:	00000000 00000020 00000020 00000020     .... ... ... ...
	...
  402bac:	00000020 00000001 00000002 00000002      ...............
  402bbc:	00000002 00000000 00000000 00000002     ................

00402bcc <_pio_irq_n>:
  402bcc:	100c0b0a 00000011 682f2e2e 702f6c70     ........../hpl/p
  402bdc:	682f6f69 705f6c70 655f6f69 632e7478     io/hpl_pio_ext.c
  402bec:	00000000                                ....

00402bf0 <_pwms>:
  402bf0:	40020000 0000001f 00010001 00000001     ...@............
  402c00:	00000001 000000ff 00000000 00000004     ................
	...
  402c1c:	00000001 00402c2c 00000000 204000a0     ....,,@.......@ 

00402c2c <_ch_cfg0>:
  402c2c:	00000000 0000020a 00000400 00000200     ................
  402c3c:	682f2e2e 702f6c70 682f6d77 705f6c70     ../hpl/pwm/hpl_p
  402c4c:	632e6d77 00000000                       wm.c....

00402c54 <spi_regs>:
  402c54:	00000000 80000000 00000001 0496fa02     ................
  402c64:	0000ffff 682f2e2e 732f6c70 682f6970     ....../hpl/spi/h
  402c74:	735f6c70 632e6970 00000000              pl_spi.c....

00402c80 <_i2cm_sync_cfgs>:
  402c80:	40018000 00000020 00000000 00000000     ...@ ...........
  402c90:	0002baba 000249f0 682f2e2e 742f6c70     .....I..../hpl/t
  402ca0:	73686977 6c70682f 6977745f 632e7368     wihs/hpl_twihs.c
  402cb0:	00000000                                ....

00402cb4 <_usarts>:
  402cb4:	00000001 001008c0 000100f4 682f2e2e     ............../h
  402cc4:	752f6c70 74726173 6c70682f 6173755f     pl/usart/hpl_usa
  402cd4:	632e7472 00000000 0a0d7325 00000000     rt.c....%s......
  402ce4:	bbccddee 000000aa                       ........

00402cec <_global_impure_ptr>:
  402cec:	20400004                                ..@ 

00402cf0 <__sf_fake_stderr>:
	...

00402d10 <__sf_fake_stdin>:
	...

00402d30 <__sf_fake_stdout>:
	...
  402d50:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
  402d60:	32313000 36353433 41393837 45444342     .0123456789ABCDE
  402d70:	31300046 35343332 39383736 64636261     F.0123456789abcd
  402d80:	00006665                                ef..

00402d84 <_init>:
  402d84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402d86:	bf00      	nop
  402d88:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402d8a:	bc08      	pop	{r3}
  402d8c:	469e      	mov	lr, r3
  402d8e:	4770      	bx	lr

00402d90 <__init_array_start>:
  402d90:	0040018d 	.word	0x0040018d

00402d94 <_fini>:
  402d94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  402d96:	bf00      	nop
  402d98:	bcf8      	pop	{r3, r4, r5, r6, r7}
  402d9a:	bc08      	pop	{r3}
  402d9c:	469e      	mov	lr, r3
  402d9e:	4770      	bx	lr

00402da0 <__fini_array_start>:
  402da0:	00400169 	.word	0x00400169
